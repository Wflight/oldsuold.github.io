<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【luogu-5091】【模板】欧拉定理]]></title>
    <url>%2F2019%2F08%2F17%2F%E3%80%90luogu-5091%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于欧拉定理定义$\varphi(n)​$表示在区间$[1, n - 1]​$所有整数中，与$n​$互质的数字个数。 通项公式$$ \varphi(x) = x \times \prod_{1}^{n}(1 - \frac{1}{p_i})​$$ 性质 $a^b\equiv \left{ \begin{aligned} a^{b%\varphi(n)} (\bmod\ n)\ \ \ \ \ \ \ \ \ \ b&lt;\varphi(n)\ a^{b%\varphi(n)+\varphi(n)}(\bmod\ n)\ \ b\geq\varphi(n) \end{aligned} \right.$ 积性函数： $gcd(a, b) = 1​$时，$ \varphi(a) \times \varphi(b) = \varphi(a \times b)​$ $p$为素数时，$\varphi(p) = p - 1$、$\varphi(p^k) = p^k - p^{k - 1}$ $n &gt; 2​$时，$\varphi(n)​$为偶数。因为$gcd(n, m) = 1​$那么$gcd(m, n - m) = 1​$，即互质的数字总是成对出现。 小于 $n$ 的数中，与 $n$互质的数的总和为 $\varphi(n) \times \frac {n}{2}$ $n​$ 的因数（包括$1​$和本身）的欧拉函数之和等于 $n$求法123456789101112131415int phi(int val)&#123; int ans = val; for(int i = 2;i * i &lt;= val;i++) &#123; if(val % i == 0) &#123; ans = ans - ans / i; while(val % i == 0) val /= i; &#125; &#125; if(val &gt; 1) ans = ans - ans / val; return ans; &#125; 模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*! * FileName: luogu-5091.cpp * This Problem is on luogu. The ID of the problem is 5091. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-15 21:21:04 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int phi(int val)&#123; int ans = val; for(int i = 2;i * i &lt;= val;i++) &#123; if(val % i == 0) &#123; ans = ans - ans / i; while(val % i == 0) val /= i; &#125; &#125; if(val &gt; 1) ans = ans - ans / val; return ans; &#125;int a, m, ph;int IsBiger = false;int getB()&#123; int ans = 0; int MOD = ph; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3); ans += (c - '0'); if(ans &gt; ans % MOD) IsBiger = true; ans %= MOD; c = getchar(); &#125;// cout&lt;&lt;"% = "&lt;&lt;MOD&lt;&lt;" ^ = "&lt;&lt;ans&lt;&lt;endl; return ans % MOD;&#125; int ksm(int a, int b, int p)&#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = (ans * 1LL * a) % p; a = (a * 1LL * a) % p; b &gt;&gt;= 1; &#125; return ans % p;&#125;int main()&#123; a = read(), m = read(); ph = phi(m); int b = getB();// printf("%d %d %d\n", a, b + ph, m); if(IsBiger) printf("%d", ksm(a, b + ph, m)); else printf("%d", ksm(a, b, m)); return 0;&#125; WARNING注意分$b &lt; \varphi(n)$和$b &gt;= \varphi(n)$两种情况。指数较大时，指数$b % \varphi(n) + \varphi(n)​$]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4549】【模板】裴蜀定理]]></title>
    <url>%2F2019%2F08%2F15%2F%E3%80%90luogu-4549%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于题目$$S = \sum_{1}^{n} (A_i \cdot S_i),S &gt; 0$$ 给出序列$A$,求最小的$S$。 关于裴蜀已知方程$ax + by = c$，只有$c$是$(a, b)$的倍数时，此方程才有正整数解。 我自己的想法 已知$a \cdot x + b \cdot y = (a, b)$ 设$c = (a, b) \times k​$ 所以$ak \cdot x + bk \cdot y = c​$ 也就是新的$a’x + b’y = c$ 于是成功证明了“$c$是$(a, b)$的倍数”是“$ax + by = c$有解”的必要条件……。 很好。（个鬼）。 关于本题多个数和两个数是一样的。若想使$\sum_{1}^{n} (A_i \cdot S_i) = S$有解，那么$S$必须是$(a, b)$的倍数，$S$又要最小，很好，一倍不就完了。 对数列$A$去$gcd$就是答案 负数取绝对值就好了，系数能变成负数。 123456789101112131415161718192021222324252627282930313233343536373839404142/*! * FileName: luogu-4549.cpp * This Problem is on luogu. The ID of the problem is 4549. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-15 20:30:54 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int gcd(int a, int b)&#123;return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; int n = read(); int ans = 0; while(n--) &#123; int x = abs(read()); ans = gcd(ans, x); &#125; printf("%d", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3386】【模板】二分图匹配]]></title>
    <url>%2F2019%2F08%2F15%2F%E3%80%90luogu-3386%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*! * FileName: luogu-3386.cpp * This Problem is on luogu. The ID of the problem is 3386. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-15 17:21:05 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 4100;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m;vector&lt;int&gt;G[_];bool vis[_];int with[_];bool find(int now)&#123; for(register int i = 0;i &lt; G[now].size();i++) &#123; int exNode = G[now][i]; if(!vis[exNode]) &#123; vis[exNode] = true; if(with[exNode] == 0 || find(with[exNode])) &#123; with[now] = exNode; with[exNode] = now; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; n = read(), m = read(); int e = read(); for(register int i = 1;i &lt;= e;i++) &#123; int u = read(); int v = read(); if(u &gt; n || v &gt; m) continue; G[u].push_back(n + v); G[n + v].push_back(u); &#125; int tot = 0; for(register int i = 1;i &lt;= n;i++) &#123; memset(vis, false, sizeof(vis)); if(find(i)) tot++; &#125; printf("%d", tot); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2746】【USACO5.3】Network of Schools]]></title>
    <url>%2F2019%2F08%2F15%2F%E3%80%90luogu-2746%E3%80%91%E3%80%90USACO5-3%E3%80%91Network-of-Schools%2F</url>
    <content type="text"><![CDATA[写在前面Tarjan缩点经典问题，证明其他题解已经泛滥了。。。我写一写我自己想法。 技巧（KEYS） 任务A：入读为$0$的点的个数 任务B: 求入度为$0$的点数与出度为0的点的个数的最大值值。 缩完点之后，可以使用set去除重复的边，进行重新建图。QAQ 好方便！ 注意需要注意缩完点之后，只剩下一个点的情况QAQ不判断会WA一个点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/*! * FileName: luogu-2746.cpp * This Problem is on luogu. The ID of the problem is 2746. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-13 21:37:29 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 110;const int _M = _N * _N;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v;&#125;int n;int dfn[_N];int low[_N];int dfnClock = 0;int scc[_N];int sccCnt = 0;stack &lt;int&gt; S;void tarjan(int now)&#123; low[now] = dfn[now] = ++dfnClock; S.push(now); for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dfn[exNode] == 0) &#123; tarjan(exNode); low[now] = min(low[now], low[exNode]); &#125; else if(scc[exNode] == 0) low[now] = min(low[now], dfn[exNode]); &#125; if(low[now] == dfn[now]) &#123; sccCnt ++; while(true) &#123; scc[S.top()] = sccCnt; if(S.top() == now) &#123; S.pop(); break; &#125; S.pop(); &#125; &#125;&#125;int outd[_N];int ind[_N];int main()&#123; n = read(); for(register int i = 1;i &lt;= n;i++) &#123; int tmp; while(true) &#123; tmp = read(); if(tmp == 0) break; add(i, tmp); &#125; &#125; for(register int i = 1;i &lt;= n;i++) if(dfn[i] == 0) tarjan(i); set&lt;pair&lt;int,int&gt; &gt; S; for(register int i = 1;i &lt;= n;i++) &#123; for(register int j = head[i];j;j = edge[j].nxt) &#123; int exNode = edge[j].node; if(scc[i] != scc[exNode]) S.insert(make_pair(scc[i], scc[exNode])); &#125; &#125; for(set&lt;pair&lt;int, int &gt; &gt;::iterator i = S.begin();i != S.end();i++) &#123; outd[(*i).first] ++; ind[(*i).second] ++; &#125; int ans1 = 0; int ans2 = 0; for(register int i = 1;i &lt;= sccCnt;i++) &#123; if(ind[i] == 0) ans1 ++; if(outd[i] == 0) ans2 ++; &#125; printf("%d\n%d\n", ans1, sccCnt == 1 ? 0 : max(ans1, ans2)) ; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3203】【HNOI2010】弹飞绵羊]]></title>
    <url>%2F2019%2F08%2F15%2F%E3%80%90luogu-3203%E3%80%91%E3%80%90HNOI2010%E3%80%91%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A%2F</url>
    <content type="text"><![CDATA[分块，代码思路很明显。 有很多细节，注意分块维护要维护整个区间的信息，不要只修改一个点。 细节死亡…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/*! * FileName: luogu-3203.cpp * This Problem is on luogu. The ID of the problem is 3203. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-14 10:18:06 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 201000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m;int num;int belong[_];int step[_];int NxtNode[_];int block;void updata(int x)&#123; int node = x; int sk = belong[x]; int S = 0; while(belong[x] == sk) &#123; S += step[x]; x = NxtNode[x]; &#125; step[node] = S; NxtNode[node] = x;&#125;int query(int x)&#123; int ans = 0; while(x &lt;= n) &#123; ans += step[x]; x = NxtNode[x]; &#125; return ans;&#125;int SP[_]; int main()&#123;// freopen("data.in", "r", stdin); n = read();block = sqrt(n); for(register int i = 1;i &lt;= n;i++) &#123; int tmp = read(); SP[i] = tmp; NxtNode[i] = tmp + i; step[i] = 1; &#125; num = 1; for(register int i = 1;i &lt;= n;i++) belong[i] = (i &gt; num * block) ? (++ num) : num; for(register int i = n;i &gt;= 1;i--) updata(i);// cout&lt;&lt;"belong: " ; for(register int i = 1;i &lt;= n;i++) printf("%d ", belong[i]) ;cout&lt;&lt;endl;// for(register int i = 1;i &lt;= n;i++)// &#123;// printf(":%d : ", i);// printf("step = %d, ", step[i]);// printf("NxtNode = %d \n", NxtNode[i]);// &#125; m = read(); while(m --) &#123; int opt = read(); if(opt == 1) &#123; int x = read() + 1; int ans = query(x); printf("%d\n", ans); &#125; if(opt == 2) &#123; int x = read() + 1; int val = read(); SP[x] = val; NxtNode[x] = x + val; step[x] = 1;// int nowk = belong[x]; int L = ((belong[x] - 1) * block) + 1; int R = ((belong[x]) * block);// printf("Updata %d to %d\n", x, L); for(register int i = L;i &lt;= R;i++) step[i] = 1, NxtNode[i] = i + SP[i]; for(register int i = x;i &gt;= L;i--) updata(i);// for(register int i = 1;i &lt;= n;i++)// &#123;// printf(":%d : ", i);// printf("step = %d, ", step[i]);// printf("NxtNode = %d \n", NxtNode[i]);// &#125;// &#125; &#125; return 0;&#125;/*61 2 3 2 5 1*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3469 】【POI2008】BLO-Blockade]]></title>
    <url>%2F2019%2F08%2F15%2F%E3%80%90luogu-3469-%E3%80%91%E3%80%90POI2008%E3%80%91BLO-Blockade%2F</url>
    <content type="text"><![CDATA[写在前面这是一道剖析算法本质的题目 关于Tarjan Tarjan的本质就是一个DFS ——苟新杰老师 既然是DFS，那么在执行的过程中会形成一颗DFS树。如果这个树点是一个割点，那么思考一下这个点的几个孩子是什么？ Tarjan过程中形成的DFS树，如果这个点是割点，那么这个点的孩子们就是删去这个点后断开的几部分。 为什么？假设这个点的孩子（子树）分别有SonTree1、SonTree2 和SonTree3。SonTree1、SonTree2 和SonTree3不会属于一个强连通分量。因为如果这些儿子属于一个强连通分量，那么在遍历第一个儿子(SonTree1)的时候，其他儿子(SonTree2 和SonTree3)一定能被便利到，而绝对不会成为当前点的子树。 关于本题两种情况： 如果当前点不是割点，那么删去之后影响不大，只能导致当前被封锁的点到不了其他点，其他点也到不了当前被封锁的点。 如果当前点是割点，那么删去之后会断成几大块儿。对于每一块，到剩下的每一个不属于这一块儿的点都不能继续拜访，设这一块大小为$S$，总点数为$n$，那么这一块儿产生的不能拜访数为： $$Ans += S \times (n - s)$$对每一块儿都要这么做。统计答案即可。注意：这个点上面的所有也是一块儿，大小计算方法与求树的重心类似。就是用总点数减去当前点为根的子树大小。 关于代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/*! * FileName: luogu-3469.cpp * This Problem is on luogu. The ID of the problem is 3469. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-13 08:29:07 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 110000;const int _M = 1010000 ;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_N];int tot = 0;struct edges&#123; int node; int nxt;&#125;edge[_M];void add(int u, int v)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v;&#125;int n, m;int dfn[_N];int low[_N];int dfnClock = 0; bool isCut[_N];int size[_N];int Ans[_N];void tarjan(int now, int fa)&#123; low[now] = dfn[now] = ++dfnClock; size[now] = 1; int child = 0; Ans[now] = 0; int SumForSon = 0; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dfn[exNode] == 0) &#123; child ++; tarjan(exNode, now); size[now] += size[exNode]; low[now] = min(low[now], low[exNode]); if(low[exNode] &gt;= dfn[now]) &#123; SumForSon += size[exNode]; Ans[now] += (size[exNode] * (n - size[exNode])); isCut[now] = true; &#125; &#125; else low[now] = min(low[now], dfn[exNode]); &#125; if(child &lt; 2 &amp;&amp; fa &lt; 0) isCut[now] = false; if(!isCut[now]) Ans[now] = (n - 1) &lt;&lt; 1; else Ans[now] += (n - SumForSon - 1) * (SumForSon + 1) + (n - 1);&#125;signed main()&#123; n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(); add(tmpx, tmpy); add(tmpy, tmpx); &#125; memset(isCut, false, sizeof(isCut)); tarjan(1, -1); for(register int i = 1;i &lt;= n;i++) printf("%lld\n", Ans[i]); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2341】【HAOI2006】受欢迎的牛]]></title>
    <url>%2F2019%2F08%2F10%2F%E3%80%90luogu-2341%E3%80%91%E3%80%90HAOI2006%E3%80%91%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[题目描述每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶 牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜 欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你 算出有多少头奶牛可以当明星。 输入格式 第一行：两个用空格分开的整数：N和M 第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B 输出格式 第一行：单独一个整数，表示明星奶牛的数量 思路如果存在环，那么环上的点相当于同一头牛。 缩点之后的判断即可 注意关于本题判断是否合法。 我有两种判断方法： 12345if(outd[i] &gt; 1)//缩点完成之后，找到一个出度大于1的点，就GG&#123; puts("0"); return 0;&#125; 或者 判断出度为0的点的个数是否为1 第一种是错的，一开始我觉得当这张图是一条链，才合法。但是并不是，只要保证最后的结束点唯一即可，中间有多少曲折都没必要管，如图： 所以这种方法是错误的： 12345if(outd[i] &gt; 1)//缩点完成之后，找到一个出度大于1的点，就GG&#123; puts("0"); return 0;&#125; CODE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/*! * FileName: luogu-2341.cpp * This Problem is on luogu. The ID of the problem is 2341. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-08 21:41:00 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 11000;const int _M = 51000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int sccNo[_N];int sccCnt = 0;int dfn[_N];int low[_N];int dfsClock = 0;stack&lt;int&gt;S;int maxN = 0;int Val[_N];void tarjan(int now)&#123; maxN = max(maxN, dfn[now] = low[now] = ++ dfsClock); S.push(now); for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dfn[exNode] == 0) &#123; tarjan(exNode); low[now] = min(low[now], low[exNode]); &#125; else if(sccNo[exNode] == 0)&#123; low[now] = min(low[now], dfn[exNode]); &#125; &#125; if(low[now] == dfn[now]) &#123; ++ sccCnt; while(true) &#123; sccNo[S.top()] = sccCnt; if(S.top() == now) &#123; S.pop(); break; &#125; S.pop(); &#125; &#125;&#125;set&lt;pair&lt;int, int &gt; &gt; _S;//int ind[_N];int outd[_N]; int main()&#123; int root = 0; int n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(); root = tmpx; add(tmpx, tmpy); &#125; for(register int i = 1;i &lt;= n;i++) if(dfn[i] == 0) tarjan(i); for(register int i = 1;i &lt;= n;i++) &#123; for(register int j = head[i];j;j = edge[j].nxt) &#123; int exNode = edge[j].node; if(sccNo[i] != sccNo[exNode]) _S.insert(make_pair(sccNo[i], sccNo[exNode])); &#125; &#125; for(set&lt;pair&lt;int, int &gt; &gt; :: iterator i = _S.begin();i != _S.end();i++) outd[(*i).first]++; for(register int i = 1;i &lt;= n;i++) Val[sccNo[i]]++; int ans = 0; int isZero = 0; for(register int i = 1;i &lt;= sccCnt;i++) &#123;// if(outd[i] &gt; 1)// &#123;// puts("0");// return 0;// &#125; if(outd[i] == 0) &#123; isZero ++; ans = Val[i]; &#125; &#125; if(isZero == 1) printf("%d\n",ans); else puts("0"); return 0;&#125; 注意那个那个，用set统计缩完点之后的边超级方便]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1993】小K的农场]]></title>
    <url>%2F2019%2F08%2F06%2F%E3%80%90luogu-1993%E3%80%91%E5%B0%8FK%E7%9A%84%E5%86%9C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[差分约束系统由$n$个变量$X_1, X_2, X_3 …. X_n$和$m$个未知条件组成的$n$元一次不等式组， 其中，每个条件都形如$X_i \le X_j + W_k$ 我们的问题是：如果有解给出一组满足所有条件的解，否则判断出无解 注意到，$X_i \le X_j + W_k$与单源最短路中的三角不等式很相似。 建立$n$个节点对应$n$个变量。 对于每组条件，从$X_j$向$X_i$连一条权值为$W_k$单向边。同时虚构节点并向每一个节点连一条边，如果存在负环则无解。否则有解。 虚构节点到每个点的距离就是这个点的解 注意事项 需要注意要将题目里面的不等式形式转化为$X_i \le X_j + W_k$ 在判断是否存在解的问题中，使用DFS-SPFA速度较快，在寻找解的过程中BFS-SPFA 不管使用哪种SPFA三角形不等式时，等于时，不更新答案。即，第一个是对的，第二个是错的。 $dist[now] + edge[i].w &lt; dist[exNode]$ $dist[now] + edge[i].w \le dist[exNode]$ Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/*! * FileName: luogu-1993.cpp * This Problem is on luogu. The ID of the problem is 1993. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-05 11:02:51 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 135000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_];struct edges&#123; int node; int w; int nxt;&#125;edge[_];int tot = 0;void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;int n, m;//bool inque[_];//queue&lt;int&gt;Q;//int dist[_];//int inQueTime[_];//bool SPFA(int s)//&#123;// memset(dist, 0x3f, sizeof(dist));// dist[s] = 0;// Q.push(s);// inque[s] = true;// inQueTime[s] ++;// while(!Q.empty())// &#123;// int now = Q.front();// Q.pop();// inque[now] = false;// for(register int i = head[now];i;i = edge[i].nxt)// &#123;// int exNode = edge[i].node;// if(dist[now] + edge[i].w &lt; dist[exNode])// &#123;// dist[exNode] = dist[now] + edge[i].w;// if(!inque[exNode])// &#123;// Q.push(exNode);// inQueTime[exNode] ++;// if(inQueTime[exNode] &gt;= n) return false;// inque[exNode] = true;// &#125;// &#125;// &#125;// &#125;// return true;//&#125;int dist[_];bool InStack[_];bool SPFA(int now)&#123; InStack[now] = true; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dist[now] + edge[i].w &lt; dist[exNode])/////////SPFA 对&lt;=敏感 &#123; dist[exNode] = dist[now] + edge[i].w; if(InStack[exNode]) return false; if(!SPFA(exNode)) return false; &#125; &#125; InStack[now] = false; return true;&#125;int main()&#123; n = read(); m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int opt = read(); int a, b, c; if(opt == 1) &#123; a = read(); b = read(); c = read(); add(a, b, -c); &#125; if(opt == 2) &#123; a = read(); b = read(); c = read(); add(b, a, c); &#125; if(opt == 3) &#123; a = read(); b = read(); add(a, b, 0); add(b, a, 0); &#125; &#125; int root = n + 1; for(register int i = 1;i &lt;= n;i++) add(root, i, 0); n++; memset(InStack, false, sizeof(InStack)); memset(dist, 0x3f, sizeof(dist)); dist[root] = 0; bool ans = SPFA(root); puts(ans ? "Yes" : "No"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1967】【NOIP2013】货车运输]]></title>
    <url>%2F2019%2F08%2F04%2F%E3%80%90luogu-1967%E3%80%91%E3%80%90NOIP2013%E3%80%91%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[首先重新建图，构造出最大生成树，然后在最大生成树上求LCA来回答询问（倍增求树上路径上最小边权）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define inf 0x7fffffffusing namespace std;int n, m;const int _N = 10100;const int _M = 100100;const int _Lg = 20;inline int read()&#123; int x = 0; int sign = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') sign = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3); x += c - '0';c = getchar();&#125; return x * sign;&#125;struct __edges&#123; int u; int v; int w; bool operator &lt; (const __edges A) const &#123; return w &gt; A.w; &#125;&#125;E[_M];int f[_N];void init(int n)&#123; for(register int i = 1;i &lt;= n;i++) f[i] = i; &#125;int find(int x)&#123; return f[x] == x ? x : f[x] = find(f[x]); &#125;void marge(int x, int y)&#123; x = find(x); y = find(y);f[x] = y;&#125;bool ask(int x, int y)&#123; return find(x) == find(y); &#125;int head[_N];struct edges&#123; int node; int w; int nxt;&#125;edge[_M];int tot = 0;void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v; edge[tot].w = w;&#125;void MakeTree()&#123; for(register int i = 1;i &lt;= m;i++) if(!ask(E[i].u, E[i].v)) &#123; add(E[i].u, E[i].v, E[i].w); add(E[i].v, E[i].u, E[i].w); marge(E[i].u, E[i].v); &#125;&#125;int anc[_N][_Lg + 10];int Min[_N][_Lg + 10];int dep[_N];bool vis[_N];void dfs(int now, int fa, int deepth, int wToFa)&#123; if(vis[now]) return; vis[now] = true; dep[now] = deepth; anc[now][0] = fa; Min[now][0] = wToFa; for(register int i = head[now];i;i = edge[i].nxt) dfs(edge[i].node, now, deepth + 1, edge[i].w);&#125;int query(int x, int y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); int ans = inf; int Dis = (dep[x] - dep[y]); for(register int i = 0;Dis != 0;i ++, Dis &gt;&gt;= 1) if(Dis &amp; 1) ans = min(ans, Min[x][i]), x = anc[x][i]; if(x == y) return ans; for(register int i = _Lg;i &gt;= 0;i--) if(anc[x][i] != anc[y][i]) ans = min(ans, min(Min[x][i], Min[y][i])),x = anc[x][i], y = anc[y][i]; ans = min(ans, min(Min[x][0], Min[y][0])); return ans;&#125;int main()&#123; n = read(), m = read(); init(n); for(register int i = 1;i &lt;= m;i++) &#123; E[i].u = read(); E[i].v = read(); E[i].w = read(); &#125; sort(E + 1, E + 1 + m); MakeTree(); memset(vis, false, sizeof(vis)); for(register int i = 1;i &lt;= n;i++) if(!vis[i]) dfs(i, i, 1, 0); for(register int j = 1;j &lt;= _Lg;j++) for(register int i = 1;i &lt;= n;i++) anc[i][j] = anc[anc[i][j - 1]][j - 1]; for(register int j = 1;j &lt;= _Lg;j++) for(register int i = 1;i &lt;= n;i++) Min[i][j] = min(Min[i][j - 1], Min[anc[i][j - 1]][j - 1]); int Q = read(); while(Q--) &#123; int tmpu = read(), tmpv = read(); int ans; if(ask(tmpu, tmpv)) ans = query(tmpu, tmpv); else ans = -1; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3398】仓鼠找sugar]]></title>
    <url>%2F2019%2F08%2F04%2F%E3%80%90luogu-3398%E3%80%91%E4%BB%93%E9%BC%A0%E6%89%BEsugar%2F</url>
    <content type="text"><![CDATA[这道题我服了 题意询问树上$a$到$b$，$c$到$d$的两条路径是否相交。 做法我们容易发现，如果相交，记$x=lca(a,b)$，$y=lca(c,d)$，则必有$x$在$c-d$路径上或$y$在$a-b$路径上。 对于判断在树上的一个点是否在一条路径$(a, b)$上有两种做法: 如果点$k$在路径$(a, b)$上，那么$Deepth_k \ge Deepth_{LCA(a, b)}$ 的情况下$LCA(k, a) = k$ 或者 $LCA(k, b) = k$ 如果点$k$在路径$(a, b)$上，那么$dist(a, b) = dist(a, k) + dist(k, b)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*! * FileName: luogu-3398.cpp * This Problem is on luogu. The ID of the problem is 3398. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-04 21:50:05 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 110000;const int Log = 20;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n;int q;struct edges&#123; int node; int nxt;&#125;edge[_ &lt;&lt; 1];int head[_];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int fa[_][Log + 10];int dep[_];bool vis[_];void dfs(int now, int father)&#123; vis[now] = true; fa[now][0] = father; dep[now] = dep[father] + 1; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(vis[exNode]) continue; dfs(exNode, now); &#125;&#125;void InitFor()&#123; for(register int j = 1;j &lt; Log;j++) for(register int i = 1;i &lt;= n;i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];&#125;int Query(int x, int y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); int len = dep[x] - dep[y]; for(register int step = 0;len != 0;step ++) &#123; if(len &amp; 1) x = fa[x][step]; len &gt;&gt;= 1; &#125; if(x == y) return x; for(register int i = Log;i &gt;= 0;i--) if(fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int main()&#123; n = read();q = read(); int root = 0; for(register int i = 1;i &lt; n;i++) &#123; int tmpx = read(), tmpy = read(); root = tmpx; add(tmpx, tmpy); add(tmpy, tmpx); &#125; dfs(root, 0); InitFor(); for(register int i = 1;i &lt;= q;i++) &#123; int a = read(); int b = read(); int c = read(); int d = read(); int LCA1 = Query(a, b); int LCA2 = Query(c, d); if( (dep[LCA1] &gt;= dep[Query(c, d)] &amp;&amp; (Query(LCA1, c) == LCA1 || Query(LCA1, d) == LCA1)) || (dep[LCA2] &gt;= dep[Query(a, b)] &amp;&amp; (Query(LCA2, a) == LCA2 || Query(LCA2, b) == LCA2)) ) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1352】没有上司的舞会]]></title>
    <url>%2F2019%2F08%2F04%2F%E3%80%90luogu-1352%E3%80%91%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[树形DP 存在负点权，无法使用二分图染色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*! * FileName: luogu-1352.cpp * This Problem is on luogu. The ID of the problem is 1352. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-04 10:35:04 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 6100;//const int _M = inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int node; int nxt;&#125;edge[_];int head[_];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int n;int V[_];bool isNotMaster[_];int dp[_][2];void dfs(int now)&#123;// printf("now at %d\n", now); dp[now][1] = V[now]; dp[now][0] = 0; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; dfs(exNode); dp[now][0] += max(dp[exNode][1], dp[exNode][0]); dp[now][1] += dp[exNode][0]; &#125; return ;&#125; int main()&#123; n = read(); for(register int i = 1;i &lt;= n;i++) V[i] = read(); for(register int i = 1;i &lt; n;i++) &#123; int tmpx = read(), tmpy = read(); add(tmpy, tmpx); isNotMaster[tmpx] = true; &#125; int rot = 0; for(register int i = 1;i &lt;= n;i++) if(!isNotMaster[i]) &#123; rot = i; break; &#125; dfs(rot); printf("%d\n", max(dp[rot][0], dp[rot][1])); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3384】【模板】树链剖分]]></title>
    <url>%2F2019%2F08%2F04%2F%E3%80%90luogu-3384%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define inf 0x7fffffffusing namespace std;const int _N = 2e5 + 100;const int _M = 2e5 + 100;int MOD;inline int read()&#123; int x = 0; int sign = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') sign = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3); x += c - '0';c = getchar();&#125; return x * sign;&#125;int NodeVal[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int head[_N];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v;&#125;int fa[_N];int size[_N];int MaxSon[_N];int depth[_N];int _dfsClock = 0;int top[_N];int dfn[_N];int _rank[_N];void dfsinit(int now, int F)&#123; fa[now] = F; size[now] = 1; MaxSon[now] = 0; int nowMax = -inf; depth[now] = depth[F] + 1; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(exNode == F) continue; dfsinit(exNode, now); size[now] += size[exNode]; if(nowMax &lt; size[exNode]) &#123; nowMax = size[exNode]; MaxSon[now] = exNode; &#125; &#125;&#125;void Dfs_Lct(int now, int Top)&#123; top[now] = Top; dfn[now] = ++_dfsClock; _rank[_dfsClock] = now; if(MaxSon[now] == 0) return; Dfs_Lct(MaxSon[now], Top); for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(exNode != MaxSon[now] &amp;&amp; exNode != fa[now]) Dfs_Lct(exNode, exNode); &#125; &#125;int Vall[_N];struct Node&#123; int sum; int tar; Node *lson, * rson; Node()&#123; sum = tar = 0;lson = rson = NULL; &#125; Node(int v)&#123;sum = v; tar = 0; lson = rson = NULL; &#125; void updata() &#123; sum = (lson -&gt; sum + rson -&gt; sum ) % MOD; &#125;&#125;*null;void build(Node *o, int l, int r)&#123; if(l == r) &#123; o -&gt; sum = NodeVal[_rank[l]] % MOD; o -&gt; lson = null; o -&gt; rson = null; return; &#125; int mid = (l + r) &gt;&gt; 1; o -&gt; lson = new Node(0); o -&gt; rson = new Node(0); build(o -&gt; lson, l, mid); build(o -&gt; rson, mid + 1, r); o -&gt; updata();&#125;void tar(Node *o, int l,int r,int v)&#123; if(o == NULL) return; o -&gt; sum += ((r - l + 1) * 1LL * v) % MOD; o -&gt; sum %= MOD; o -&gt; tar += v; o -&gt; tar %= MOD;&#125;void push(Node *o, int l, int r)&#123; int mid = (l + r) &gt;&gt; 1; if(o -&gt; tar == 0) return; tar(o -&gt; lson, l, mid, o -&gt; tar); tar(o -&gt; rson, mid + 1, r, o -&gt; tar % MOD); o -&gt; tar = 0;&#125;int query(Node *o, int nowl, int nowr, int l, int r)&#123; if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return o -&gt; sum; push(o, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; int ans = 0; if(l &lt;= mid) ans = (ans + query(o -&gt; lson, nowl, mid, l, r)) % MOD; if(r &gt; mid) ans = (ans + query(o -&gt; rson, mid + 1, nowr, l, r)) % MOD; return ans;&#125;void change(Node *o, int nowl, int nowr, int l, int r, int v)&#123; if(l &lt;= nowl &amp;&amp; nowr &lt;= r) &#123; tar(o, nowl, nowr, v); return ; &#125; push(o, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(o -&gt; lson, nowl, mid, l, r, v); if(r &gt; mid) change(o -&gt; rson, mid + 1, nowr, l, r, v); o -&gt; updata();&#125;void AddOnPath(Node *root, int L, int A, int B, int Val)&#123; while(top[A] != top[B]) &#123; if(depth[top[A]] &gt; depth[top[B]]) swap(A, B); change(root, 1, L, dfn[top[B]], dfn[B], Val); B = fa[top[B]]; &#125; change(root, 1, L, min(dfn[A], dfn[B]), max(dfn[A], dfn[B]), Val);&#125;int GetOnPath(Node *root, int L, int A, int B)&#123; int ans = 0; while(top[A] != top[B]) &#123; if(depth[top[A]] &gt; depth[top[B]]) swap(A, B); ans += query(root, 1, L, dfn[top[B]], dfn[B]); ans %= MOD; B = fa[top[B]]; &#125; ans += query(root, 1, L, min(dfn[A], dfn[B]), max(dfn[A], dfn[B])); ans %= MOD; return ans;&#125;inline void AddOnSub(Node * root, int L, int now, int V)&#123; change(root, 1, L, dfn[now], dfn[now] + size[now] - 1, V);&#125;inline int GetOnSub(Node *root, int L, int now)&#123; return query(root, 1, L, dfn[now], dfn[now] + size[now] - 1);&#125;int main()&#123; int n = read(); int m = read(), r = read(), p = read();MOD = p; for(register int i = 1;i &lt;= n;i ++) NodeVal[i] = read(); for(register int i = 1;i &lt; n;i++) &#123; int tmpx = read(), tmpy = read(); add(tmpx, tmpy); add(tmpy, tmpx); &#125; dfsinit(r, r); Dfs_Lct(r, r); Node *root = new Node(0); null = new Node(0); build(root, 1, n); for(register int i = 1;i &lt;= m;i++) &#123; int opt = read(); int A, B, Val, R; switch(opt) &#123; case 1 : A = read(), B = read(), Val = read()%MOD; AddOnPath(root, n, A, B, Val); break; case 2 : A = read(), B = read(); printf("%d\n", GetOnPath(root, n, A, B) % MOD); break; case 3 : R = read(), Val = read() % MOD; AddOnSub(root, n, R, Val); break; case 4 : R = read(); printf("%d\n", GetOnSub(root, n, R) % MOD); break; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-P3037】【USACO11DEC】简化的农场Simplifying the Farm]]></title>
    <url>%2F2019%2F08%2F04%2F%E3%80%90luogu-P3037%E3%80%91%E3%80%90USACO11DEC%E3%80%91%E7%AE%80%E5%8C%96%E7%9A%84%E5%86%9C%E5%9C%BASimplifying-the-Farm%2F</url>
    <content type="text"><![CDATA[思路如果没有边权相同的边，那么其实时不存在多种最小生成树的方案的。 题目中同一边权的个数不超过三个 按照Kruskal的建树流程进行模拟。 边权排完序后，边权相同的会聚到一起，然后在从小到大枚举的时候分类讨论即可。 流程首先找到边权相同到的几条边。 这是我们需要在这些边中选出有用边。 所谓有用边就是加入其中一条边，不会产生环。因为之前已经加入的边是不能再反悔的，所以如果当前等待加入的边与之前的边存在矛盾的话，当前边一定是无用的。如下图，下图的橙色边就是无用边： 然后我们考虑哪些情况会使最小生成树方案增加： 如过当前权值有两条边相同：就有这两种情况： 对于第一种情况，这两条边只能同时加入其中任意一条，这样就有两种建树方案。对于第二种情况，这两条边没有选择余地，必须都加入。 如过当前权值有三条边相同：以下三种情况能产生多种建树方案： 这三种情况分别产生$3$（选其中一条不加入），$2$（选重复的两条中的一条），$3$（选三条中的任意一条）种生成树方案。 代码使用set帮助区分三条边权相同时，第一种情况和第二种情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/*! * FileName: luogu-3037.cpp * This Problem is on luogu. The ID of the problem is 3037. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-03 22:47:58 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _M = 1e5 + 100;const int _N = 4e4 + 100;const int MOD = 1000000007;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int u; int v; int w; bool operator &lt; (const edges &amp; A) const &#123; return w &lt; A.w; &#125;&#125;E[_M];int n, m;//Kruskal 所用的并查集 Startint f[_N];int find(int x)&#123; return f[x] == x ? x : f[x] = find(f[x]); &#125;void initForSet()&#123; for(register int i = 1;i &lt;= n;i++) f[i] = i;&#125;void marge(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; f[x] = y;&#125;bool ask(int x, int y)&#123; return find(x) == find(y);&#125;//Kruskal 所用的并查集 Endint nxtIt(int now)//往下找最后一个边权相同的位置&#123; for(register int i = now;i &lt;= m;i++) if(E[now].w != E[i].w) return i - 1; return m;&#125;set &lt;pair&lt;int , int &gt; &gt; S;//int main()&#123; n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; E[i].u = read(); E[i].v = read(); E[i].w = read(); &#125; initForSet(); sort(E + 1, E + 1 + m); int ans1 = 0; int ans2 = 1; int nxt; for(register int i = 1;i &lt;= m;) &#123; S.clear(); nxt = nxtIt(i); int totEdge = 0; for(register int j = i;j &lt;= nxt;j++) if(!ask(E[j].u, E[j].v)) &#123; totEdge ++; int k1 = min(find(E[j].u), find(E[j].v)); int k2 = max(find(E[j].u), find(E[j].v)); S.insert(make_pair(k1, k2)); &#125; int totAdd = 0; for(register int j = i;j &lt;= nxt;j++) &#123; if(!ask(E[j].u, E[j].v)) &#123; marge(E[j].u, E[j].v); totAdd ++; ans1 = (ans1 + E[j].w) % MOD; &#125; &#125; if(totAdd == 1) ans2 = ans2 * 1LL * totEdge % MOD;//分别是两条边权相同时的第一种情况 和 三条边权相同时的第三种情况。 if(totAdd == 2 &amp;&amp; totEdge == 3) &#123; if(S.size() == 3) ans2 = ans2 * 3LL % MOD;//三条边权相同时的第一种情况 if(S.size() == 2) ans2 = ans2 * 2LL % MOD; //三条边权相同时的第二种情况 &#125; i = nxt + 1; &#125; printf("%d %d\n", ans1 % MOD, ans2 % MOD); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-UVA10366】【uva-10366】龙头滴水 Faucet Flow]]></title>
    <url>%2F2019%2F08%2F03%2F%E3%80%90luogu-UVA10366%E3%80%91%E3%80%90uva-10366%E3%80%91%E9%BE%99%E5%A4%B4%E6%BB%B4%E6%B0%B4-Faucet-Flow%2F</url>
    <content type="text"><![CDATA[最初的想法看到这道题给人的第一感觉是模拟。 我们来模拟一下 然后水往右边流 更快的方法我们来模拟一个更复杂的情况 这里开始加水 我们发现一些柱子完全可以删掉，每次跳到有用的柱子之间后，水量可以直接计算出来。设$H_i$为柱子$i$高度，$L$，$R$代表已经有水的区间。$$Ans = (R - L) * min(H_L, H_R)$$ 好，现在我们的优化算法大体就是这样的流程： 从加水的位置开始，从那边开始溢水（即哪边柱子的高度小），就往后扩展哪边，去找下一个“有用柱子”。 扩展有水的范围后，更新答案。 重复以上两步 看图解：我们用两个变量记录当前水已经覆盖的地方 右边低，水先往右边流 往右边第一个比当前右柱子高的（第一个能挡住水的）柱子就是下一个 继续 右边低，水先往右边流 往右边的下一个柱子比当前右柱子低，这个柱子是无用的，跳过。 这时，有用柱子已经找完了。 我们发现现在中间是一个完整的矩形。 这时水会继续往低的那一端流出去，这时仔细想想，水最后会流成阶梯状。 处理这里比较复杂，我们换张图。 这样的话，仔细观察会发现，其实还是找有用的柱子。但是这次是从最左边开始往右找有用柱子（第一个比它高的柱子）（橙色的）设$i$为第$i$个柱子，$next$为下一个有用柱子 $$Ans += (next - i) * H_i$$ 计算阶梯是从最两端的柱子开始往中间找有用柱子，计算”大矩形的时候”是从开始区间的柱子往外开始找有用柱子。为什么呢？因为，这两种柱子，都能确定一定会限制水面高度。 特殊情况这道题最难处理的就是柱子相等的问题，因为水会同时往两边流。分两种情况： 如果这两个柱子都能继续往各自的方向拓展，同时拓展即可 如果两柱子都无法继续拓展，也就是将在当前大矩形两边形成“阶梯状”。找这两边的阶梯中的小的那个乘$2$加入答案即可（乘$2$是因为如果水往两边同时流，要形成一个阶梯，需要花费两倍的时间），因为越小，代表越早流出边界。 如果两柱子中只有一边无法继续拓展，注意这里不能直接乘$2$计入答案。 以左边无法拓展，开始形成阶梯为例：（底下的数字为柱子高度） 这时开始同时往两边溢水 这样其实就已经不再往右边溢水，继续全部往左边溢水了。这样的话，对答案的贡献就是 Ans += min(向左边形成阶梯的花费 * 2, 向左边形成阶梯的花费 + 往右边溢出的水) 这样统计答案即可。 代码题目给出的位置不好处理，我把各各柱子都编号成$1 - n$然后再换算一下起始区间。 一些变量 nowl和nowr表示当前被水覆盖的区间是[nowl, nowr] n表示柱子个数，高度分别存在H[1] ~ H[n] ans为答案，因为每个柱子之间间隔是$2$，所以最后答案需要乘$2$ 一些函数 QueryToR和QueryToL分别是往右、左形成阶梯状的时间 GetNxt_R和GetNxt_L这里是往右、左找有用柱子，第二个bool变量是为了告诉函数，等于的情况算不算。在不同情况下是不一样的，请自己想一想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*! * FileName: uva-10366.cpp * This Problem is on uva. The ID of the problem is 10366. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-01 20:57:59 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1e4 + 100;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int tmpL, tmpR;int n;int H[_];inline int GetNxt_L(int now, bool isSame)&#123; for(register int i = now - 1;i &gt;= 0;i--) if(H[i] &gt; H[now] || (H[i] == H[now] &amp;&amp; isSame)) return i; return 0;&#125;inline int GetNxt_R(int now, bool isSame)&#123; for(register int i = now + 1;i &lt;= n + 1;i++) if(H[i] &gt; H[now] || (H[i] == H[now] &amp;&amp; isSame)) return i; return n + 1;&#125;inline int QueryToL(int L, int R)&#123; int ans = 0; for(register int i = L;i &lt;= R;i = GetNxt_R(i, true)) ans += H[i] * (GetNxt_R(i, true) - i); return ans; &#125;inline int QueryToR(int L, int R)&#123; int ans = 0; for(register int i = R;i &gt;= L;i = GetNxt_L(i, true)) ans += H[i] * (i - GetNxt_L(i, true)); return ans;&#125;void doit()&#123; n = ((abs(tmpL) + abs(tmpR)) &gt;&gt; 1) + 1; for(register int i = 1;i &lt;= n;i++) H[i] = read(); H[0] = H[n + 1] = inf; int nowl = ((abs(tmpL) + 1) &gt;&gt; 1); int nowr = nowl + 1; int ans = min(H[nowl], H[nowr]); while(true) &#123; int nxtL = GetNxt_L(nowl, false); int nxtR = GetNxt_R(nowr, false); if(nxtL == 0 || nxtR == n + 1)//NxtL == 0就代表往左已经找不到有用柱子了。NxtR == n + 1就代表往右已经找不到有用柱子了 &#123; bool flag = false;//是否更新成功标记。 if(nxtL == 0 &amp;&amp; nxtR == n + 1) flag = true, ans += (H[nowl] == H[nowr] ? min(QueryToL(1, nowl - 1) &lt;&lt; 1 , QueryToR(nowr + 1, n) &lt;&lt; 1) : (H[nowl] &lt; H[nowr] ? QueryToL(1, nowl - 1) : QueryToR(nowr + 1, n)));//请仔细查看这里，这里是处理柱子相同和不相同的情况。（第一个特殊情况） if(nxtL == 0 &amp;&amp; nxtR != n + 1 &amp;&amp; H[nowl] &lt;= H[nowr])//如果左边找不到有用柱子，且水的确要往左边流 flag = true, ans += QueryToL(1, nowl - 1) + (H[nowl] == H[nowr] ? min(QueryToL(1, nowl - 1), (nxtR - nowr) * H[nowr]) : 0);//这里是处理第二个特殊情况 if(nxtL != 0 &amp;&amp; nxtR == n + 1 &amp;&amp; H[nowl] &gt;= H[nowr])//如果右边找不到有用柱子，且水的确要往右边流 flag = true, ans += QueryToR(nowr + 1, n) + (H[nowl] == H[nowr] ? min(QueryToR(nowr + 1, n), (nowl - nxtL) * H[nowl]) : 0);//这里是处理第三个特殊情况 if(flag) break; &#125; int ToVal_L = (H[nowl] &lt;= H[nowr] ? nxtL : nowl); int ToVal_R = (H[nowl] &gt;= H[nowr] ? nxtR : nowr); //这种写法，区间两边高度相等的情况时，两边都能完成拓展。 nowl = ToVal_L; nowr = ToVal_R; ans = (nowr - nowl) * min(H[nowl], H[nowr]); &#125; printf("%d\n", ans &lt;&lt; 1); return ;&#125;int main()&#123; while(scanf("%d%d", &amp;tmpL, &amp;tmpR) == 2 &amp;&amp; tmpL != 0 &amp;&amp; tmpR != 0) doit(); return 0;&#125; 唔~ 写了好长。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【poj-2777】Count Color]]></title>
    <url>%2F2019%2F07%2F17%2F%E3%80%90poj-2777%E3%80%91Count-Color%2F</url>
    <content type="text"><![CDATA[【poj-2777】Count Color原题题目描述选择问题解决和程序设计作为选修课程，您需要解决各种问题。 在这里，我们遇到了一个新问题。 有一个很长的板长$L$厘米,$L$是一个正整数，所以我们可以将板均分为$L$段，从左到右标记为$1,2，…… L$，每个为$1$厘米 长。 现在我们必须给电路板上色 - 只有一种颜色的一个部分。 我们可以在董事会上进行以下两项操作： “C A B C”使用颜色$C$将电路板从$A$段到$B$段着色。 “P A B”输出段$A$和段$B$（包括）之间绘制的不同颜色的数量。 在我们的日常生活中，我们用很少的词来描述颜色（红色，绿色，蓝色，黄色……），因此您可以假设不同颜色T的总数非常小。 为了简单起见，我们将颜色的名称表示为颜色$1$，颜色$2$，…颜色$T$.开始时，板上涂有颜色$1$.现在剩下的问题留给你了。 输入描述第一行输入包含$L（1 &lt;= L &lt;= 100000）$，$T（1 &lt;= T &lt;= 30）$和$O（1 &lt;= O &lt;= 100000）$。 这里$O$表示操作次数。 在$O$行之后，每个包含“C A B C”或“P A B”（这里$A，B，C$是整数，$A$可以大于$B$）作为先前定义的操作。 输出描述输出操作的输出结果按顺序，每行包含一个数字。 做法显然是使用线段树，但是对于求区间互异元素个数来说，有一定难度。 $T$很小，只有$30$，并且只有两种状态 考虑使用二进制 一个$int$有$32$位，能存下所有信息， 合并节点信息的时候只需要将两节点存储的颜色信息按位或即可。 真·好强啊~ Codes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int x = 0; int sign = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') sign = -1;c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0')&#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3);x += c - '0' ;c = getchar();&#125; return x * sign;&#125;void printBin(int v)&#123; printf("%d: ", v); bool S[40];int tot = 0; while(v != 0) &#123; S[++tot] = (v &amp; 1); v &gt;&gt;= 1; &#125; for(register int i = tot;i &gt;= 1;i --) printf("%d%c", S[i], ' '); putchar('\n');&#125;inline int GetNum(int v)&#123; int ans = 0; while(v != 0) &#123; ans += (v &amp; 1); v &gt;&gt;= 1; &#125; return ans;&#125;inline int GetColor(int v) &#123; return (1 &lt;&lt; (v - 1)); &#125;inline char readOpt()&#123; char c = getchar(); while(c != 'C' &amp;&amp; c != 'P') c = getchar(); return c;&#125;int L, T, O;struct Node&#123; int color; Node *lson, *rson; int tar; inline void maintain() &#123; color = lson -&gt; color | rson -&gt; color;&#125; Node()&#123;color = 1;lson = rson = NULL; tar = 0;&#125;&#125;*null;void build(Node *o, int l, int r)&#123; if(l == r) &#123; o -&gt; lson = o -&gt; rson = null; return ; &#125; int mid = (l + r) &gt;&gt; 1; o -&gt; lson = new Node(); o -&gt; rson = new Node(); build(o -&gt; lson, l, mid); build(o -&gt; rson, mid + 1, r); o -&gt; maintain();&#125;void tar(Node *o, int v)&#123; o -&gt; color = v; o -&gt; tar = v;&#125;void push(Node *o)&#123; if(o -&gt; tar == 0) return; tar(o -&gt; lson, o -&gt; tar); tar(o -&gt; rson, o -&gt; tar); o -&gt; tar = 0;&#125;void change(Node *o, int nowl, int nowr, int l , int r, int v)&#123;// printf("Now at [%d, %d] color: \n", nowl, nowr);// printBin(o -&gt; color); if(l &lt;= nowl &amp;&amp; nowr &lt;= r) &#123; tar(o, v); return; &#125; push(o); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(o -&gt; lson, nowl, mid, l, r, v); if(r &gt; mid) change(o -&gt; rson, mid + 1, nowr, l, r, v); o -&gt; maintain();&#125;int query(Node *o, int nowl, int nowr, int l, int r)&#123; if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return o -&gt; color; int mid = (nowl + nowr) &gt;&gt; 1; push(o); int ans = 0; if(l &lt;= mid) ans |= query(o -&gt; lson, nowl, mid, l, r); if(r &gt; mid) ans |= query(o -&gt; rson, mid + 1, nowr, l, r); return ans;&#125;int main()&#123;// freopen("test.in.txt", "r", stdin); //for(;;)printBin(read()); L = read(), T = read(), O = read(); null = new Node(); Node *root = new Node(); build(root, 1, L); while(O--) &#123; char opt = readOpt(); if(opt == 'C') &#123; int Lq = read(), Rq = read(), Val = read();// puts("change By");// printBin(GetColor(Val)); if(Lq &gt; Rq) swap(Lq, Rq); change(root, 1, L, Lq, Rq, GetColor(Val)); &#125; else &#123; int Lq = read(), Rq = read(); if(Lq &gt; Rq) swap(Lq, Rq); printf("%d\n", GetNum(query(root, 1, L, Lq, Rq))); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3374】【模板】树状数组 1]]></title>
    <url>%2F2019%2F07%2F16%2F%E3%80%90luogu-3374%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-1%2F</url>
    <content type="text"><![CDATA[关于树状数组转载自Small_Orange_five的树状数组彻底入门，算法小白都看得懂的超详细解析 再此对本数据结构的作者和本博文原作者表示由衷的敬意 导入树状数组 重点是在树状的数组 大家都知道二叉树吧 叶子结点代表$A$数组 $[A_1,A_8]$ 现在变形一下 $C_i$代表 子树的叶子结点的权值之和 这里以求和举例 如图可以知道 $C_1=A_1$ $C_2=A_1+A_2;$ $C_3=A_3;$ $C_4=A_1+A_2+A_3+A_4;$ $C_5=A_5;$ $C_6=A_5+A_6;$ $C_7=A_7;$ $C_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8;$ 下面观察如下图 将C[]数组的结点序号转化为二进制 $1=(001)$ $C[1]=A[1];$ $2=(010)$ $C[2]=A[1]+A[2];$ $3=(011)$ $C[3]=A[3];$ $4=(100)$ $C[4]=A[1]+A[2]+A[3]+A[4];$ $5=(101)$ $C[5]=A[5];$ $6=(110)$ $C[6]=A[5]+A[6];$ $7=(111)$ $C[7]=A[7];$$8=(1000)$ $C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];$ 对照式子可以发现 $ C[i]=A[i-2^k+1]+A[i-2^k+2]+……A[i];$ （k为i的二进制中从最低位到高位连续零的长度）例如$i=8$时，$k=3$; 可以自行带入验证; lowbit(x)$lowbit(x)$ 其实就是取出x的最低位$1$ 换言之 $lowbit(x)=2^k$ $k$的含义与上面相同 理解一下 下面说代码 12345678910int lowbit(int t)&#123; return t&amp;(-t);&#125;//-t 代表t的负数 计算机中负数使用对应的正数的补码来表示//例如 :// t=6（0110） 此时 k=1//-t=-6=(1001+1)=(1010)// t&amp;(-t)=(0010)=2=2^1 $C[i]=A[i-2^k+1]+A[i-2^k+2]+……A[i];$ $C[i]=A[i-lowbit(i)+1]+A[i-lowbit(i)+2]+……A[i];$ 区间查询 ok 下面利用$C[i]$数组，求A数组中前i项的和 举个例子 $i=7$;$sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;$ 前i项和 $C[4]=A[1]+A[2]+A[3]+A[4]; C[6]=A[5]+A[6]; C[7]=A[7];$ 可以推出: $sum[7]=C[4]+C[6]+C[7];$ 序号写为二进制: $sum[(111)]=C[(100)]+C[(110)]+C[(111)];$ 再举个例子 $i=5$$sum[5]=A[1]+A[2]+A[3]+A[4]+A[5] ;$ 前i项和 $C[4]=A[1]+A[2]+A[3]+A[4]; C[5]=A[5];$ 可以推出: $sum[5]=C[4]+C[5];$ 序号写为二进制: $sum[(101)]=C[(100)]+C[(101)];$ 细细观察二进制 树状数组追其根本就是二进制的应用 结合代码 1234567int getsum(int x)&#123;int ans=0;for(int i=x;i&gt;0;i-=lowbit(i))ans+=C[i];return ans；&#125; 对于$i=7 $进行演示 $7(111)$ $ans+=C[7]$ $lowbit(7)=001 7-lowbit(7)=6(110) ans+=C[6]$ $lowbit(6)=010 6-lowbit(6)=4(100) ans+=C[4]$ $lowbit(4)=100 4-lowbit(4)=0(000) $ 对于$i=5 $进行演示 $5(101)$ $ans+=C[5]$ $lowbit(5)=001 5-lowbit(5)=4(100) ans+=C[4]$ $lowbit(4)=100 4-lowbit(4)=0(000)$ 单点更新当我们修改$A[]$数组中的某一个值时 应当如何更新$C[]$数组呢？ 回想一下 区间查询的过程，再看一下上文中列出的图 1234567void add(int x,int y)&#123; for(int i=x;i&lt;=n;i+=lowbit(i)) tree[i]+=y;&#125;//可以发现 更新过程是查询过程的逆过程//由叶子结点向上更新C[]数组 当更新$A[1]$时 需要向上更新$C[1] ,C[2],C[4],C[8]$ $C[1], C[2], C[4], C[8]$ 写为二进制 $C[(001)],C[(010)],C[(100)],C[(1000)]$ $1(001) C[1]+=A[1]$ $lowbit(1)=001 1+lowbit(1)=2(010) C[2]+=A[1]$ $lowbit(2)=010 2+lowbit(2)=4(100) C[4]+=A[1]$ $lowbit(4)=100 4+lowbit(4)=8(1000) C[8]+=A[1]$ 相关题目http://poj.org/problem?id=2299 http://codeforces.com/contest/703/problem/D http://acm.zcmu.edu.cn/JudgeOnline/problem.php?cid=1270&amp;pid=3]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3387】【模板】缩点（DP）]]></title>
    <url>%2F2019%2F07%2F14%2F%E3%80%90luogu-3387%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BC%A9%E7%82%B9%EF%BC%88DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【luogu-3387】【模板】缩点（DP）【luogu-3387】【模板】缩点 这是一道模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*! * FileName: luogu-3387.cpp * This Problem is on luogu. The ID of the problem is 3387. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define inf 0x7fffffffusing namespace std;const int _N = 10010;const int _M = 100010;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int W[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int head[_N];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int n, m;int dfn[_N];int low[_N];int sccno[_N];int sccCnt = 0;int dfsCnt = 0;stack&lt;int&gt;S;void tarjan(int now)&#123; dfn[now] = low[now] = ++dfsCnt; S.push(now); for(register int i = head[now];i;i = edge[i].nxt) &#123; int node = edge[i].node; if(dfn[node] == 0) &#123; tarjan(node); low[now] = min(low[now], low[node]); &#125; else if(sccno[node] == 0) &#123; low[now] = min(low[now], dfn[node]); &#125; &#125; if(dfn[now] == low[now]) &#123; sccCnt ++; while(true) &#123; sccno[S.top()] = sccCnt; if(S.top() == now) &#123; S.pop();break; &#125; S.pop(); &#125; &#125;&#125;vector&lt;int&gt;G[_N];int val[_N];int sccNodeVal[_N];void findit(int now)&#123; val[now] = sccNodeVal[now];// printf("%d\n", now); int maxSon = 0; for(register int i = 0;i &lt; G[now].size();i++) &#123; int node = G[now][i]; if(node == now) continue; if(val[node] == 0) findit(node); maxSon = max(maxSon, val[node]); &#125; val[now] += maxSon;&#125;int main()&#123;// freopen("test.in.txt", "r", stdin); n = read(), m = read(); int s; for(register int i = 1;i &lt;= n;i++) W[i] = read(); for(register int i = 1;i &lt;= m;i++) add(s = read(), read()); for(register int i = 1;i &lt;= n;i++) if(dfn[i] == 0) tarjan(i);// for(register int i = 1;i &lt;= n;i++)// printf("Sccno[%d] = %d\n", i, sccno[i]);// puts("Ok"); for(register int i = 1;i &lt;= n;i++) for(int u = head[i];u;u = edge[u].nxt) G[sccno[i]].push_back(sccno[edge[u].node]);// puts("OK"); for(register int i = 1;i &lt;= n;i++) sccNodeVal[sccno[i]] += W[i];// puts("Ok"); for(register int i = 1;i &lt;= n;i++) if(val[sccno[i]] == 0) findit(sccno[i]); int maxAns = -inf; for(register int i = 1;i &lt;= n;i++) maxAns = max(maxAns, val[sccno[i]]); printf("%d", maxAns); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1522】 牛的旅行 Cow Tours]]></title>
    <url>%2F2019%2F07%2F14%2F%E3%80%90luogu-1522%E3%80%91-%E7%89%9B%E7%9A%84%E6%97%85%E8%A1%8C-Cow-Tours%2F</url>
    <content type="text"><![CDATA[【luogu-1522】 牛的旅行 Cow Tours 原题 floyd挺好的。 坑点 保证精度符合题目要求 注意合并两条直径之后，距离不一定增大的问题，还需要使用每一个牧场的直径进行更新答案 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/*! * FileName: luogu-1886.cpp * This Problem is on luogu. The ID of the problem is 1886. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1e6 + 100;int A[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, k;struct AmazingQue&#123; int Que[_]; int head; int tail; AmazingQue()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &gt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q1;struct AmazingQue2&#123; int Que[_]; int head; int tail; AmazingQue2()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &lt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q2;int AnsA[_];int totA = 0;int main()&#123; n = read(), k = read(); for(register int i = 1;i &lt;= n;i++) A[i] = read(); for(register int i = 1;i &lt;= k;i++) Q1.push(A[i]); for(register int i = 1;i &lt;= k;i++) Q2.push(A[i]); for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q1.front()) == A[i - 1]) Q1.pop(); Q1.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); totA = 0; for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q2.front()) == A[i - 1]) Q2.pop(); Q2.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-5098】【USACO2004OPEN】Cave Cows 3 洞穴里的牛之三]]></title>
    <url>%2F2019%2F07%2F14%2F%E3%80%90luogu-5098%E3%80%91%E3%80%90USACO2004OPEN%E3%80%91Cave-Cows-3-%E6%B4%9E%E7%A9%B4%E9%87%8C%E7%9A%84%E7%89%9B%E4%B9%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[【luogu-5098】【USACO2004OPEN】Cave Cows 3 洞穴里的牛之三 原题 关于求曼哈夫距离的最大值，最小值存在一个$O(n)$做法。 见luogu日报 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*! * FileName: luogu-5098.cpp * This Problem is on luogu. The ID of the problem is 5098. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int main()&#123; int n = read(); int A1 = -inf, A2 = -inf, B1 = inf, B2 = inf; for(register int i = 1;i &lt;= n;i++) &#123; int tmpx = read(), tmpy = read(); A1 = max(A1, tmpx + tmpy); A2 = max(A2, tmpx - tmpy); B1 = min(B1, tmpx + tmpy); B2 = min(B2, tmpx - tmpy); &#125; printf("%d\n", max(A1 - B1, A2 - B2)); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1516】青蛙的约会]]></title>
    <url>%2F2019%2F07%2F14%2F%E3%80%90luogu-1516%E3%80%91%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[青蛙的约会原题 原题 今得青蛙两只，其一名为$A$， 另一名为$B$。 青蛙$A$从$x$开始跳，每次跳$m$米， 青蛙$B$从$y$开始跳，每次跳$n$米，两青蛙同时开始往同一方向跳，问跳几次可以跳到同一位置。（地球是圆得，周长是$L$） 如果不能跳到同一位置，就输出Impossible 分析设一起跳$K$次能跳到同一位置。 $$x + mK \equiv y + nK \pmod L$$ 移向得到 $$\left ( x - y \right ) + \left ( m - n \right )K \equiv 0 \pmod L$$ 转换为欧几里得方程得到 $$\left ( x - y\right ) + (m - n)K + K’L = 0$$ 移向得到 $$(m - n)K + K’L = \left ( y - x\right )$$ $(m - n)$、$(y - x)$和$L$已经知道，拓展欧几里得求出一组$K$和$K’$即可 然后将$K$调整到最小正整数解。 关于不定方程从一组解得到其他解得过程： 设 $$d = gcd(a,b)$$ $$ d = ax + by = a(x + \frac{b}{d} \times t) + b(y - \frac{a}{d} \times t) ,t \in \mathbb{Z} $$ 通过确定调整 $t$，即可调整一解到最小正整数解。 源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*! * FileName: luogu-1516.cpp * This Problem is on luogu. The ID of the problem is 1516. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define LL long longusing namespace std;const int _ = 233;inline LL read()&#123; char c = getchar(); LL sign = 1; LL x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;void exgcd(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;g)&#123; if(b == 0) &#123; g = a; x = 1;y = 0; &#125; else &#123;exgcd(b, a%b, x, y, g); int X = x; x = y; y = X - (a / b) * y;&#125;&#125;int main()&#123; LL x = read(), y = read(), m = read(), n = read(), L = read(), d, tx, ty;// exgcd(//, y, tx, ty, d);// cout&lt;&lt;tx&lt;&lt; ' '&lt;&lt; ty&lt;&lt;' '&lt;&lt;d&lt;&lt;endl; if(n &gt; m) swap(x, y), swap(m, n); exgcd(m - n, L, tx, ty, d); int k = (y - x) % d; if(k != 0) puts("Impossible"); else &#123; tx = (y - x) / d * tx;//调整方程`c`至gcd(a, b) printf("%lld", (tx % (L / d) + (L / d)) % (L / d)); &#125; return 0;&#125; tips 拓展欧几里得需要使a和b为正数，若 n &gt; m 时，交换两青蛙的信息。 对于调整到最小正整数解，例如得到一个解$K$，通过乘 $t$ 倍的 $\frac{a}{d}$ 得到最小正整数解。只需要$$K = ((K mod \frac{a}{d} )+ \frac{a}{d})mod\frac{a}{d}$$ 注意 $long long$。]]></content>
  </entry>
  <entry>
    <title><![CDATA[线性代数]]></title>
    <url>%2F2019%2F07%2F08%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假INF - INF 第INF周计划]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%9A%91%E5%81%872019-7-1-2019-7-7%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[第三周计划制定时间： 2019/6/30执行时间： Inf Monday 学习Tarjan 无向图相关 有向图强连通分量 习题 【luogu-3388】【模板】割点（割顶） 【luogu-3387】【模板】缩点 【luogu-2341】【HAOI2006】受欢迎的牛 Tuesday 习题 【luogu-3132】【USACO16JAN】愤怒的奶牛Angry Cows 【luogu-3398】仓鼠找sugar 【luogu-1047】【国家集训队】稳定婚姻 Wednesday 完善前两天题目 完善任务列表内题目 Thursday 习题 【luogu-2668】【NOIP2015】斗地主 树（BZOJ 2466） 基因变异（CODEVS 3194） Friday 习题 同余方程（NOIP2012 提高组）（CODEVS 1200） 麦森数（CODEVS 1087） 统计公共子序列个数（CODEVS 1778） Xn 数列（CODEVS1281） Saturday 洛谷网课进阶数学 洛谷网课进阶数据结构 Sunday 完善周四周五两天题目 完善任务列表内题目]]></content>
  </entry>
  <entry>
    <title><![CDATA[【unknow】木板（单调栈）]]></title>
    <url>%2F2019%2F06%2F28%2F%E3%80%90unknow%E3%80%91%E6%9C%A8%E6%9D%BF%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述地上从左到右竖立着$n$块木板，从 $1~n$依次编号. 如下图所示。我们知道每块木板的高度，在第$n$块木板右侧竖立着一块高度无限大的木板，现对每块木板依次做如下的操作： 对于第$i$块木板，我们从其右侧开始倒水，直到水的高度等于第$i$块木板的高度，倒入的水会淹没$a_i$块木板（如果木板左右两侧水的高度大于等于木板高度即视为木板被淹没）. 求$n$次操作后，所有$a_i$的和是多少。如图上所示，在第$4$块木板右侧倒水，可以淹没第$5$块和第$6$块一共$2$块木板,$a_{4} = 2$。 单调栈单调栈来求解的话，复杂度是$O(n)$ 结合单调栈的性质：使用单调栈可以找到元素向左遍历第一个比他小的元素，也可以找到元素向左遍历第一个比他大的元素。 顾名思义，单调栈就是栈内元素单调递增或者单调递减的栈，这一点和单调队列很相似，但是单调栈只能在栈顶操作。 性质 若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。(数值单调性) 越靠近栈顶的元素越后进栈。（下标单调性） 进栈操作元素进栈过程：对于单调递增栈，若当前进栈元素为e，从栈顶开始遍历元素，把小于e或者等于e的元素弹出栈，直接遇到一个大于e的元素或者栈为空为止，然后再把e压入栈中。对于单调递减栈，则每次弹出的是大于e或者等于e的元素。 数据模拟思路：寻找比栈顶高的木板i，找到就出栈，不是就把木板i入栈，给出循环计数样例 10，5，8，12，6从左往右扫描 栈为空，10入栈 栈：10 此时栈顶是10，也就是说要寻找比10大的木板 5比10小，5入栈 栈：5，10 此时栈顶是5，也就是说要寻找比5大的木板 8比5大，5出栈 栈：10 这个时候，第二个高度为5的木板右边比它高的木板已经找到了，是第三个木板8，所以5出栈，计算a2 = 3-2-1 = 0 8比10小，8入栈 栈：8，10 此时栈顶是8，也就是说要寻找比8大的木板 12比8大，8出栈 栈：10 第三个高度为8的木板右边比它高的木板已经找到了，是第四个木板12，8出栈，计算a3 = 4-3-1 = 0 12比10大，10出栈 栈：空 第一个高度为10的木板右边比它高的木板已经找到了，是第四个木板12，所以10出栈，计算a1 = 4-1-1 = 2 栈为空，12入栈 栈：12 此时栈顶是12，也就是说要寻找比12大的木板 6比12小，6入栈 栈：6，12 此时栈顶是6，也就是说要寻找比6大的木板 扫描完成结束 最后栈的结构是：6，12 栈顶为6 由于最右端竖立着一块高度无限大的木板，即存在第六块木板高度为无穷，所以剩余两块木板的算法如下 a5 = 6-5-1 =0 a4 = 6-4-1 = 1 sum = a1 + a2 +a3 +a4 +a5 = 3 因此本题可以在O(n)的时间内迎刃而解了。 从左往右将木板节点压栈，遇到比栈顶木板高的木板就将当前栈顶木板出栈并计算淹没的木板数，如此循环直到栈顶木板高度比当前木板高或者栈为空， 然后将此木板压栈。木板全都压栈完成后，栈内剩余的木板都是右侧没有比它们更高的木板的，所以一个个出栈并计算$a_i= n+1-temp_id-1$(用最右边无限高的木板减)。 简述思路对于一个栈中元素$k$,在把序列中$k$后面的元素加入栈中时，寻找在加栈过程中将$k$替换的元素，这个把$k$替换掉的元素就是$k$右边第一个比$k$小（大）的值。 code12345678910111213141516171819202122int main() &#123; int n,ans=0; cin&gt;&gt;n; Stack&lt;Node&gt; stack(n); Node temp; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;temp.height; temp.id=i; //遇到了右侧第一个比栈顶元素大的元素,计算并出栈 while(!stack.empty()&amp;&amp;stack.top().height&lt;=temp.height)&#123; ans=ans+i-stack.top().id-1; stack.pop(); &#125; stack.push(temp); &#125; //现在栈中的木板右侧没有比它高的木板,用最右侧无限高的木板减 while(!stack.empty())&#123; ans=ans+n+1-stack.top().id-1; stack.pop(); &#125; cout&lt;&lt;ans&lt;&lt;endl; retur]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1886】【poj-2823】滑动窗口]]></title>
    <url>%2F2019%2F06%2F28%2F%E3%80%90luogu-1886%E3%80%91%E3%80%90poj-2823%E3%80%91%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[【luogu-1886】【poj-2823】滑动窗口单调队列 两种性质 单调队列中数据的顺序于原序列顺序相同 单调队列中数据数值上是单调的 用途 解决类似滑动窗口的问题（即：维护区间最值） 优化DP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*! * FileName: luogu-1886.cpp * This Problem is on luogu. The ID of the problem is 1886. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1e6 + 100;int A[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct AmazingQue&#123; int Que[_]; int head; int tail;// bool *optor(int a, int b); AmazingQue()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &gt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q1;struct AmazingQue2&#123; int Que[_]; int head; int tail; AmazingQue2()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &lt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q2;int AnsA[_];int totA = 0;int main()&#123;// Q1.optor = rule1;// Q2.optor = rule2; int n = read(), k = read(); for(register int i = 1;i &lt;= n;i++) A[i] = read(); for(register int i = 1;i &lt;= k;i++) Q1.push(A[i]); for(register int i = 1;i &lt;= k;i++) Q2.push(A[i]); for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q1.front()) == A[i - 1]) Q1.pop(); Q1.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); totA = 0; for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q2.front()) == A[i - 1]) Q2.pop(); Q2.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[知识树 && 注意事项 && 文章]]></title>
    <url>%2F2019%2F06%2F26%2F%E7%9F%A5%E8%AF%86%E6%A0%91-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[index 算法模拟 【luogu-UVA10366】【uva-10366】龙头滴水 Faucet Flow 图论 Tarjan 无向图割点And桥 【luogu-3469 】【POI2008】BLO-Blockade 无向图双连通分量 有向图强连通分量 【luogu-3387】【模板】缩点 【luogu-2341】【HAOI2006】受欢迎的牛 【luogu-2746】【USACO5.3】Network of Schools 最短路 差分约束 【luogu-1993】小K的农场 Djikstra SPFA Folyd 【luogu-1522】 牛的旅行 Cow Tours 分层图最短路 【luogu-4822】【BJWC2012】冻结（Done） 【luogu-4568】【JLOI2011】飞行路线（Done） 连通块 树相关 最小生（大）成树 Prim Kruskal 【luogu-2573】【SCOI2012】滑雪（Done） 最小生成树（Done） 【luogu-P3037】【USACO11DEC】简化的农场Simplifying the Farm (最小生成树数量) 【luogu-1967】【NOIP2013】货车运输 LCA 【luogu-3398】仓鼠找sugar （判断树上两路径是否相交） 【luogu-1967】【NOIP2013】货车运输 瓶颈树 树的重心 【poj-1655】Balancing Act (树的重心)（Done） 树的直径 【luogu-4408】【NOI2003】逃学的小孩（Done） 【luogu-3304】【SDOI2013】直径（Done） 基环树 表达式树 tire树 topsort 欧拉回路 欧拉路径 【unknow】Ant-trip（Error） 树链剖分 【luogu-3384】【模板】树链剖分 二分图匹配\染色 【luogu-3386】【模板】二分图匹配 网络流 最大流问题 增广路算法 最小割最大流定理 最小费用最大流问题 搜索 DFS BFS 迭代加深 双端搜索 A* IDA* 数论 见到式子，先推导！！ 【luogu-2671】【NOIP2015】求和（Done） 【luogu-2512】【HNOI2008】糖果传递（Done） 欧几里得算法(gcd、exgcd) 【luogu-1516】青蛙的约会（Done） 唯一分解定理(NO) 同余 【luogu-4942】小凯的数字（Done） 筛法 不定方程 杨耀三角 二项式定理 概率 期望 编码解码 莫比乌斯反演 矩阵 字符串 KMP Manacher LCP-最长公共前缀 后缀数组 AC自动机 DP DAG上动态规划 线性DP 区间DP 各种背包 树上DP 【luogu-1352】没有上司的舞会 数位DP 利用单调性 Two-Pointer 【luogu-1638】逛画展（Done） 【USACO16OPEN】钻石收藏家Diamond Collector 二分答案 二分查找 【luogu-1083】【NOIP2012】借教室（Done） 单调队列 【luogu-1886】【poj-2823】滑动窗口（Done） 单调栈 【unknow】木板（单调栈）（Done） 其他 贪心 分治 OI中的距离应用 【luogu-5098】【USACO2004OPEN】Cave Cows 3 洞穴里的牛之三(Done) 递归 数据结构 并查集 朴素并查集 种类并查集 【luogu-2024】食物链（Done） 【luogu-1525】关押罪犯（Done） 链表 队列 栈 平衡树 Treap 平衡树——Treap（Done） FHQ Treap splay 线段树 【luogu-1083】【NOIP2012】借教室（Done） 树状数组 【luogu-3374】【模板】树状数组 1 【poj-2777】Count Color 分块 【luogu-3203】【HNOI2010】弹飞绵羊 莫队 【luogu-1494】【国家集训队】小Z的袜子（Done） 主席树 堆 手写堆 Priority_Queue 可持久化 可持久化并查集 主席树 其他算法 《浅谈用极大化思想解决最大子矩形问题》 注意事项 关于编译 打开编译选项-Wall，能帮助检查语言类错误 容易和库文件重复的函数、变量名 clock init max不要宏定义，递归结构GG min abs自己写 time 语言规范 一切情况下禁止使用gets，gets在Linux编译异常 read读取时，先存下返回值，再传入参数 使用stl时&lt; &lt; &gt; &gt;不要连着 做题需要注意的地方 一定注意题目是否需要开long long、long long、long long！ 无向图，边数开两倍 堆，平衡树相关，空间四倍 见到式子，先推导！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2671】【NOIP2015】求和]]></title>
    <url>%2F2019%2F06%2F25%2F%E3%80%90luogu-2671%E3%80%91%E3%80%90NOIP2015%E3%80%91%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[【luogu-2671】【NOIP2015】求和思路看见这种一堆一堆一堆的式子的题目，赶紧先手推一下。 可以得到$x + y$是偶数 然后先按照颜色分类，再按照编号奇偶分类。 需要算一些东西 不好意思懒得写了 看代码吧…… 注意最近做题老是被long long卡掉…… 以后交题前先检查long long。 要是NOIP被long long弄死 我直接从机房跳下去。 F**K Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*! * FileName: luogu-2671.cpp * This Problem is on luogu. The ID of the problem is 2671. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 100100;const int _M = 100100;int Ai[_M];//oint An[_M];//oint Bi[_M];//jint Bn[_M];//jint tot[_M][2];//tot[a][b] 颜色a， b = 0 : 1 o数 j数 int color[_N];int N[_N];const int MOD = 10007;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;signed main()&#123; int n = read();int m = read(); for(register int i = 1;i &lt;= n;i++) N[i] = read(); for(register int i = 1;i &lt;= n;i++) color[i] = read(); for(register int i = 1;i &lt;= n;i++) &#123; if(i &amp; 1) &#123; Bi[color[i]] += i; Bn[color[i]] += N[i]; tot[color[i]][1] ++; &#125; else &#123; Ai[color[i]] += i; An[color[i]] += N[i]; tot[color[i]][0] ++; &#125; &#125; long long ans = 0; for(register int i = 1;i &lt;= m;i++) &#123; if(tot[i][1] &gt; 1) ans += (Bi[i] * 1LL * Bn[i]) % MOD; if(tot[i][0] &gt; 1) ans += (Ai[i]* 1LL * An[i]) % MOD; ans %= MOD; &#125; for(register int i = 1;i &lt;= n;i++) ans += (max(0, (tot[color[i]][i &amp; 1] - 2)) * i * 1LL * N[i]) % MOD, ans %= MOD; printf("%lld", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【poj-1655】Balancing Act (树的重心)]]></title>
    <url>%2F2019%2F06%2F25%2F%E3%80%90poj-1655%E3%80%91Balancing-Act-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[树的重心概念 树的重心也叫树的质心。 找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。 其实我的理解就是（人话）：找一个点，把这个点删掉后，让得到的一堆小森林中最大的数最小。 性质 删掉这个点后，得到森林，森林中的每一棵树的大小$\max\left { A \right }\leq $$\frac{n}{2}$($A\epsilon$得到的森林 $n$为结点总数)；逆定理存在。 两棵树接起来，形成的树的重心一定在原来两棵数的重心形成的路径上。 一棵树最多有两个重心，且相邻。 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。 求法贼简单到一个节点后，找他的儿子的子树大小，和去掉他本身这棵子树后，剩下的大小。如果这些值中的最大值最小，记录节点更新答案。 Code原题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*! * FileName: poj-1655.cpp * This Problem is on poj. The ID of the problem is 1655. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 201000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int node; int nxt;&#125;edge[_N];int head[_N];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int n;int AnsId;int minSize = inf;int Size[_N];void dfs(int now, int parent)&#123; int res = 0; Size[now] = 1; for(register int i = head[now];i;i = edge[i].nxt) &#123; int sonNode = edge[i].node; if(sonNode == parent) continue; dfs(sonNode, now); Size[now] += Size[sonNode]; res = max(res, Size[sonNode]); &#125; res = max(res, n - Size[now]); if(res == minSize) AnsId = min(AnsId, now); else if(res &lt; minSize) AnsId = now, minSize = res; return;&#125;void doit()&#123; memset(Size, 0, sizeof(Size)); minSize = inf; n = read(); int k; memset(head, 0, sizeof(head)); tot = 0; for(register int i = 1;i &lt;= n - 1;i ++) &#123; int tmpx = read(), tmpy = read(); add(tmpx, tmpy); add(tmpy, tmpx); k = tmpx; &#125; dfs(k, 0); printf("%d %d\n", AnsId, minSize) ;&#125;int main()&#123; int T = read(); while(T--) &#123; doit(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4408】【NOI2003】逃学的小孩]]></title>
    <url>%2F2019%2F06%2F24%2F%E3%80%90luogu-4408%E3%80%91%E3%80%90NOI2003%E3%80%91%E9%80%83%E5%AD%A6%E7%9A%84%E5%B0%8F%E5%AD%A9%2F</url>
    <content type="text"><![CDATA[【luogu-4408】【NOI2003】逃学的小孩思路为了让小孩的妈妈走的最远： 找一个最长的直径，直径两端就是小孩两朋友的家 求出在这条直径上的每一个点到叶节点的最长距离，对应叶节点就是小孩的家 这样的话，小孩的妈妈走的路就是最最最最远的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/*! * FileName: luogu-4408.cpp * This Problem is on luogu. The ID of the problem is 4408. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 200100;const int _M = _N;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; &apos;9&apos; || c &lt; &apos;0&apos;) &#123; if(c==&apos;-&apos;)sign = -1; c = getchar(); &#125; while(c &lt;= &apos;9&apos; &amp;&amp; c &gt;= &apos;0&apos;) &#123; x *= 10; x += c - &apos;0&apos;; c = getchar(); &#125; return x * sign;&#125;void swap(int &amp; x, int &amp; y)&#123; int t = x; x = y; y = t;&#125;int n, m; struct edges&#123; int node; int w; int nxt;&#125;edge[_M &lt;&lt; 1];int tot = 0;int head[_N];void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;bool vis[_N];int dist[_N];void dfs(int nowNode)&#123; vis[nowNode] = true; for(register int i = head[nowNode];i;i = edge[i].nxt) &#123; if(vis[edge[i].node]) continue; dist[edge[i].node] = dist[nowNode] + edge[i].w; dfs(edge[i].node); &#125;&#125;float r;int dist_[_N];int tot_ = 0;int MaxId2, MaxId;int MaxDeep = -inf;bool flag = false;int path[_N];bool inPath[_N];int path_w[_N];void dfsForPath(int k,int deepth, int w)&#123; vis[k] = true; path[deepth] = k; path_w[deepth] = w; if(k == MaxId2) &#123; MaxDeep = deepth;flag = true;return; &#125; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(vis[SonNode]) continue; dfsForPath(SonNode, deepth + 1, edge[i].w); if(flag)return; &#125;&#125;int dfsLast(int k)&#123; int longest = 0; vis[k] = true; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(inPath[SonNode] || vis[SonNode]) continue; longest = max(longest, dfsLast(SonNode) + edge[i].w); &#125; return longest;&#125;signed main()&#123; memset(vis, false, sizeof(vis)); n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(), tmpz = read(); add(tmpx, tmpy, tmpz); add(tmpy, tmpx, tmpz); &#125; int MaxDis = 0; memset(dist, 0, sizeof(dist)); dfs(1); for(register int i = 1;i &lt;= n;i++) &#123; if(dist[i] &gt; MaxDis) &#123; MaxDis = dist[i]; MaxId = i; &#125; &#125; memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); dfs(MaxId); int MaxDis2 = 0; for(register int i = 1;i &lt;= n;i++) &#123; if(dist[i] &gt; MaxDis2) &#123; MaxDis2 = dist[i]; MaxId2 = i; &#125; &#125; memset(vis, false, sizeof(vis)); dfsForPath(MaxId, 1, 0); memset(inPath, false, sizeof(inPath)); for(register int i = 1;i &lt;= MaxDeep;i++) inPath[path[i]] = true;//求出数的最长直径，并标记最长直径上的点。 int ans = -inf; memset(vis, 0, sizeof(vis)); int now = 0; for(register int i = 1;i &lt;= MaxDeep;i++) &#123; now += path_w[i]; int tmp = min(now, MaxDis2 - now); int kk = dfsLast(path[i]);//求最长直径上的点到叶节点的最长距离（不走在最长直径上的点） ans = max(ans, kk + tmp + MaxDis2); &#125; printf(&quot;%lld&quot;, ans); return 0;&#125;/*4 31 2 12 4 12 3 2*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3304】【SDOI2013】直径]]></title>
    <url>%2F2019%2F06%2F24%2F%E3%80%90luogu-3304%E3%80%91%E3%80%90SDOI2013%E3%80%91%E7%9B%B4%E5%BE%84%2F</url>
    <content type="text"><![CDATA[【luogu-3304】【SDOI2013】直径前提我们需要明确以下几个条件： 树的直径会有很多条 一般地，树的这些直径有且只有一段重合。特殊地，这一段可能是一个点。 如图路径$3-1-4$是重合的。 思路求出重合的这一段的长度，就是最终答案。 求法要求这条路径的长度，由于是在树上的，所以只需要求出路径两端的端点即可 这端点是什么呢 就是各直径在这条重合路径同侧的端点的LCA 例子就是上图中，第一条路径是$3-2$,第二条路径是$3 - 6$,重合路径是$3-4$。两条直径的端点$6$和$2$在重合路径$3-4$的同侧。我们只需要求端点$6$和$2$的LCA即点$4$就是重合路径的一个端点。 同理，求出另一个端点即可。 特殊地，对于一个点的LCA就是它本身。 但是多个点的LCA我不会用倍增求……呜呜呜呜呜。 然后用欧拉序求出LCA即可，然后求两个LCA的距离。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/*! * FileName: luogu-3304.cpp * This Problem is on luogu. The ID of the problem is 3304. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 200100;const int _M = _N;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;void swap(int &amp; x, int &amp; y)&#123; int t = x; x = y; y = t;&#125;int n, m; struct edges&#123; int node; int w; int nxt;&#125;edge[_M &lt;&lt; 1];int tot = 0;int head[_N];void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;bool vis[_N];int dist[_N];void dfs(int nowNode)&#123;// if(vis[edge[i].node]) continue; vis[nowNode] = true; for(register int i = head[nowNode];i;i = edge[i].nxt) &#123; if(vis[edge[i].node]) continue; dist[edge[i].node] = dist[nowNode] + edge[i].w; dfs(edge[i].node); &#125;&#125;bool B[_N];int Er[_N &lt;&lt; 1], tot_Er = 0;int first[_N], tot_F = 0;int MinId = inf;int MaxId = -inf;void dfsForLCA(int k)&#123; vis[k] = true; first[k] = ++tot_F; Er[++tot_Er] = k; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(vis[SonNode]) continue; dfsForLCA(SonNode); Er[++tot_Er] = k; &#125;&#125;int To;//, ansB;int ans = 0;int RunningAns = 0;void dfsLast(int k)&#123; if(k == To) &#123; ans = RunningAns; return; &#125; vis[k] = true; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(vis[SonNode]) continue; RunningAns++; dfsLast(SonNode); RunningAns--; &#125;&#125;signed main()&#123; // freopen("test.in.txt", "r", stdin); int k = 1; memset(vis, false, sizeof(vis)); n = read(), m = n - 1; for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(), tmpz = read(); add(tmpx, tmpy, tmpz); add(tmpy, tmpx, tmpz); k = tmpx; &#125; int MaxDis = 0, MaxId; memset(dist, 0, sizeof(dist));// printf("Start at %d\n", k); dfs(k); for(register int i = 1;i &lt;= n;i++) &#123;// printf("%d ", dist[i]); if(dist[i] &gt; MaxDis) &#123; MaxDis = dist[i]; MaxId = i; &#125; &#125;// printf("%d\n", MaxId); memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); dfs(MaxId); int MaxDis_ = 0; int MaxAns = -inf; for(register int i = 1;i &lt;= n;i++) MaxDis_ = max(MaxDis_, dist[i]); MaxAns = MaxDis_; for(register int i = 1;i &lt;= n;i++) B[i] = (dist[i] == MaxDis_); memset(first, -1, sizeof(first)); memset(vis, false, sizeof(vis)); dfsForLCA(MaxId); for(register int i = 1;i &lt;= tot_Er;i++) &#123;// printf("%d ", Er[i]); if(B[Er[i]]) &#123; MinId = min(MinId, i); MaxId = max(MaxId, i); &#125; &#125;//cout&lt;&lt;endl;// for(register int i = 1;i &lt;= tot_Er;i++) // printf("%d ", first[Er[i]]); //printf("\n%d %d\n", MinId, MaxId); int F_Min = inf; int LCA_Id; for(register int i = MinId;i &lt;= MaxId;i ++) &#123; //printf("at %d , Er[%d] = %d, First[%d] = %d\n", i, i, Er[i], Er[i], first[Er[i]]); if(F_Min &gt; first[Er[i]]) &#123; F_Min = first[Er[i]]; LCA_Id = Er[i]; &#125; &#125; //printf("LCA = %d\n", LCA_Id);// printf("MaxDist = %d, node = %d ,%d\n", MaxDis2, MaxId2, MaxId); memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); int S = Er[MinId]; dfs(S);//printf("%d", S); memset(first, -1, sizeof(first)); tot_Er = 0; tot_F = 0; for(register int i = 1;i &lt;= n;i++) B[i] = (dist[i] == MaxDis_); memset(vis, false, sizeof(vis)); dfsForLCA(S); MinId = inf; MaxId = -inf;//cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"&amp;"&lt;&lt;endl; for(register int i = 1;i &lt;= tot_Er;i++) &#123;// printf("%d ", Er[i]); if(B[Er[i]]) &#123; MinId = min(MinId, i); MaxId = max(MaxId, i); &#125; &#125;// printf("MaxId = %d, MinId = %d\n", MaxId, MinId); F_Min = inf; int LCA_Id2; for(register int i = MinId;i &lt;= MaxId;i ++) &#123;// printf("at %d , Er[%d] = %d, First[%d] = %d\n", i, i, Er[i], Er[i], first[Er[i]]); if(F_Min &gt; first[Er[i]]) &#123; F_Min = first[Er[i]]; LCA_Id2 = Er[i]; &#125; &#125;// printf("\n###%d %d\n", LCA_Id2, LCA_Id); To = LCA_Id; memset(vis, false, sizeof(vis)); dfsLast(LCA_Id2); printf("%lld\n%lld", MaxAns, ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2573】【SCOI2012】滑雪]]></title>
    <url>%2F2019%2F06%2F23%2F%E3%80%90luogu-2573%E3%80%91%E3%80%90SCOI2012%E3%80%91%E6%BB%91%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[数据丢失，详见题解 第一次知道有向图也是可以最小生成树的…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/*! * FileName: luogu-2573.cpp * This Problem is on luogu. The ID of the problem is 2573. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 100100;const int _M = 1000100;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int node; int w; int nxt;&#125;edge[_M &lt;&lt; 1];int tot = 0;int head[_N];void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;struct Ew&#123; int u; int v; int w; int h; inline bool operator &lt; (const Ew A) const &#123; if(h == A.h) return w &lt; A.w; else return h &gt; A.h; &#125;&#125;_edge[_M];int totE = 0;int H[_N];bool vis[_N];int sum = 0;void Shu_Yu_Mo_Jia_You(int k)&#123; sum ++; vis[k] = true; for(register int i = head[k];i;i = edge[i].nxt) &#123; int &amp;node = edge[i].node; _edge[++totE].u = k; _edge[totE].v = node; _edge[totE].w = edge[i].w; _edge[totE].h = H[node]; if(!vis[node]) Shu_Yu_Mo_Jia_You(node); &#125;&#125;int F[_N];void init(int n) &#123; for(register int i = 1;i &lt;= n;i++) F[i] = i; &#125;int find(int x) &#123; return F[x] == x ? x : F[x] = find(F[x]); &#125;void marge(int x, int y) &#123; x = find(x);y = find(y);if(x == y) return; F[x] = y; &#125;int ask(int x, int y) &#123; return find(x) == find(y); &#125;signed main()&#123; memset(vis, false, sizeof(vis)); int n = read(), m = read(); for(register int i = 1;i &lt;= n;i++) H[i] = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(), tmpz = read(); if(H[tmpx] &gt;= H[tmpy]) add(tmpx, tmpy, tmpz); if(H[tmpx] &lt;= H[tmpy]) add(tmpy, tmpx, tmpz); &#125; Shu_Yu_Mo_Jia_You(1); sort(_edge + 1, _edge + 1 + totE); init(n); int ans = 0; for(register int i = 1;i &lt;= totE;i++) &#123; Ew &amp; now = _edge[i];// printf("#%d %d %d %d\n", now.u, now.v,now.w,now.h); if(!ask(now.u, now.v)) &#123;// printf("marge %d %d\n", now.u, now.v); marge(now.u, now.v); ans += now.w; &#125; &#125; printf("%lld %lld", sum, ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1638】逛画展]]></title>
    <url>%2F2019%2F06%2F23%2F%E3%80%90luogu-1638%E3%80%91%E9%80%9B%E7%94%BB%E5%B1%95%2F</url>
    <content type="text"><![CDATA[原题 Tow Point算法 利用单调性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*! * FileName: luogu-1638.cpp * This Problem is on luogu. The ID of the problem is 1638. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1000100;const int _M = 2010;int A[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m;int sum = 0;int book[_M];void del(int x)&#123; book[x] --; if(book[x] == 0) sum --;&#125;void add(int x)&#123; book[x] ++; if(book[x] == 1) sum ++;&#125;int main()&#123;// freopen("test.in.txt", "r", stdin); memset(book, 0, sizeof(book)); n = read(); m = read(); for(register int i = 1;i &lt;= n;i++) A[i] = read(); int l = n, r = n; add(A[n]); int ansA; int ansB; int MinC = inf; while(l &lt;= r) &#123;// printf("[%d, %d] , sum = %d\n", l, r, sum); while(sum &lt; m &amp;&amp; l &gt; 1) add(A[--l]); if(r - l &lt;= MinC &amp;&amp; sum == m &amp;&amp; l &gt; 0 &amp;&amp; r &gt; 0) &#123;// printf("updated [%d, %d], sum = %d\n", l, r, sum); MinC = r - l; ansA = l; ansB = r; &#125; if(sum != m) break; del(A[r--]); if(r &lt; 1) break; &#125; printf("%d %d", ansA, ansB); return 0;&#125;]]></content>
      <categories>
        <category>Tow-pointer</category>
      </categories>
      <tags>
        <tag>Tow-pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4942】小凯的数字]]></title>
    <url>%2F2019%2F06%2F22%2F%E3%80%90luogu-4942%E3%80%91%E5%B0%8F%E5%87%AF%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[原题 9是一个神奇的数字 设一个数$x$ $x mod 9 =$把x拆开，每个数位加起来再$mod 9$ 所以就好做了啊$QAQ$ 等差数列求和，计算机中如果直接乘起来再除以$2$，会导致严重的溢出($10^{12} * 10^{12}$) 正解先找其中一个偶数除以$2$，然后分别对$9$去余，相乘即可 反正还是同余啊。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*! * FileName: luogu-4942.cpp * This Problem is on luogu. The ID of the problem is 4942. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int main()&#123; long long a, b; int Q = read(); while(Q--) &#123; scanf("%lld%lld", &amp;a, &amp;b); int ans; if((a + b) % 2 == 0) ans = ((a + b) &gt;&gt; 1) % 9 * ((b - a + 1) % 9), ans %= 9; else ans = (((b - a + 1) &gt;&gt; 1) % 9) * ((a + b) % 9), ans %= 9; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【unknow】Ant-trip]]></title>
    <url>%2F2019%2F06%2F21%2Fant-trip%2F</url>
    <content type="text"><![CDATA[蚂蚁国家包含$N$个村庄，这里有$M$条道路连接这些村庄 蚂蚁$tony$和他的朋友想访问国家的每一个部分。 他们打算访问每一条路，并且每一条道只能访问一次。 然而，可能仅仅一组人没有办法完成这个任务。 所以，他们试图把这些蚂蚁朋友分成好几个组，从不同的地方开始。他想知道至少需要多少组才能完成这个任务。 输入包含多组样例，魅族阳历以好几行空白行隔开。每一组阳历以连个整数 N(1&lt;=N&lt;=100000),M(0&lt;=M&lt;=200000)开始。分别表示N个村庄和M条道路。接下来的M行，每行包含两个整数 a,b,(1&lt;=a,b&lt;=N) 。表示有一条路连接a和b。每条路都是不同的，没有路连接两个相同的村庄。 没有写完QAQ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/*! ** have NOT Finished** ** https://www.luogu.org/blog/TheDawn/qian-xi-lca ** * FileName: luogu-3379.cpp * This Problem is on luogu. The ID of the problem is 3379. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;const int _N = 1e5 + 100;const int _M = 5 * 1e5 + 100; inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m, s;namespace Graph&#123; struct _edges&#123; int node; int w; int nxt; &#125;edge[_M]; int head[_N]; int tot = 0; void add(int u, int v,int w) &#123; // printf("added %d %d\n", u, v); // printf("%d--%d[lable=\"%d\"];\n", u, v, w); edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot; swap(u, v); edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot; &#125; struct edges&#123; int a; int b; int c; &#125;e[_M];&#125;namespace LCA&#123; const int LOG = 23; int anc[_N][LOG]; int MinW[_N][LOG]; int depth[_N]; inline void dfs(int u, int p, int P_Udist, int d) &#123; anc[u][0] = p; depth[u] = d; MinW[u][0] = P_Udist; for(register int i = Graph::head[u];i != 0;i = Graph::edge[i].nxt) &#123; int node = Graph::edge[i].node; if(node == p) continue; dfs(node, u, Graph::edge[i].w, d + 1); &#125; &#125; inline void init() &#123; dfs(root, 0, 0, 1); for(register int j = 1; j &lt; LOG;j++) for(register int i = 1; i &lt;= n;i++) ans[i][j] = anc[ anc[i][j - 1] ][j - 1]; &#125; inline void swim(int &amp;x, int h) &#123; for(register int i = 0;h &gt; 0;i++) &#123; if(h &amp; 1) x = anc[x][i]; h &gt;&gt; 1; &#125; &#125; inline int query(int x, int y) &#123; &#125;&#125;int main()&#123; n = read(), m = read(), s = read(); for(register int i = 1;i &lt;= n - 1;i++)// int tmpx = read(), tmpy = read(); Graph::add(read(), read()); for(register int i = 1;i &lt;= m;i++) return 0;&#125;]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2512】【HNOI2008】糖果传递]]></title>
    <url>%2F2019%2F06%2F21%2Fe3-80-90luogu-2512-e3-80-91-e3-80-90hnoi2008-e3-80-91-e7-b3-96-e6-9e-9c-e4-bc-a0-e9-80-92%2F</url>
    <content type="text"><![CDATA[原题 解 设： $X_{i}$为第$ i $个人给第$i - 1$个人的糖果（$X_i$可以为负数）。 $A_i$为第$i$个人原有的糖果。 可得： 第一个人：$A_1 - X_1 + X_2 = ave$ $X_2 = ave -A_1 + X_1$ 第二个人：$A_2 - X_2 + X_3 = ave$ $X_3 = ave -A_2 + X_2 =&gt; 2 * ave + X_1 - A_1-A_2 $ 第三个人：$A_3 - X_3 + X_4 = ave$ $X_4 = ave -A_3 + X_3 =&gt; 3 * ave + X_1 - A_1-A_2-A_3 $ …… 对于第n个小朋友，An-Xn+X1=ave。 我们希望Xi的绝对值之和尽量小，即|X1| + |X1-C1| + |X1-C2| + ……+ |X1-Cn-1|要尽量小。 注意到|X1-Ci|的几何意义是数轴上的点X1到Ci的距离，所以问题变成了：给定数轴上的n个点，找出一个到他们的距离之和尽量小的点，而这个点就是这些数中的中位数。(蓝书P6) 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longconst int _ = 1e6 + 10;int A[_];int S[_];int C[_];int main()&#123; int n; scanf("%d", &amp;n); LL Ave = 0; for(register int i = 1;i &lt;= n;i++) scanf("%d", A + i), Ave += A[i]; Ave /= n; for(register int i = 1;i &lt;= n;i++) S[i] = S[i - 1] + A[i]; for(register int i = 1;i &lt;= n;i++)// cout&lt;&lt;(C[i] = S[i - 1] - (i - 1) * Ave)&lt;&lt;" "; C[i] = S[i - 1] - (i - 1) * Ave;// printf("Ave = %d \n", Ave); sort(C + 1, C + 1 + n); int mid; mid = C[(n + 1) &gt;&gt; 1]; LL ans = 0; for(int i = 1;i &lt;= n;i++) ans += abs(mid - C[i]); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两段视频]]></title>
    <url>%2F2019%2F06%2F21%2Fe4-b8-a4-e6-ae-b5-e8-a7-86-e9-a2-91%2F</url>
    <content type="text"><![CDATA[注意：两段视频已迁移到BiliBili地址 第一段视频[plyr poster=”http://47.92.113.238/Shu\_Yu\_Mo/wp-content/uploads/2019/06/1.mp4&quot;\]http://47.92.113.238/Shu\_Yu\_Mo/wp-content/uploads/2019/06/1.mp4\[/plyr\] 第二段视频[plyr poster=”http://47.92.113.238/Shu\_Yu\_Mo/wp-content/uploads/2019/06/2.mp4&quot;\]http://47.92.113.238/Shu\_Yu\_Mo/wp-content/uploads/2019/06/2.mp4\[/plyr\]]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡树——Treap]]></title>
    <url>%2F2019%2F06%2F17%2Fe5-b9-b3-e8-a1-a1-e6-a0-91-treap%2F</url>
    <content type="text"><![CDATA[记录几个坑点： 可以修改节点times来插入删除时，记得修改times和子树大小 插入删除函数，指针引用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/*! * This Problem is on Luogu. The ID of the problem is 1000. * Github :https://github.com/oldsuold/ * Gitee :https://gitee.com/Shu_Yu_Mo/ * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;const int inf = 2147483647;using namespace std;//inline int randed()//&#123;// static unsigned int seed = 233;// return (seed *= 48271LL + 1000007) % 100000007; //&#125;inline int max(int x, int y) &#123; return x &lt; y ? y : x; &#125;inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;void print(int x)&#123; if(x &gt; 9) print(x / 10); putchar((x % 10) + '0');&#125;inline void writeln(int x)&#123; if(x &lt; 0) putchar('-'), print(-x); else print(x); putchar('\n');&#125;struct Node&#123; Node *ch[2]; int r; int v; int s; int times; Node(int v):v(v) &#123; ch[0] = ch[1] = NULL; r = rand(); s = times = 1;&#125; bool operator &lt; (const Node &amp; rhs) const &#123; return r &lt; rhs.r; &#125; int cmp(int x) &#123; if(x == v) return -1; return x &lt; v ? 0 : 1; &#125; void maintain() &#123; s = times; s += ch[0] -&gt; s; s += ch[1] -&gt; s; &#125; &#125;;Node *null;void rotate(Node *&amp;o, int d)&#123; Node *k = o -&gt; ch[d ^ 1]; o -&gt; ch[d ^ 1] = k -&gt; ch[d]; k -&gt; ch[d] = o; o -&gt; maintain(); k -&gt; maintain(); o = k;&#125;void insert(Node *&amp;o, int x)&#123; if(o == null) &#123; o = new Node(x); o -&gt; ch[0] = o -&gt; ch[1] = null; &#125; //, printf("create a node val = %d\n", x); else &#123; int d = o -&gt; cmp(x); if(d == -1) o -&gt; times++, o -&gt; s++; else &#123; insert(o -&gt; ch[d], x); if(o -&gt; ch[d] -&gt; r &gt; o -&gt; r) rotate(o, d ^ 1); &#125; &#125; o -&gt; maintain();&#125;void remove(Node *&amp;o,int x)&#123; int d = o -&gt; cmp(x); if(d == -1) &#123; if(o -&gt; times &gt; 1) &#123;o -&gt; times --;o -&gt; s -- ; return;&#125; Node *u = o; if(o -&gt; ch[0] != null &amp;&amp; o -&gt; ch[1] != null) &#123; int d2 = (o -&gt;ch[0]-&gt;r &gt; o-&gt;ch[1]-&gt;r ? 1 : 0); rotate(o, d2); remove(o -&gt; ch[d2], x); &#125; else &#123; if(o -&gt; ch[0] == null) o = o -&gt; ch[1]; else o = o -&gt; ch[0]; delete u; &#125; &#125; else remove(o -&gt; ch[d], x); o -&gt; maintain();&#125;//int rank(Node * o, int x)//&#123;// int ans = 0;// while(o -&gt; v != x)// &#123;// int leftSize = (o -&gt; ch[0] == NULL ? 0 : o -&gt; ch[0] -&gt; s);// if(o -&gt; v &lt; x)// ans += leftSize + o -&gt; times;// o = o -&gt; ch[o -&gt; cmp(x)];// &#125;// return ++ans;//&#125;int rank(Node *o, int x) &#123; if(o == null) return 0; if(o -&gt; v == x)return o -&gt; ch[0] -&gt; s + 1; if(o -&gt; v &lt; x) return o -&gt; ch[0] -&gt; s + o -&gt; times + rank(o -&gt; ch[1], x) ; if(o -&gt; v &gt; x) return rank(o -&gt; ch[0], x) ;&#125;//int find(Node * o, int x)//&#123;// if(o == NULL) return 0;// int leftSize = (o -&gt; ch[0] == NULL ? 0 : o -&gt; ch[0] -&gt; s);// if(leftSize &gt; x)// return find(o -&gt; ch[0], x);// else// if(leftSize + o -&gt; times &lt; x)// return find(o -&gt; ch[1], x - leftSize - (o -&gt; times));// else// return o -&gt; v;//&#125;int kth(Node *o, int x)&#123; Node *now = o; for(int leftSize = now -&gt; ch[0] -&gt; s; (x &lt;= leftSize || x &gt; leftSize + now -&gt; times); leftSize = now -&gt; ch[0] -&gt; s) if(x &gt; leftSize + now -&gt; times) &#123; x -= leftSize + now -&gt; times; now = now -&gt; ch[1]; &#125; else now = now -&gt; ch[0]; return now -&gt; v;&#125;int pre(Node *o, int x)&#123; if(o == null) return -inf; if(x &lt;= o -&gt; v) return pre(o -&gt; ch[0], x); else return max(o -&gt; v, pre(o -&gt; ch[1], x));&#125;int suf(Node *o, int x)&#123; if(o == null) return inf; if(x &gt;= o -&gt; v) return suf(o -&gt; ch[1], x); else return min(o -&gt; v, suf(o -&gt; ch[0], x));&#125;void check(Node *o)&#123; puts("# Node info:"); if(o == null) puts("This Node is NULL"); else &#123; printf(" value = %d\n times = %d\n rand = %d\n size = %d\n", o -&gt; v, o -&gt; times, o -&gt; r, o -&gt; s); printf("Into %d left son:\n", o -&gt; v); check(o -&gt; ch[0]); printf("Into %d right son:\n", o -&gt; v); check(o -&gt; ch[1]); &#125;&#125;int main()&#123;// writeln(233);// writeln(-233);// freopen("test.in.txt", "r", stdin);// freopen("test.out.txt", "w", stdout); null = new Node(0);null -&gt; Node *root = null; int n; n = read(); srand((n &gt;&gt; 1) + 233); for(register int i = 1; i &lt;= n;i++) &#123; int opt ; opt = read(); if(opt == 1) &#123; int val = read(); insert(root, val); &#125; if(opt == 2) &#123; int val = read(); remove(root, val); &#125; if(opt == 3) &#123; int val = read(); writeln(rank(root, val)); &#125; if(opt == 4) &#123; int val = read(); writeln(kth(root, val)); &#125; if(opt == 5) &#123; int val = read(); writeln(pre(root, val)); &#125; if(opt == 6) &#123; int val = read(); writeln(suf(root, val)); &#125; if(opt == 9) &#123; check(root); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>模板</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2F2019%2F06%2F17%2Fe6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91%2F</url>
    <content type="text"><![CDATA[最小生成树模板prim/*! * FileName: luogu-3366.cpp * This Problem is on luogu. The ID of the problem is 3366. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff using namespace std; const int _ = 5100; inline int read() { char c = getchar(); int sign = 1; int x = 0; while(c &gt; &apos;9&apos; || c &lt; &apos;0&apos;) { if(c==&apos;-&apos;)sign = -1; c = getchar(); } while(c &lt;= &apos;9&apos; &amp;&amp; c &gt;= &apos;0&apos;) { x *= 10; x += c - &apos;0&apos;; c = getchar(); } return x * sign; } int n, m; int g[_][_]; int Min[_]; bool vis[_]; int main() { n = read(), m = read(); memset(Min, 0x7f, sizeof(Min)); memset(g, 0x7f, sizeof(g)); memset(vis, false, sizeof(vis)); Min[1] = 0; for(register int i = 1;i &lt;= m;i++) { int tmpx = read(), tmpy = read(),tmpz = read(); g[tmpy][tmpx] = g[tmpx][tmpy] = min(g[tmpx][tmpy], tmpz); } for(register int i = 1;i &lt;= n;i++) { int k = 0; for(register int j = 1;j &lt;= n;j++) { if(!vis[j] &amp;&amp; Min[k] &gt; Min[j]) k = j; } // printf(&quot;find %d\n&quot;, k); vis[k] = true; for(register int j = 1;j &lt;= n;j++) if(!vis[j] &amp;&amp; Min[j] &gt; g[k][j]) Min[j] = g[k][j]; } int total = 0; bool flag = true; // for(register int i = 1;i &lt;= n;i++) // printf(&quot;%d : %d\n&quot;, i, Min[i]); for(register int i = 1;i &lt;= n;i++) { total += Min[i]; if(Min[i] == 0x7f7f7f7f) { flag = false; break; } } if(flag) cout&lt;&lt;total&lt;&lt;endl; else puts(&quot;orz&quot;); return 0; }Kruskal/*! * FileName: luogu-3366.cpp * This Problem is on luogu. The ID of the problem is 3366. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int MAX_M=200100; int n,m; struct www{ int u; int v; int w; // int id; }edge[MAX_M]; int f[MAX_M];//并查集 bool cmp(const www &amp; x,const www &amp; y){return x.w&lt;y.w;} void init() { for(int i=1;i&lt;=n;i++) f[i]=i; } int find(int k){return f[k]==k?k:f[k]=find(f[k]);} int Kruskal() { int ans=0; sort(edge+1,edge+1+m,cmp); for(int i=1;i&lt;=m;i++) { int x=find(edge[i].u); int y=find(edge[i].v); if(x!=y) { ans+=edge[i].w; f[x]=y; } } int caset=find(f[1]); for(int i=1;i&lt;=n;i++) if(caset!=find(f[i])) // printf(&quot;%d &quot;,find(f[i])), ans=-1; return ans; } int main() { int x,y,z; ios::sync_with_stdio(false); // ios::setstate() cin&gt;&gt;n&gt;&gt;m; init(); for(int i=1;i&lt;=m;i++) cin&gt;&gt;edge[i].u&gt;&gt;edge[i].v&gt;&gt;edge[i].w; int ans=Kruskal(); if(ans==-1) printf(&quot;orz\n&quot;); else printf(&quot;%d&quot;,ans); return 0; }]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1494】【国家集训队】小Z的袜子]]></title>
    <url>%2F2019%2F03%2F24%2F192%2F</url>
    <content type="text"><![CDATA[莫对算法对于$L,R$的询问。 其中颜色为$ x,y,z $的袜子的个数为$ a,b,c $… 那么答案即为 $(a_(a-1) / 2+b_(b-1) / 2 + c_(c-1)/2….) / ((R-L+1)(R-L)/2) $ 化简得: $(a^2+b^2+c^2+…x^2-(a+b+c+d+…..)) / ((R-L+1)(R-L)) $ 即： $ (a^2+b^2+c^2+…x^2-(R-L+1)) / ((R-L+1)_(R-L)) $ 我们需要解决的一个问题 求一个区间内每种颜色数目的平方和 Set记录颜色出现个数会TLE40。 开$O_2$才30分。 坑点： 快读 100 -&gt; 40 long long 100 -&gt; 60 多次提交之后心态爆炸。。。。 \MMP__ 啥破题目 原题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define int long long using namespace std;const int _ = 5e4 + 10;int _n;int A[_];struct Query&#123; int le; int ri; int I; inline bool operator &lt; (const Query X ) const &#123; return (le / _n == X.le / _n) ? ri &lt; X.ri : le &lt; X.le; &#125;&#125;Q[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1); x += (c - '0'); c = getchar(); &#125; return x * sign;&#125;struct ANS&#123; int x; int y; int gcd(int a, int b) &#123; return b == 0 ? a : this -&gt; gcd(b, a%b); &#125; inline void init(int _x, int _y) &#123; int g; if(_x != 0 &amp;&amp; _y != 0) g = this -&gt; gcd(_x, _y); else g = 1; if(_x == 0 || _y == 0) &#123; x = 0;y = 1;return; &#125; x = _x / g; y = _y / g; &#125;&#125;Ans[_];int book[_];int NOW = 0;inline void add(int x)&#123;// printf("add : %d NOW = %d\n", A[x], NOW); if(x == 0) return; NOW -= book[A[x]] * book[A[x]]; book[A[x]]++; NOW += book[A[x]] * book[A[x]];&#125;inline void del(int x)&#123;// printf("del : %d NOW = %d\n", A[x], NOW); if(x == 0) return; NOW -= book[A[x]] * book[A[x]]; book[A[x]]--; NOW += book[A[x]] * book[A[x]];&#125; main()&#123;// freopen("test.txt", "r", stdin);freopen("test.out.txt", "w", stdout); memset(book, 0, sizeof(book)); int n, m; n = read(); m = read(); _n = sqrt(n); for(register int i = 1;i &lt;= n;i++) A[i] = read(); for(register int i = 1;i &lt;= m;i++) Q[i].le = read(), Q[i].ri = read(), Q[i].I = i; sort(Q + 1, Q + 1 + m); register int nowl = 0, nowr = 0; for(register int i = 1;i &lt;= m;i++) &#123; register int &amp;Tl = Q[i].le; register int &amp;Tr = Q[i].ri; while(nowl &lt; Tl) del(nowl ++); while(nowl &gt; Tl) add(-- nowl); while(nowr &lt; Tr) add(++ nowr); while(nowr &gt; Tr) del(nowr --); int Y = (nowr - nowl + 1) * (nowr - nowl); int X = NOW - (nowr - nowl + 1); Ans[Q[i].I].init(X, Y); &#125; for(register int i = 1;i &lt;= m;i++) printf("%lld/%lld\n", Ans[i].x, Ans[i].y); return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>国家集训队</category>
        <category>模板</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2024】食物链]]></title>
    <url>%2F2019%2F03%2F10%2Fe3-80-90luogu-2024-e3-80-91-e9-a3-9f-e7-89-a9-e9-93-be%2F</url>
    <content type="text"><![CDATA[种类并查集原题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int _ = 3 * 1e5 + 10;struct Tree&#123; int f[_]; void initTree(int n) &#123; for(register int i = 0;i &lt;= n;i++) f[i] = i; &#125; int find(int x) &#123; return f[x] == x ? x :f[x] = find(f[x]); &#125; inline void marge(int x, int y) &#123; int f1 = find(x); int f2 = find(y); if(f1 == f2) return; f[f1] = f2; &#125; inline bool ask(int x, int y) &#123; return find(x) == find(y); &#125;&#125;S;int main()&#123; int n, k; scanf("%d%d", &amp;n, &amp;k); S.initTree(n * 3 + 5);//zzzzxcccc int tot = 0; for(register int i = 1;i &lt;= k;i++) &#123; int op;int x, y; scanf("%d", &amp;op); scanf("%d%d", &amp;x, &amp;y); if(x &gt; n || y &gt; n) &#123; tot++; continue; &#125; if(op == 1) &#123; int ans = true; if(S.ask(x, y + n) || S.ask(x + n , y)) &#123; tot++; continue; &#125; else &#123; S.marge(x, y); S.marge(x + n, y + n); S.marge(x + n + n, y + n + n); &#125; &#125; else &#123; if(x == y || S.ask(x, y) || S.ask(x + n, y)) &#123; tot++; continue; &#125; S.marge(x, y + n) ; S.marge(x + n, y + n + n); S.marge(x + n + n, y); &#125; &#125; printf("%d", tot); return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1525】关押罪犯]]></title>
    <url>%2F2019%2F03%2F03%2Fe3-80-90luogu-1525-e3-80-91-e5-85-b3-e6-8a-bc-e7-bd-aa-e7-8a-af%2F</url>
    <content type="text"><![CDATA[原题 分类并查集 https://www.luogu.org/blog/812-xiao-wen/solution-p1525 // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; const int _N = 21000; const int _M = 110000; struct Find_Union_Set{ int F[_N &lt;&lt; 1]; Find_Union_Set(){} Find_Union_Set(int n){ for(register int i = 0;i &lt;= n;i++) F[i] = i;} int find(int x) { return F[x] == x ? F[x] : F[x] = find(F[x]); } bool ask(int x, int y) { return this -&gt; find(x) == this -&gt; find(y) ; } void marge(int x, int y) { int f1 = this -&gt; find(x), f2 = this -&gt; find(y); if(f1 == f2) return; F[f1] = f2; } }; Find_Union_Set set; struct Edge{ int a; int b; int w; bool operator &lt; (const Edge &amp; X) const { return w &gt; X.w; } }E[_M]; int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); set = Find_Union_Set((n &lt;&lt; 1) + 10); for(register int i = 1;i &lt;= m;i++) scanf(&quot;%d%d%d&quot;, &amp;E[i].a, &amp;E[i].b, &amp;E[i].w); sort(E + 1, E + 1 + m); int ans = 0; for(register int i = 1;i &lt;= m;i++) { int &amp;A = E[i].a, &amp;B = E[i].b; if(!set.ask(A, B)) { set.marge(A, B + n); set.marge(A + n, B); } else { ans = E[i].w; break; } } printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1083】【NOIP2012】借教室]]></title>
    <url>%2F2019%2F02%2F26%2Fe3-80-90luogu-1083-e3-80-91-e3-80-90noip2012-e3-80-91-e5-80-9f-e6-95-99-e5-ae-a4%2F</url>
    <content type="text"><![CDATA[原题 二分做法$O(mlogn)$的复杂度，常数还挺大的。。一直以为过不了，但是其实跑的挺快的。 你会发现，其实就是在枚举某个订单能否被接受，如果能，那这个点前面的都能；如果不能，那这个点后面的都不能；符合单调性,直接瞎$**$二分。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; const int _ = 1e6 + 100; struct Need{ int d; int s; int t; }ned[_]; int A[_]; int n, m; int C[_]; inline bool check(int k) { memset(C, 0, sizeof(C)); // printf(&quot;Id = %d : &quot;, k); for(register int i = 1;i &lt;= k;i++) { C[ned[i].s] -= ned[i].d; C[ned[i].t + 1] += ned[i].d; } int now = 0; for(register int i = 1;i &lt;= n;i++) { now += C[i]; if(A[i] + now &lt; 0) { // printf(&quot;false\n&quot;); return false; } } // printf(&quot;true\n&quot;); return true; } int work() { int le = 1, ri = n; int ans; while(le &lt;= ri) { int mid = (le + ri) &gt;&gt; 1; if(check(mid)) ans = mid, le = mid + 1; else ri = mid - 1; } return ans + 1; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(register int i = 1;i &lt;= n;i++) scanf(&quot;%d&quot;, A + i); for(register int i = 1;i &lt;= m;i++) scanf(&quot;%d%d%d&quot;, &amp;ned[i].d, &amp;ned[i].s, &amp;ned[i].t); int ans = work(); if(ans &gt; n) puts(&quot;0&quot;); else printf(&quot;-1\n%d&quot;, ans); return 0; } /* 4 3 20 20 20 20 2 1 3 3 2 4 4 2 4 */线段树做法$O(mlogn)$以为数据结构能跑的呲呲的，但是线段树的常数……是一个尴尬的问题。。 $O(mlogn)$的复杂度，过$10^{5}$的数据竟然困难……（吸一口$O_2$才能勉强过） 在使用define定义min()时，（#define min(a, b) (a)&lt;(b)?(a):(b)）一定不要把它使用在递归结构中，他会访问两次以上的参数，对于递归，这是致命的。 结果就是，好好的线段树跑的比暴力慢…… #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff using namespace std; const int _NODE = 3100000; const int _N = 1000000; inline int min(int x, int y) { if(x &lt; y) return x; else return y; } struct Node{ int MIN; int Sum; int tar; Node *lson, *rson; Node() { MIN = 0; tar = 0; } }POOL[_NODE]; int __tot__ = 0; Node * malloc_() { return &amp; POOL[__tot__++]; } Node * null; inline void updata(Node *tree) { tree -&gt; MIN = min(tree -&gt; rson -&gt; MIN, tree -&gt; lson -&gt; MIN); } inline void initNode(Node * tree) { tree -&gt; lson = tree -&gt; rson = null; } inline void build(Node *tree, int l, int r) { if(l == r) { scanf(&quot;%d&quot;, &amp;tree -&gt; MIN); return ; } tree -&gt; lson = malloc_(); initNode(tree -&gt; lson); tree -&gt; rson = malloc_(); initNode(tree -&gt; rson); int mid = (l + r) &gt;&gt; 1; build(tree -&gt; lson, l, mid); build(tree -&gt; rson, mid + 1, r); updata(tree); } inline void tar(Node * tree, int l, int r, int val) { if(tree == null) return; tree -&gt; MIN -= val; tree -&gt; tar += val; } inline void push(Node * tree, int nowl, int nowr) { if(nowl == nowr || tree == null) return; int mid = (nowl + nowr) &gt;&gt; 1; tar(tree -&gt; lson, nowl, mid, tree -&gt; tar); tar(tree -&gt; rson, mid + 1, nowr, tree -&gt; tar); tree -&gt; tar = 0; } inline void change(Node * tree, int l, int r, int val, int nowl,int nowr) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) { tar(tree, nowl, nowr, val); return ; } push(tree, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(tree -&gt; lson, l, r, val, nowl, mid); if(r &gt; mid) change(tree -&gt; rson, l, r, val, mid + 1, nowr); updata(tree); } inline int query(Node * tree, int l, int r, int nowl, int nowr) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return tree -&gt; MIN; int mid = (nowl + nowr) &gt;&gt; 1; push(tree, nowl, nowr); int ans = inf ; if(l &lt;= mid) ans = min(ans, query(tree -&gt; lson, l, r, nowl, mid)) ; if(r &gt; mid) ans = min(ans, query(tree -&gt; rson, l, r, mid + 1, nowr)); return ans; } int main() { // freopen(&quot;1083.in.txt&quot;, &quot;r&quot;, stdin); null = malloc_(); int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); Node * root = malloc_(); build(root, 1, n); // puts(&quot;Build Dnoe&quot;); /// printf(&quot;Memory = %d MiB\n&quot;, (sizeof(POOL)/1024/1024)); for(register int i = 1;i &lt;= m;i++) { int s, t, d; scanf(&quot;%d%d%d&quot;, &amp;d, &amp;s, &amp;t); change(root, s, t, d, 1, n); // puts(&quot;change Dnoe&quot;); int VAL = query(root, s, t, 1, n); // puts(&quot;query Dnoe\n&quot;); // printf(&quot;now ans = %d\n&quot;, VAL); if(VAL &lt; 0) { printf(&quot;-1\n%d&quot;, i); return 0; } // int op; // scanf(&quot;%d&quot;, &amp;op); // if(op == 2) // { // int x, y; // scanf(&quot;%d%d&quot;, &amp;x, &amp;y); // printf(&quot;In [%d, %d] Min Val = %d\n&quot;, x, y, query(root, x, y, 1, n)); // } // else // { // int x, y, val; // scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;val); // change(root, x, y, val, 1, n); // } } puts(&quot;0&quot;); return 0; }另外还有几点注意：]]></content>
      <categories>
        <category>luogu</category>
        <category>NOIP</category>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4822】【BJWC2012】冻结]]></title>
    <url>%2F2019%2F02%2F24%2Fe3-80-90luogu-4822-e3-80-91-e3-80-90bjwc2012-e3-80-91-e5-86-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[分层图最短路问题分层图最短路是指在可以进行分层图的图上解决最短路问题。 一般模型是： 在图上，有$K$次机会可以直接通过一条边，问起点与终点之间的最短路径。 P4822 【BJWC2012】冻结 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff //#include&lt;pair&gt; #include&lt;queue&gt; using namespace std; const int _M = 5100000; const int _N = 1100000; struct edges{ int node; int w; int nxt; edges() {} edges(int _node, int _w, int _nxt) { node = _node; w = _w; nxt = _nxt; } }edge[_M]; int head[_N]; int tot = 0; int N = -inf; inline void add(int u, int v,int w) { N = max(N, max(u, v)); edge[++tot] = edges(v, w, head[u]); head[u] = tot; } int n, m, k; int s, t; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; Q; int dist[_N]; bool vis[_N]; void dijkstra() { memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; Q.push(make_pair(0, s)); while(!Q.empty()) { int now = Q.top().second; Q.pop(); if(!vis[now]) { vis[now] = true; for(register int i = head[now];i;i = edge[i].nxt) { edges exNode = edge[i]; if(dist[exNode.node] &gt; dist[now] + exNode.w) { dist[exNode.node] = dist[now] + exNode.w; Q.push(make_pair(dist[exNode.node], exNode.node)); } } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); // scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s = 1;t = n; for(register int i = 1;i &lt;= m;i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); for(register int j = 1;j &lt;= k;j++) { add(u + j * n, v + j * n, w); add(v + j * n, u + j * n, w); add(u + (j - 1) * n, v + j * n, w &gt;&gt; 1); add(v + (j - 1) * n, u + j * n, w &gt;&gt; 1); } } // for(register int i = 1;i &lt;= k;i++) // add(t + (i - 1) * n, t + i * n, 0); dijkstra(); int ans = inf; for(register int i = 1;i &lt;= k + 1;i++) ans = min(ans, dist[t + (i - 1) * n]); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
        <category>OI</category>
        <category>模板</category>
        <category>省选题目</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4568】【JLOI2011】飞行路线]]></title>
    <url>%2F2019%2F02%2F24%2Fe3-80-90luogu-4568-e3-80-91-e3-80-90jloi2011-e3-80-91-e9-a3-9e-e8-a1-8c-e8-b7-af-e7-ba-bf%2F</url>
    <content type="text"><![CDATA[分层图最短路问题分层图最短路是指在可以进行分层图的图上解决最短路问题。 一般模型是： 在图上，有$K$次机会可以直接通过一条边，问起点与终点之间的最短路径。 P4568 [JLOI2011]飞行路线 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff //#include&lt;pair&gt; #include&lt;queue&gt; using namespace std; const int _M = 5100000; const int _N = 1100000; struct edges{ int node; int w; int nxt; edges() {} edges(int _node, int _w, int _nxt) { node = _node; w = _w; nxt = _nxt; } }edge[_M]; int head[_N]; int tot = 0; int N = -inf; inline void add(int u, int v,int w) { N = max(N, max(u, v)); edge[++tot] = edges(v, w, head[u]); head[u] = tot; } int n, m, k; int s, t; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; Q; int dist[_N]; bool vis[_N]; void dijkstra() { memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; Q.push(make_pair(0, s)); while(!Q.empty()) { int now = Q.top().second; Q.pop(); if(!vis[now]) { vis[now] = true; for(register int i = head[now];i;i = edge[i].nxt) { edges exNode = edge[i]; if(dist[exNode.node] &gt; dist[now] + exNode.w) { dist[exNode.node] = dist[now] + exNode.w; Q.push(make_pair(dist[exNode.node], exNode.node)); } } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); // scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s = 1;t = n; for(register int i = 1;i &lt;= m;i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); for(register int j = 1;j &lt;= k;j++) { add(u + j * n, v + j * n, w); add(v + j * n, u + j * n, w); add(u + (j - 1) * n, v + j * n, w &gt;&gt; 1); add(v + (j - 1) * n, u + j * n, w &gt;&gt; 1); } } // for(register int i = 1;i &lt;= k;i++) // add(t + (i - 1) * n, t + i * n, 0); dijkstra(); int ans = inf; for(register int i = 1;i &lt;= k + 1;i++) ans = min(ans, dist[t + (i - 1) * n]); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
        <category>省选题目</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层最短路]]></title>
    <url>%2F2019%2F02%2F24%2Fe5-88-86-e5-b1-82-e6-9c-80-e7-9f-ad-e8-b7-af%2F</url>
    <content type="text"><![CDATA[分层最短路适用情况分层图最短路是指在可以进行分层图的图上解决最短路问题. 在图上，有$k$次机会可以直接通过一条边或者改变一条边的边权，问起点与终点之间的最短路径。 或者经过某个点需要对答案造成额外的贡献。 实现套路$DP$实现（没写过）建立多层图把原图拆成很多层，这一层的点向下一层的点连单向边。同时改变点的编号。 注意如果不需要$K$次，我们的操作是把在每层的结束点使用边权为$0$的边连起来。 建图类似于这样 for(register int i = 1;i &lt;= m;i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); for(register int j = 1;j &lt;= k;j++) { add(u + j * n, v + j * n, w); add(v + j * n, u + j * n, w); add(u + (j - 1) * n, v + j * n, w &gt;&gt; 1); add(v + (j - 1) * n, u + j * n, w &gt;&gt; 1); } } //add()用来建立单向边例题 【JLOI2011】飞行路线 【BJWC2012】冻结 #### Blog 【JLOI2011】飞行路线 【BJWC2012】冻结]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1341】无序字母对]]></title>
    <url>%2F2019%2F02%2F24%2Fe3-80-90luogu-1341-e3-80-91-e6-97-a0-e5-ba-8f-e5-ad-97-e6-af-8d-e5-af-b9%2F</url>
    <content type="text"><![CDATA[欧拉回环裸题无向图 图联通 有两个或者没有奇点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define max(a, b) (a)&gt;(b)?(a):(b)#define min(a, b) (a)&lt;(b)?(a):(b)#define inf 0x7fffffffusing namespace std;const int _M = 6100;const int _N = 60;vector&lt;int&gt; G[_N];bool vis[_N][_N];int maxNode = -inf;int minNode = inf;//string Ans;std::stack &lt;char&gt; Ans;inline int GetHash(char x)&#123; if('A' &lt;= x &amp;&amp; x &lt;= 'Z') return x - 'A'; else if('a' &lt;= x &amp;&amp; x &lt;= 'z') return x - 'a' + 30;&#125;inline char SrcHash(int x)&#123; if(0 &lt;= x &amp;&amp; x &lt;= 25) return (char)(x + 'A'); else if(30 &lt;= x &amp;&amp; x &lt;= 55) return (char)(x - 30 + 'a');&#125;void dfs(int k)&#123;// printf("%c \n", SrcHash(k)); for(register int i = 0;i &lt; G[k].size();i++) &#123; int exNode = G[k][i]; if(!vis[k][exNode]) &#123; vis[k][exNode] = vis[exNode][k] = true; dfs(exNode); &#125; &#125; Ans.push(SrcHash(k));&#125;int main()&#123; int n; scanf("%d", &amp;n); for(register int i = 1;i &lt;= n;i++) &#123; char a, b; cin &gt;&gt; a &gt;&gt; b; int _a = GetHash(a), _b = GetHash(b); G[_a].push_back(_b); G[_b].push_back(_a); maxNode = max(maxNode, max(_a, _b)); minNode = min(minNode, min(_a, _b)); &#125;//QuMengYan@ for(register int i = 0;i &lt;= maxNode;i++) if(G[i].size() != 0) sort(G[i].begin(), G[i].end());// for(register int i = 0;i &lt;= maxNode;i++)// &#123;// if(G[i].size() == 0) continue;// printf("%c to :", SrcHash(i));// for(register int j = 0;j &lt; G[i].size();j++)// printf("%c ", SrcHash(G[i][j]));// cout&lt;&lt;endl;// &#125; int Sum = 0 ; int id = minNode; for(register int i = 0;i &lt;= maxNode;i++) if(G[i].size() % 2 == 1) &#123; Sum ++; if(Sum == 1) id = i;// printf("d = %d \n", i); &#125; dfs(id); int haveAns = true; if(Sum != 2 &amp;&amp; Sum != 0) haveAns = false; if(Ans.size() != n + 1) haveAns = false; if(haveAns) while(!Ans.empty())putchar(Ans.top()), Ans.pop(); else puts("No Solution"); return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路（路径）]]></title>
    <url>%2F2019%2F02%2F24%2Fe6-ac-a7-e6-8b-89-e5-9b-9e-e8-b7-af-ef-bc-88-e8-b7-af-e5-be-84-ef-bc-89%2F</url>
    <content type="text"><![CDATA[用处简单说就是在一张图上的一笔画问题。 要求对于无向图 底图联通 有两个或者没有奇点 没有奇点就从任意点出发均可。 对于有向图 底图联通（忽略边） 最多只有两个点的入度不等于出度。而且必须是一个点入度比出度大$1$；另一个点的出度比入度大$1$。 void dfs(int k){// printf(“%d\n”, k);不要在这里输出 for(int i = 0;i &lt; G[k].size();i++) { int exNode = G[k][i]; if(vis[k][exNode] &gt; 0) { vis[k][exNode]--; vis[exNode][k]--; dfs(exNode); } } stack.push(k);//先记录入栈} 模板题]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2731】【USACO】骑马修栅栏 Riding the Fences]]></title>
    <url>%2F2019%2F02%2F24%2Fe3-80-90luogu-2731-e3-80-91-e3-80-90usaco-e3-80-91-e9-aa-91-e9-a9-ac-e4-bf-ae-e6-a0-85-e6-a0-8f-riding-the-fences%2F</url>
    <content type="text"><![CDATA[欧拉路径原题 找一个奇点，开始跑。 注意DFS统计答案要在最后面把结点压入栈中。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define max(a, b) (a)&gt;(b)?(a):(b) #define min(a, b) (a)&lt;(b)?(a):(b) #define inf 0x7fffffff using namespace std; const int _ = 521; vector&lt;int&gt; G[_]; int vis[_][_]; stack&lt;int&gt;Ans; void dfs(int k) { // printf(&quot;%d\n&quot;, k); for(int i = 0;i &lt; G[k].size();i++) { int exNode = G[k][i]; if(vis[k][exNode] &gt; 0) { vis[k][exNode]--; vis[exNode][k]--; dfs(exNode); } } Ans.push(k); } int main() { memset(vis, 0, sizeof(vis)); int F, MaxNode = -inf, MinNode = inf; scanf(&quot;%d&quot;, &amp;F); for(register int i = 1;i &lt;= F;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); vis[x][y] ++; vis[y][x] ++; G[x].push_back(y); G[y].push_back(x); MaxNode = max(MaxNode, x); MaxNode = max(MaxNode, y); MinNode = min(MinNode, x); MinNode = min(MinNode, y); } for(register int i = 1;i &lt;= MaxNode;i++) if(G[i].size()) sort(G[i].begin(), G[i].end()); int S = -1;; for(register int i = 1;i &lt;= MaxNode;i++) if(G[i].size() % 2 == 1) { S = i; break; } if(S != -1) dfs(S); else dfs(1); while(!Ans.empty()) { cout&lt;&lt;Ans.top()&lt;&lt;endl; Ans.pop(); } return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1983】【NOIP2012】车站分级]]></title>
    <url>%2F2019%2F02%2F22%2Fe3-80-90luogu-1983-e3-80-91-e3-80-90noip2012-e3-80-91-e8-bd-a6-e7-ab-99-e5-88-86-e7-ba-a7%2F</url>
    <content type="text"><![CDATA[原题 非常恶心的一道题（坑多）调试记录： - RE - 需要手写队列 - 访问下标为负数的内存 - 邻接表开大点…… - MLE - 邻接表开的太大了………… - 稠密图使用邻接矩阵存图 - TLE(Point #7) - 稠密图使用邻接矩阵存图 - 建立图方式尽量优化 - 去除重边 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define LL long long #define max(a, b) (a)&gt;(b)?(a):(b) using namespace std; const int _ = 1000010; //1000343 const int __ = 1100; //struct Node { // int node; // int nxt; //}edge[_]; //int head[__]; //int tot = 0; int ind[__]; //vector&lt;int&gt; G[__]; bool map[__][__]; void add(int u, int v) { if(map[u][v]) return; ind[v] ++; // G[u].push_back(v); map[u][v] = 1; // edge[++tot].nxt = head[u]; // edge[tot].node = v; // head[u] = tot; // printf(&quot;tot = %d \n&quot;, tot); } //queue&lt;int&gt;Q; int n, m; int ans = 0; int Time[__]; struct Queue{ int Q[_]; int head; int tail; Queue(){ head = tail = 0; } inline bool empty() { return head == tail; } inline void push(int x){ Q[tail++] = x; } inline void pop() { head++; } inline int top() { return Q[head]; } }Q; void topsort() { for(int i = 1;i &lt;= n;i++) if(ind[i] == 0) { Q.push(i); Time[i] = 1; } // puts(&quot;Done Init topsort&quot;); while(!Q.empty()) { int nowNode = Q.top();Q.pop(); ans = max(ans, Time[nowNode]); // puts(&quot;After pop --&quot;); for(int i = 1;i &lt;= n;i++) { if(map[nowNode][i]) { int exNode = i; ind[exNode]--; // puts(&quot;After ind --&quot;); // printf(&quot;i == %d&quot;, i); if(ind[exNode] == 0) { Q.push(exNode); Time[exNode] = Time[nowNode] + 1; } } // puts(&quot;After push --&quot;); // printf(&quot;Queue size = %d \n&quot;, Q.size()); // printf(&quot;Node = %d\n&quot;, edge[i].node); } } } int S[__]; int tot_S = 0; int uS[__]; int tot_uS = 0; int main() { // freopen(&quot;1983.in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;1983.out.txt&quot;, &quot;w&quot;, stdout); memset(ind, 0, sizeof(ind)); memset(map, 0, sizeof(map)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m) ; // puts(&quot;Running Begin&quot;); // cout&lt;&lt;n&lt;&lt;m&lt;&lt;endl; for(int i = 1;i &lt;= m;i++) { tot_S = tot_uS = 0; int s; scanf(&quot;%d&quot;, &amp;s); int a, b; scanf(&quot;%d&quot;, &amp;a); S[++tot_S] = a; for(register int j = 2;j &lt;= s;j++) { scanf(&quot;%d&quot;, &amp;b); S[++tot_S] = b; for(register int k = a + 1;k &lt; b;k++) uS[++tot_uS] = k; a = b; } for(register int j = 1;j &lt;= tot_S;j++) for(register int k = 1;k &lt;= tot_uS;k++) add(S[j], uS[k]); } // printf(&quot;Build Done\n&quot;); topsort(); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>NOIP</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1396】营救]]></title>
    <url>%2F2019%2F02%2F22%2Fe3-80-90luogu-1396-e3-80-91-e8-90-a5-e6-95-91%2F</url>
    <content type="text"><![CDATA[原题 第一道二分答案。 要求最大值最小。 注意DFS在无向图上跑的时候需要vis判断重复#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #define max(a, b) (a)&gt;(b)?(a):(b) #define min(a, b) (a)&lt;(b)?(a):(b) #define inf 0x7fffffff using namespace std; const int _M = 40100; const int _N = 10100; int s, t; struct edges{ int node; int w; int nxt; }edge[_M]; int head[_N]; int tot = 0; void add(int u, int v,int w) { edge[++tot].node = v; edge[tot].w = w; edge[tot].nxt = head[u]; head[u] = tot; edge[++tot].node = u; edge[tot].w = w; edge[tot].nxt = head[v]; head[v] = tot; } bool HaveAns; bool vis[_N]; void dfs(int nowNode, int val) { if(nowNode == t) { HaveAns = true; return ; } if(vis[nowNode]) return; vis[nowNode] = true; for(int i = head[nowNode];i;i = edge[i].nxt) { if(edge[i].w &gt; val) continue; dfs(edge[i].node, val); if(HaveAns) return; } } inline bool check(int val) { memset(vis, false, sizeof(vis)); HaveAns = false; dfs(s, val); return HaveAns; } int MaxW = 0; int MinW = inf; int work() { int le = MinW, ri = MaxW; int ans = 0; while(le &lt;= ri) { int mid = (le + ri) &gt;&gt; 1; if(check(mid)) ans = mid, ri = mid - 1; else le = mid + 1; } return ans; } int main() { int n, m; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(register int i = 1;i &lt;= m;i++) { int tmpx, tmpy, tmpw; scanf(&quot;%d%d%d&quot;, &amp;tmpx, &amp;tmpy, &amp;tmpw); add(tmpx, tmpy, tmpw); MaxW = max(MaxW, tmpw); MinW = min(MinW, tmpw); } int ans = work(); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3143】【USACO16OPEN】钻石收藏家Diamond Collector]]></title>
    <url>%2F2019%2F02%2F22%2Fe3-80-90luogu-e3-80-91-e3-80-90usaco16open-e3-80-91-e9-92-bb-e7-9f-b3-e6-94-b6-e8-97-8f-e5-ae-b6diamond-collector%2F</url>
    <content type="text"><![CDATA[two-pointer问题， \\ 类似于二分的思想， 利用数组的单调性。 简单的题意就是，需要解决在一个有序序列上面找一个最长的子序列，使子序列两极值相差小于K。 Luogu钻石收藏家 因为是要寻找两个子序列，我们使用两个数组维护答案： per[i]表示区间全部在i前面的最大区间。 suf[i] 表示区间全部在i后面的最大区间。 调试记录 两个区间端点不能重合 注意维护suf数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define max(a, b) (a)&gt;(b)?(a):(b) using namespace std; const int _ = 50100; int A[_]; int per[_]; int suf[_]; int main() { int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(register int i = 1;i &lt;= n;i++) scanf(&quot;%d&quot;, A + i); sort(A + 1, A + 1 + n); int l = 1; for(register int r = 2;r &lt;= n;r++) { int backL = l; while(l &lt;= r &amp;&amp; A[r] - A[l] &gt; k) l ++; suf[l] = r - l + 1; for(register int i = backL;i &lt;= l;i++) suf[i] = max(suf[i], suf[l]) ; per[r] = max(per[r - 1], (r - l + 1)); } int ans = 0; for(register int i = 1;i &lt;= n;i++) ans = max(ans, per[i] + suf[i + 1]); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【nowcoder 18985】数字权重]]></title>
    <url>%2F2019%2F02%2F22%2Fe3-80-90nowcoder-18985-e3-80-91-e6-95-b0-e5-ad-97-e6-9d-83-e9-87-8d%2F</url>
    <content type="text"><![CDATA[题目描述小$A$有一个$n$位的数字，但是它忘了各个位上的数是什么，现在请你来确定各个位上的数字，满足以下条件： - $\left ( \sum_{i=2}^{n} \left ( a_{i}-a_{i-1} \right )\right )=K$ - 不含前导$0$ 设第$i$位的数为$a_{i}$，其中$a1. {1}$为最高位，$a{n}$为最低位，$K$为给定的数字。 输入描述:两个整数$n$, $K$ 若存在无解的情况，请输出$0$ 输出描述:一个整数表示答案，对$10^{9} + 7$取模 输入输出样例 输入：2 3 输出：6 输入：2 -3输出：7 输入：4 3 输出：600 输入：4 -3输出：700 数据范围 对于30%的数据 $n, |k| = 5$ 对于60%的数据 $n, |k| \leq 10^{13}$ 对于1000%的数据 $n, |k| \leq 10^{13} , n &gt; 0$ 题解$\left ( \sum_{i=2}^{n} \left ( a_{i}-a_{i-1} \right )=K \right) \Rightarrow \left( \left( a_{2}-a_{1} \right)+\left( a_{3}-a_{2} \right)+\left( a_{4}-a_{3} \right)+\cdots +\left( a_{n}-a_{n-1} \right)\right) \Rightarrow \left( a_{2}-a_{1} + a_{3}-a_{2} + a_{4}-a_{3} +\cdots + a_{n}-a_{n-1} \right)\Rightarrow \left( a_{n} - a_{1} \right)$ 保证第一个数和最后一个数的差是$K$即可。 然后中间的差值有$10$种，一共有$10^{n-2}$种，快速幂求值即可。 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int P = 1000000007; long long Pow(long long a,long long b) { long long ans=1; while(b) { if(b&amp;1) ans=(ans*a)%P; a=(a*a)%P; b&gt;&gt;=1; } return ans; } int main() { long long n, k; cin &gt;&gt; n &gt;&gt; k; int p; if (k&gt;0)p = 9 - k; if (k&lt;0)p = 10 + k; if (k == 0)p = 9; long long sum = Pow(10, n - 2) % P; long long out = 0; for (int i = 0; i &lt; p; i++) out = (out + sum) % P; cout &lt;&lt; out &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>NewCoder</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1080】【NOIP-2012】国王游戏]]></title>
    <url>%2F2019%2F02%2F22%2Fe3-80-90luogu-1080-e3-80-91-e3-80-90noip-2012-e3-80-91-e5-9b-bd-e7-8e-8b-e6-b8-b8-e6-88-8f%2F</url>
    <content type="text"><![CDATA[原题 一道比较顺畅的贪心 当然要给大臣排序。 考虑一个排序规则，现在有两个大臣。X 和Y； $X_{a}, X_{b}$分别代表其左手和右手数字的值； 如果X在Y前面，那么X会对Y做出贡献。 如果Y在X前面，那么Y会对X做出贡献。 哪个更好？ 根据$X_{a}/Y_{b}$和$Y_{a}/X_{b}$的大小即可判断哪个在前面。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define LL long long #define max(a, b) (a)&gt;(b)?(a):(b) using namespace std; const int _ = 10100; struct person{ int a; int b; bool operator &lt; (const person &amp; x) const { return a / x.b &lt; x.a /b; } }P[_]; LL S = 1; int main() { int n; int a, b; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%d%d&quot;, &amp;a, &amp;b); for(register int i = 1;i &lt;= n;i++) scanf(&quot;%d%d&quot;, &amp;P[i].a, &amp;P[i].b); sort(P + 1, P + 1 + n); LL ans = 0; S = a; for(register int i = 1;i &lt;= n;i++) { ans = max(ans ,S / P[i].b); S *= P[i].a; } printf(&quot;%lld&quot;, ans); return 0; }没有考虑高精度，只是贪心思想。]]></content>
      <categories>
        <category>luogu</category>
        <category>NOIP</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2820】局域网]]></title>
    <url>%2F2019%2F02%2F18%2F106%2F</url>
    <content type="text"><![CDATA[原题 最小生成树而且我绝对不会说：我其实考试的时候没看出来…… 让删去的边最大。。那不就是让生成树最小吗。。。 于是，……最小生成树…… #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int _ = 310; struct edge{ int u; int v; int w; }; edge G[_]; int tot = 0; bool __CMP(const edge &amp;x, const edge &amp;y) { return x.w &lt; y.w; } struct Tree{ int F[_]; Tree (){} Tree(int n){ for(register int i = 1;i &lt;= n;i++)F[i] = i; } int find(int x) { return F[x] == x ? (F[x]):(find(F[x])); } void marge(int x, int y) { int f1 = this -&gt; find (x); int f2 = this -&gt; find (y); F[f1] = f2; } bool ask(int x, int y) { return this -&gt; find(x) == this -&gt; find(y); } }; Tree T; int main() { int n, k, sum = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(register int i = 1; i&lt;= k;i++) scanf(&quot;%d%d%d&quot;, &amp;G[i].u, &amp;G[i].v, &amp;G[i].w) , sum += G[i].w; sort(G + 1, G + 1 + k, __CMP); T = Tree(n); int ans = 0; for(register int i = 1;i &lt;= k;i++) { if(!T.ask(G[i].u, G[i].v)) { T.marge(G[i].u, G[i].v); ans += G[i].w; } } printf(&quot;%d&quot;, sum - ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错题集]]></title>
    <url>%2F2019%2F02%2F17%2Fe9-94-99-e9-a2-98-e9-9b-86%2F</url>
    <content type="text"><![CDATA[堆 - 2019-1-29记得pop()循环结束条件为now&lt;&lt;1&lt;=tot而不是now&lt;=tot。 记得pop()和push()循环结束条件都带着个等于号。 记得Z[]开四倍。 struct _heap{ private: int Z[40010]; int tot; void swap(int x,int y) { int tmp=Z[x]; Z[x]=Z[y]; Z[y]=tmp; } public: _heap() { tot=0; } void push(int x) { Z[++tot]=x; int now=tot; while((now&gt;&gt;1)&gt;=1) { int parent=now&gt;&gt;1; if(Z[now]&gt;=Z[parent])break; this-&gt;swap(now,parent); now=parent; } } void print() { for(int i=1;i&lt;=tot;i++) printf(&quot;%d &quot;,Z[i]); putchar(&apos;\n&apos;); } void pop() { Z[1]=Z[tot]; tot--; int now=1; while(now&lt;&lt;1&lt;=tot) { int son=now&lt;&lt;1; if(son+1&lt;=tot &amp;&amp; Z[son]&gt;Z[son+1])son++; if(Z[son]&gt;Z[now])break; this-&gt;swap(son,now); now=son; } } int top() { return Z[1]; } };]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营day1]]></title>
    <url>%2F2019%2F02%2F17%2Fluogu-e6-98-a5-e4-bb-a4-e8-90-a5day1%2F</url>
    <content type="text"><![CDATA[this博客没有写完，有空再写……二分&amp;三分之所以一开始就聊二/三分，是因为我觉得这东西比较有意思，而且主要是我一直不会。。。。 首先，最大值最小化和最小值最大化是两个二分的_标志_，当然没有这两个标志的问题也可能用二分。 二分，一般有两种情况：最小值最大化和最小值最大化。 最大值最小化二分一般的二分答案，其实就是在一个单调的函数上摩擦的操作。 这个函数可以不存在解析式，但是这个函数可以通过自变量取值得到函数值即可。 如果f(x)这个函数是判断取X是否合法的函数，而且具有单调性，那么其实这个函数的图像是这样的 或者 当x的值可以的时候，函数返回值为true，即为1。 当x的值不可以的时候，函数返回值为false，即为0。 二分查找的目的就在于找到函数图像的那个折点。 当然更复杂的就是函数值小于某个值的最大的x和函数值大于某个值的最小x（函数单调递增）。 来看一道例题。 题目描述：输入N个数，把这N个数划分为M段，SUM(i)表示第i段的区间和，现在需要得到一中划分方法，使最大的区间和最小。 解题思路：既然要求最大的区间和最小，那我们先分解这个问题；第一步是求出最大的区间和；然后第二步就是找出最小的那一个最大区间和。废话 我们先设最大的区间和为x，易得:任意一个i都可以使SUM(i)&lt;=x成立。 然后通过二分答案的方法查找一个在满足条件的情况下最小的x。 这样问题就转化为找下图中的折点。 //最大值最小化 int le = 1, ri = n, mid, ans; while (le &lt;= ri) { mid = (le + ri) / 2; if (check(mid)) ans = mid, ri = mid - 1; else le = mid + 1; } ans //最小值最大化 int le = 1, ri = n, mid, ans; while (le &lt;= ri) { mid = (le + ri) / 2; if (check(mid)) ans = mid, le = mid + 1; else ri = mid - 1; } ans //求实数 double le = 1, ri = n, mid; for (int i = 1; i &lt;= 50; i++) { mid = (le + ri) / 2; if (check(mid)) ri = mid; else le = mid; } ans //三分 le = 0; ri = min(i - 1, n - i); while (le + 1 &lt;= ri) { w1 = (ri - le) / 3 + le; w2 = ri - (ri - le) / 3; v1 = make(i, w1); v2 = make(i, w2); if (v1 &gt; v2) ri = w2 - 1; else le = w1 + 1; } leDFS判断存在环]]></content>
      <categories>
        <category>OI</category>
        <category>培训</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营 2]]></title>
    <url>%2F2019%2F02%2F17%2F90%2F</url>
    <content type="text"><![CDATA[很多来自WJH老师的课件，若侵权then删除 TopSort很少有特别裸的，图论反正都是这熊样，先建图，然后各种套模板 适用性TopSort适用于DAG。 判断题目的关系是否能构成DAG。 int ind[MAXN]; int d[MAXN]; int q[MAXN], qhead = 0, qtail = 0;//队列相关 void topo() { for (int i = 1; i &lt;= n; i++) { if (!ind[i]) q[qtail++] = i; } while (qhead != qtail) { int now = q[qhead++]; for (int i = he[now]; i; i = ne[i]) { Edge &amp;e = ed[i]; d[e.to] = max(d[e.to], d[now] + 1);//DAG上最长路 if (!--ind[e.to]) q[qtail++] = e.to; } } }待做例题 luoguP1983 车站分级 最小生成树&amp;并查集struct UnionSet { int f[MAXN]; UnionSet(int n) { for (int i = 1; i &lt;= n; i++) { f[i] = i; } } UnionSet(){} void uni(int x, int y) { f[find(x)] = find(y); } bool query(int x, int y) { return find(x) == find(y); } int find(int x) { return f[x] == x ? x : (f[x] = find(f[x])); } } us; void kruskal() { sort(edges, edges+m); us = UnionSet(n); for (int i = 0; i &lt; m &amp;&amp; etop &lt; n * 2 - 1; i++) { Edge &amp;e = edges[i]; if (!us.query(e.from, e.to)) { insert(e.from, e.to, e.dist); insert(e.to, e.from, e.dist); us.uni(e.from, e.to); } } }待做例题 luogu 模板题 P3366 luogu 买礼物P1194 最短路两大“冤家”算法比较Dijkstra算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：O(n²)（原版）/O(mlogn)(堆优化) 无法处理负权 每次找到离当前结点直接相连且最短的点，设置为确定点（这里可以看初如果边权为负的话，就不能确定这个点是确定点=GG）。再以当前点为当前结点，继续松弛。 SPFA算法，即队列优化的Bellman-Ford算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：声称为O(m)，最坏O(nm)，容易卡到最坏 可以处理负权边，可以判断负权环 其实就是在用边松弛的时候，没必要用每一条边松弛这个图，只需要使用那些上一次被更新答案的边松弛即可。 大概就是如果有负权就用 dijkstra代码int d[MAXN]; bool vis[MAXN]; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q; int dijkstra(int s, int t){ memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while(!q.empty()){ int now = q.top().second; q.pop(); if(!vis[now]){ vis[now] = true; for(int i = he[now]; i; i = ne[i]){ Edge&amp; e = ed[i]; if(d[e.to] &gt; d[now] + e.dist){ d[e.to] = d[now] + e.dist; q.push(make_pair(d[e.to], e.to)); } } } } return d[t] == INF ? -1 : d[t]; }SPFA代码bool inq[MAXN]; queue&lt;int&gt; q; inline int spfa(int s, int t) { q.push(s); inq[s] = true; memset(d, 0x3f, sizeof(d)); d[s] = 0; while (!q.empty()) { int now = q.front(); q.pop(); inq[now] = false; for (int i = he[now]; i; i = ne[i]) { Edge &amp;e = ed[i]; if (d[now] + e.dist &lt; d[e.to]) { d[e.to] = d[now] + e.dist; if (!inq[e.to]) { q.push(e.to); inq[e.to] = true; } } } } return d[t] == INF ? -1 : d[t]; }待做例题 luogu模板题 P3371 luoug P1119 灾后重建(感受一下离线) luogu P1629 邮递员送信（反图） Tarjan用途很多很多很多…… 如果用来缩点。就是在一个有环有向图里面，我们可以用tarjan把强连通分量们弄成一个点，当然这个点权可能就是_最大/最小值_或者和。然后肯定就成DAG了，然后可以尽情的TopSort了。 四种边：为了更好理解tarjan我们定义四种边。 P.S:只要_DFN小_那就在以其为根的子树中。 树枝边：A边终点未访问过（找到一个有边相连而且没有被访问的就好） 前向边：B边终点已被访问过，且dfn[v]&gt;dfn[u]，说明在子树中（只需要判断是否有边相连而且在栈内即可） 后向边：C边终点已被访问过且不在子树中，终点在栈中 横叉边：D边终点已被访问过且不在子树中 且 已经出栈 分别操作：图自老师的PPT 维护一个数组low，low[u]代表点u所能到达的，深度最小的点的dfs序编号。 更新LOW 对于边(u,v) 若为树枝边，则用low[v]更新 若为后向边，则用dfn[v]更新 后向边一定已经更新过，所以不需要处理 横叉边属于别的强连通分量，别瞎操心 简单来说，若使用边(u,v)更新LOW[u]，那么: LOW[u]=MIN{ DFN(v)//后向边 LOW(v)//树枝边 DFN(u)//当然初始化就是自己的dfs序。特别想一下这个点没有出边的情况。 }示例代码int s[MAXN], stop; int dfn[MAXN], low[MAXN]; int scccnt, sccnum[MAXN];//属于同一个强连通分量的，sccnum的值相同。 int dfscnt; inline void tarjan(int now){ dfn[now] = low[now] = ++dfscnt; s[stop++] = now; for (int i = he[now]; i != 0 ; i = ne[i]){ if (!dfn[ed[i]]) { tarjan(ed[i]); low[now] = min(low[now], low[ed[i]]); } else if(!sccnum[ed[i]]) { low[now] = min(low[now], dfn[ed[i]]); } } if (dfn[now] == low[now]) { scccnt++; do { sccnum[s[--stop]] = scccnt; } while(s[stop] != now); } }待做例题 luogu模板 P3387]]></content>
      <categories>
        <category>OI</category>
        <category>培训</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3372】【模板】线段树 1]]></title>
    <url>%2F2019%2F02%2F17%2Fe3-80-90luogu-3372-e3-80-91-e3-80-90-e6-a8-a1-e6-9d-bf-e3-80-91-e7-ba-bf-e6-ae-b5-e6-a0-91-1%2F</url>
    <content type="text"><![CDATA[#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; using namespace std; const int _ = 400010; #define ll long long struct Node{ ll S; ll tar; Node * lson, * rson; Node(){ S = tar = 0; lson = rson = NULL; } }POOL[_]; int __tot__ = 0; inline Node * malloc_(){return &amp;POOL[__tot__++];} inline void updata(Node * tree) { tree -&gt; S = tree -&gt; lson -&gt; S + tree -&gt; rson -&gt; S; } void build(Node * tree, int l, int r) { if(l == r) { scanf(&quot;%lld&quot;, &amp;tree -&gt; S); return ; } int mid = (l + r) &gt;&gt; 1; tree -&gt; lson = malloc_(); tree -&gt; rson = malloc_(); build(tree -&gt; lson, l, mid); build(tree -&gt; rson, mid + 1, r); updata(tree); } void tar(Node * tree, int l, int r, ll val) { if(tree == NULL) return; tree -&gt; S += (r - l + 1) * val; tree -&gt; tar += val; } void push(Node * tree, int l, int r) { if(tree == NULL || l == r) return;///////////// int mid = (l + r) &gt;&gt; 1; tar(tree -&gt; lson, l, mid, tree -&gt; tar); tar(tree -&gt; rson, mid + 1, r, tree -&gt; tar); tree -&gt; tar = 0; } void change(Node * tree, int nowl, int nowr, ll val, int l, int r) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) { tar(tree, nowl, nowr, val); return ; } push(tree, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(tree -&gt; lson, nowl, mid, val, l, r); if(r &gt; mid) change(tree -&gt; rson, mid + 1, nowr, val, l, r); updata(tree); } ll query(Node * tree, int nowl,int nowr, int l, int r) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return tree -&gt; S; int mid = (nowl + nowr) &gt;&gt; 1; ll ans = 0; push(tree, nowl, nowr); if(l &lt;= mid) ans += query(tree -&gt; lson, nowl, mid, l, r); if(r &gt; mid) ans += query(tree -&gt; rson, mid + 1, nowr, l, r); return ans ; } int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); Node * root = malloc_(); build(root, 1, n); for(register int i = 1;i &lt;= m;i++) { int op; scanf(&quot;%d&quot;, &amp;op); if(op == 1) { int x, y; ll k; scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;k); change(root, 1, n, k, x, y); } else { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); printf(&quot;%lld\n&quot;, query(root, 1, n, x, y)); } } return 0; } #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define root 1,n,1 #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 #define nownode l,r,rt #define max(a,b) (a)&gt;(b)?(a):(b)//虽然可以用stl或者自己写个正儿八经的函数，但是这样写起来据说能快一点，毕竟调用栈空间也是需要时间的。。。 #define min(a,b) (a)&lt;(b)?(a):(b) //同上 #define LL long long using namespace std; const int MAXN=100000+10; long long z[MAXN&lt;&lt;2];//位运算，相当于MAXN*4 long long col[MAXN&lt;&lt;2];//同上 void updata(int rt)//更新数据函数，rt为待更新的结点编号 { z[rt]=z[rt&lt;&lt;1]+z[rt&lt;&lt;1|1];//位运算，相当于z[rt/2]+z[rt/2+1] } void color(int l,int r,int rt,LL v) //参数说明：区间【l，r】，编号为rt，打上“加上V”的标记 { z[rt]+=(r-l+1)*v;//区间修改的话，需要打lazy标记， //也就是需要先将此处结点（被修改区间完全覆盖的）数据更新（因为是在某一段区间的所有数都加一个数V，所以这段区间的和就要加上【区间长度】*V就好） col[rt]+=v; //为它这个结点打lazy，表示rt这个结点的孩子们都要加上V，（现在还没加上V，先打标记，不继续操作）。 //标记颜色需要累加，不能col[rt]=v; } void push_color(int l,int r,int rt)//下放标记 //参数说明：区间【l，r】，编号为rt { if(col[rt]!=0)//如果这个结点有标记的话 //（废话。。没标记还下放个pi { int m=(l+r)&gt;&gt;1;//相当于（l+r）/2 color(lson,col[rt]);//为rt结点的左儿子打标记 color(rson,col[rt]);//为rt结点的左儿子打标记 col[rt]=0;//因为已经下放了，就清除这个结点的标记 } } void build(int l,int r,int rt)//建立这个线段树 //建立区间【l，r】，编号为rt的结点 //虽然根据rt就可以算出来区间【l，r】，但是这样写会方便很多 { if(l==r)//已经是叶子结点了 { scanf(&quot;%lld&quot;,&amp;z[rt]);//直接读入就好 return ;//建立完成此节点就GG } int m=(l+r)&gt;&gt;1;//相当于（l+r）/2 build(lson);//建立左儿子 build(rson);//建立右儿子 //WARNING：以上两行顺序不可换。 updata(rt);//俩儿子建立完成了，那就根据俩儿子的数据，来更新自己的数据就欧克。 } void modify(int l,int r,int rt,int nowl,int nowr,LL v)//修改函数 //参数说明：在区间【l，r】（编号为rt）内为【nowl,nowr】区间加上V //貌似很难懂 //其实就是，我们始终要修改【nowl,nowr】这个很大的区间，但是现在我们现在管不了那么多，就先修改【nowl,nowr】在【l，r】里面的部分。 { if(nowl&lt;=l&amp;&amp;r&lt;=nowr)//如果这个【l，r】区间已经被【nowl,nowr】完全包含了，也就是【l，r】里面的数据都要修改。 { color(nownode,v);//直接打标记就欧克 return ; } push_color(nownode);//下放标记，没错，千辛万苦打的标记就是在修改/查询的时候下放 int m=(l+r)&gt;&gt;1;////相当于（l+r）/2 if(nowl&lt;=m)modify(lson,nowl,nowr,v);//如果需要修改左儿子，那就修改它 if(nowr&gt;m)modify(rson,nowl,nowr,v);//如果需要修改右儿子，那就修改它 updata(rt);//俩儿子修改完后，更新这个结点数据 } LL query(int l,int r,int rt,int nowl,int nowr)//终于写到查询了。。。。 //参数说明：在区间【l，r】，编号rt，查询sum（【nowl，nowr】） //貌似又很难懂 //其实就是，我们始终要查询【nowl,nowr】这个很大的区间和，但是现在我们现在管不了那么多，就先查询【nowl,nowr】在【l，r】里面的部分数据的和。 { if(nowl&lt;=l&amp;&amp;r&lt;=nowr) { return z[rt]; } int m=(l+r)&gt;&gt;1; LL ans=0;//WARNKING ::: VAL ans MUST INIT push_color(nownode); //下放标记，没错，千辛万苦打的标记就是在修改/查询的时候下放 if(nowl&lt;=m)ans+=query(lson,nowl,nowr); //如果右儿子在查询的区间里面，那就ans再加上右儿子的和 if(nowr&gt;m)ans+=query(rson,nowl,nowr);//如果右儿子在查询的区间里面，那就ans再加上右儿子的和 return ans; } int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); build(root); int op,x,y;LL k; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;op); if(op==1) { scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;k); modify(root,x,y,k); } else { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%lld\n&quot;,query(root,x,y)); } } return 0; //不要忘了好习惯。 }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-AT46 】【AtCoder】リモコン]]></title>
    <url>%2F2019%2F02%2F17%2Fe3-80-90luogu-at46-e3-80-91-e3-80-90atcoder-e3-80-91-e3-83-aa-e3-83-a2-e3-82-b3-e3-83-b3%2F</url>
    <content type="text"><![CDATA[推荐一个做法：迭代加深搜索 感觉比广搜要好写一些，其实就是加了一点别的东西的DFS 这里是luogu网校提高组讲义里的一段话，供参考。 具体来看下代码。 希望通过此题，大家能了解到这个比较冷门的算法，自我感觉挺好用。。。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; int A,B; bool haveAns=false;//用途如名，判断是否已经找到解 void DFS(int x,int deep,const int maxDeep) //x是当前已经调到的值；deep是迭代深度；maxDeep是规定的最大迭代深度，目的就是我们不会让dfs沿着解答树的一边一头扎下去。 { if(haveAns)return; if(x==B){//找到解 haveAns=true;//更新状态 return; } if(deep&gt;maxDeep)return;//限制最大迭代深度 DFS(x+5,deep+1,maxDeep); DFS(x+1,deep+1,maxDeep); DFS(x+10,deep+1,maxDeep); DFS(x-1,deep+1,maxDeep); DFS(x-5,deep+1,maxDeep); DFS(x-10,deep+1,maxDeep); } int main() { scanf(&quot;%d%d&quot;,&amp;A,&amp;B); if(A==B){cout&lt;&lt;0&lt;&lt;endl;return 0;}//之前的温度和调完的温度一样那还调啥，直接输出0步。 int deep=abs(A-B)+5;//我们规定一个最大的深度（即每次调高或者调低一度，最大需要调节abs（A-B）次） //至于+5.。。这个是玄学，反正大一点总是好的。。+1就可以其实，但是时间充足，不差钱（时间）。。 int i; for(i=1;i&lt;=deep&amp;&amp;!haveAns;i++)//循环条件，就是没有超过最大深度，而且没找到解。 DFS(A,1,i); //这样答案就是i-1。我们来考虑一下这东西的流程。 //我先用dfs判断，如果调1步行不行； //如果不行，那就调两步行不行； //如果还不行，那就调三步行不行 //如果还不行，那就调四步行不行 //…………………… //最后总有一种步数是可以的，这时候跳出循环，然后输出结果。 cout&lt;&lt;--i&lt;&lt;endl; return 0; } //其实代码炒鸡短。。去掉注释大概30行左右。（当然还能更短）]]></content>
      <categories>
        <category>AtCoder</category>
        <category>luogu</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4051】【JSOI2007】字符加密]]></title>
    <url>%2F2019%2F02%2F17%2Fe3-80-90luogu-4051-e3-80-91-e3-80-90jsoi2007-e3-80-91-e5-ad-97-e7-ac-a6-e5-8a-a0-e5-af-86%2F</url>
    <content type="text"><![CDATA[提供一种思路，不保证是最好的，但是代码好像是最短的。。。。。 例如JSOI07， 可以读作： - JSOI07 - SOI07J - OI07JS - I07JSO - 07JSOI - 7JSOI0 把它们按照字符串的大小排序： - 07JSOI - 7JSOI0 - I07JSO - JSOI07 - OI07JS - SOI07J 读出最后一列字符：I0O7SJ， 对于此题，其实还有一种比较恶心（玄学）的做法。 对，没错确实恶心。 其实对于给出的字符串S，我们可以有strlen(S)种读法，其实我们不关心这些读法到底是什么，我们只需要关心这些读法的最后一个字符是什么。 那么如何得知最后一个字符是什么呢？ 显然，你只需要知道这一个读法第一个字符就可以。 去观察一下那些字符串： 原字符串：JSOI07 可以读作： - JSOI07 - SOI07J - OI07JS - I07JSO - 07JSOI - 7JSOI0 //以这个为例，最后一个字符是0，第一个是7 我们可以得到如下结论，如果最后一个字符是原字符串的第i个，那它对应的第一个字符是原字符串的第i + 1个。 所以我们知道这个字符串各种读法 排好序后的第一个字符就可以了， 那这个又咋求呢？ （直接排原字符串就好了啊。。。。） 嗯对， 就这么骚。。 简单说就是把源字符串本身进行排序，然后对于每个字符找到原来字符串的前一个，组成字符串输出就可以了。。。 代码如下： //代码中，我没有直接对原字符串排序，我排了一下这个字符串的顺序，就是我没有改变原字符串，而是记录了某个字符排序前的位置。 //紫书里面说过好像。叫什么间接排序之类的。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int _ = 200010; char S[_]; int S_id[_]; int len; bool __CMP(const int &amp;x, const int &amp;y) { int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) {px++;py++;k++;} return S[px] &lt; S[py]; }//排序规则这里，while循环是为了防止字符重复，重复的话就往后找（字典序哦~）， //k的话。。。为了防止全都是重复的，然后找个不停。。。 //有一个点就卡这个东西。。 int main() { scanf(&quot;%s&quot;, S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i];//把原来的串再接到原来的串后面，找“前一个”字符时比较方便。 for (int i = 0; i &lt; len; i++) S_id[i] = i;//记录原来字符串，每个字符的位置，没排序前，第一个就在原来字符串的第一个，第二个就在第二个 sort(S_id, S_id + len, __CMP); //对这个记录序号的数组排序。 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]);//这里输出就好了，三目运算符自己看一下就欧克了。 return 0; }最后再展示一下没有注释的代码，得瑟一下代码长度 数据可能再稍微强一点我就GG了…… #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int _ = 200010; char S[_]; int S_id[_]; int len; bool oldsu(const int &amp;x, const int &amp;y) { int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) {px++;py++;k++;} return S[px] &lt; S[py]; } int main() { scanf(&quot;%s&quot;, S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i]; for (int i = 0; i &lt; len; i++) S_id[i] = i; sort(S_id, S_id + len, oldsu); //100000 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>省选题目</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-P4051】【JSOI2007】字符加密]]></title>
    <url>%2F2019%2F02%2F10%2F%E3%80%90luogu-P4051%E3%80%91%E3%80%90JSOI2007%E3%80%91%E5%AD%97%E7%AC%A6%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[提供一种思路，不保证是最好的，但是代码好像是最短的。。。。。 例如JSOI07， 可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ， 对于此题，其实还有一种比较恶心（玄学）的做法。 对，没错确实恶心。 其实对于给出的字符串S，我们可以有strlen(S)种读法，其实我们不关心这些读法到底是什么，我们只需要关心这些读法的最后一个字符是什么。 那么如何得知最后一个字符是什么呢？ 显然，你只需要知道这一个读法第一个字符就可以。 去观察一下那些字符串： 原字符串：JSOI07 可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 //以这个为例，最后一个字符是0，第一个是7 我们可以得到如下结论，如果最后一个字符是原字符串的第i个，那它对应的第一个字符是原字符串的第i + 1个。 所以我们知道这个字符串各种读法 排好序后的第一个字符就可以了， 那这个又咋求呢？ （直接排原字符串就好了啊。。。。） 嗯对， 就这么骚。。 简单说就是把源字符串本身进行排序，然后对于每个字符找到原来字符串的前一个，组成字符串输出就可以了。。。 代码如下： 1234567891011121314151617181920212223242526272829//代码中，我没有直接对原字符串排序，我排了一下这个字符串的顺序，就是我没有改变原字符串，而是记录了某个字符排序前的位置。//紫书里面说过好像。叫什么间接排序之类的。#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int _ = 200010;char S[_];int S_id[_];int len;bool __CMP(const int &amp;x, const int &amp;y)&#123; int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) &#123;px++;py++;k++;&#125; return S[px] &lt; S[py];&#125;//排序规则这里，while循环是为了防止字符重复，重复的话就往后找（字典序哦~），//k的话。。。为了防止全都是重复的，然后找个不停。。。//有一个点就卡这个东西。。int main()&#123; scanf("%s", S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i];//把原来的串再接到原来的串后面，找“前一个”字符时比较方便。 for (int i = 0; i &lt; len; i++) S_id[i] = i;//记录原来字符串，每个字符的位置，没排序前，第一个就在原来字符串的第一个，第二个就在第二个 sort(S_id, S_id + len, __CMP); //对这个记录序号的数组排序。 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]);//这里输出就好了，三目运算符自己看一下就欧克了。 return 0;&#125; 最后再展示一下没有注释的代码，得瑟一下代码长度 数据可能再稍微强一点我就GG了…… 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int _ = 200010;char S[_];int S_id[_];int len;bool oldsu(const int &amp;x, const int &amp;y)&#123; int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) &#123;px++;py++;k++;&#125; return S[px] &lt; S[py];&#125;int main()&#123; scanf("%s", S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i]; for (int i = 0; i &lt; len; i++) S_id[i] = i; sort(S_id, S_id + len, oldsu); //100000 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]); return 0;&#125;]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营-Day2]]></title>
    <url>%2F2019%2F01%2F29%2Fluogu%E6%98%A5%E4%BB%A4%E8%90%A5-Day2%2F</url>
    <content type="text"><![CDATA[很多来自WJH老师的课件，若侵权then删除 TopSort 很少有特别裸的，图论反正都是这熊样，先建图，然后各种套模板 适用性 TopSort适用于DAG。 判断题目的关系是否能构成DAG。 123456789101112131415161718int ind[MAXN];int d[MAXN];int q[MAXN], qhead = 0, qtail = 0;//队列相关void topo() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (!ind[i]) q[qtail++] = i; &#125; while (qhead != qtail) &#123; int now = q[qhead++]; for (int i = he[now]; i; i = ne[i]) &#123; Edge &amp;e = ed[i]; d[e.to] = max(d[e.to], d[now] + 1);//DAG上最长路 if (!--ind[e.to]) q[qtail++] = e.to; &#125; &#125;&#125; 待做例题 luoguP1983 车站分级 最小生成树&amp;并查集1234567891011121314151617181920212223242526272829303132333435struct UnionSet &#123; int f[MAXN]; UnionSet(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i] = i; &#125; &#125; UnionSet()&#123;&#125; void uni(int x, int y) &#123; f[find(x)] = find(y); &#125; bool query(int x, int y) &#123; return find(x) == find(y); &#125; int find(int x) &#123; return f[x] == x ? x : (f[x] = find(f[x])); &#125;&#125; us;void kruskal() &#123; sort(edges, edges+m); us = UnionSet(n); for (int i = 0; i &lt; m &amp;&amp; etop &lt; n * 2 - 1; i++) &#123; Edge &amp;e = edges[i]; if (!us.query(e.from, e.to)) &#123; insert(e.from, e.to, e.dist); insert(e.to, e.from, e.dist); us.uni(e.from, e.to); &#125; &#125;&#125; 待做例题 luogu 模板题 P3366 luogu 买礼物P1194 最短路两大“冤家”算法比较Dijkstra算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：O(n²)（原版）/O(mlogn)(堆优化) 无法处理负权 每次找到离当前结点直接相连且最短的点，设置为确定点（这里可以看初如果边权为负的话，就不能确定这个点是确定点=GG）。再以当前点为当前结点，继续松弛。SPFA算法，即队列优化的Bellman-Ford算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：声称为O(m)，最坏O(nm)，容易卡到最坏 可以处理负权边，可以判断负权环 其实就是在用边松弛的时候，没必要用每一条边松弛这个图，只需要使用那些上一次被更新答案的边松弛即可。大概就是如果有负权就用dijkstra代码1234567891011121314151617181920212223int d[MAXN];bool vis[MAXN];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q;int dijkstra(int s, int t)&#123; memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while(!q.empty())&#123; int now = q.top().second; q.pop(); if(!vis[now])&#123; vis[now] = true; for(int i = he[now]; i; i = ne[i])&#123; Edge&amp; e = ed[i]; if(d[e.to] &gt; d[now] + e.dist)&#123; d[e.to] = d[now] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; return d[t] == INF ? -1 : d[t];&#125; SPFA代码1234567891011121314151617181920212223bool inq[MAXN];queue&lt;int&gt; q;inline int spfa(int s, int t) &#123; q.push(s); inq[s] = true; memset(d, 0x3f, sizeof(d)); d[s] = 0; while (!q.empty()) &#123; int now = q.front(); q.pop(); inq[now] = false; for (int i = he[now]; i; i = ne[i]) &#123; Edge &amp;e = ed[i]; if (d[now] + e.dist &lt; d[e.to]) &#123; d[e.to] = d[now] + e.dist; if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = true; &#125; &#125; &#125; &#125; return d[t] == INF ? -1 : d[t];&#125; 待做例题 luogu模板题 P3371 luoug P1119 灾后重建(感受一下离线) luogu P1629 邮递员送信（反图） Tarjan用途 很多很多很多…… 如果用来缩点。就是在一个有环有向图里面，我们可以用tarjan把强连通分量们弄成一个点，当然这个点权可能就是最大/最小值或者和。然后肯定就成DAG了，然后可以尽情的TopSort了。 四种边： 为了更好理解tarjan我们定义四种边。 P.S:只要DFN小那就在以其为根的子树中。 树枝边：A边终点未访问过（找到一个有边相连而且没有被访问的就好） 前向边：B边终点已被访问过，且dfn[v]&gt;dfn[u]，说明在子树中（只需要判断是否有边相连而且在栈内即可） 后向边：C边终点已被访问过且不在子树中，终点在栈中 横叉边：D边终点已被访问过且不在子树中 且 已经出栈 分别操作：图自老师的PPT 维护一个数组low，low[u]代表点u所能到达的，深度最小的点的dfs序编号。 更新LOW 对于边(u,v) 若为树枝边，则用low[v]更新 若为后向边，则用dfn[v]更新 后向边一定已经更新过，所以不需要处理 横叉边属于别的强连通分量，别瞎操心 简单来说，若使用边(u,v)更新LOW[u]，那么: 12345LOW[u]=MIN&#123; DFN(v)//后向边 LOW(v)//树枝边 DFN(u)//当然初始化就是自己的dfs序。特别想一下这个点没有出边的情况。&#125; 示例代码123456789101112131415161718192021222324int s[MAXN], stop;int dfn[MAXN], low[MAXN];int scccnt, sccnum[MAXN];//属于同一个强连通分量的，sccnum的值相同。int dfscnt;inline void tarjan(int now)&#123; dfn[now] = low[now] = ++dfscnt; s[stop++] = now; for (int i = he[now]; i != 0 ; i = ne[i])&#123; if (!dfn[ed[i]]) &#123; tarjan(ed[i]); low[now] = min(low[now], low[ed[i]]); &#125; else if(!sccnum[ed[i]]) &#123; low[now] = min(low[now], dfn[ed[i]]); &#125; &#125; if (dfn[now] == low[now]) &#123; scccnt++; do &#123; sccnum[s[--stop]] = scccnt; &#125; while(s[stop] != now); &#125;&#125; 待做例题 luogu模板 P3387]]></content>
      <tags>
        <tag>洛谷网课</tag>
        <tag>外出培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营-Day1]]></title>
    <url>%2F2019%2F01%2F29%2Fluogu%E6%98%A5%E4%BB%A4%E8%90%A5-Day1%2F</url>
    <content type="text"><![CDATA[首先这些文字都是给我自己看的，所以比较土。。 博客没有写完，有空再写……二分&amp;三分 之所以一开始就聊二/三分，是因为我觉得这东西比较有意思，而且主要是我一直不会。。。。 首先，最大值最小化和最小值最大化是两个二分的标志，当然没有这两个标志的问题也可能用二分。 二分，一般有两种情况：最小值最大化和最小值最大化。 最大值最小化二分 一般的二分答案，其实就是在一个单调的函数上摩擦的操作。 这个函数可以不存在解析式，但是这个函数可以通过自变量取值得到函数值即可。 如果f(x)这个函数是判断取X是否合法的函数，而且具有单调性，那么其实这个函数的图像是这样的 或者 当x的值可以的时候，函数返回值为true，即为1。 当x的值不可以的时候，函数返回值为false，即为0。 二分查找的目的就在于找到函数图像的那个折点。 当然更复杂的就是函数值小于某个值的最大的x和函数值大于某个值的最小x（函数单调递增）。 来看一道例题。 题目描述： 输入N个数，把这N个数划分为M段，SUM(i)表示第i段的区间和，现在需要得到一中划分方法，使最大的区间和最小。 解题思路： 既然要求最大的区间和最小，那我们先分解这个问题；第一步是求出最大的区间和；然后第二步就是找出最小的那一个最大区间和。废话 我们先设最大的区间和为x，易得:任意一个i都可以使SUM(i)&lt;=x成立。 然后通过二分答案的方法查找一个在满足条件的情况下最小的x。 这样问题就转化为找下图中的折点。 12345678910//最大值最小化int le = 1, ri = n, mid, ans;while (le &lt;= ri)&#123; mid = (le + ri) / 2; if (check(mid)) ans = mid, ri = mid - 1; else le = mid + 1;&#125;ans 1234567891011121314151617181920212223242526272829303132//最小值最大化int le = 1, ri = n, mid, ans;while (le &lt;= ri)&#123; mid = (le + ri) / 2; if (check(mid)) ans = mid, le = mid + 1; else ri = mid - 1;&#125;ans//求实数double le = 1, ri = n, mid;for (int i = 1; i &lt;= 50; i++)&#123; mid = (le + ri) / 2; if (check(mid)) ri = mid; else le = mid;&#125;ans//三分le = 0; ri = min(i - 1, n - i);while (le + 1 &lt;= ri)&#123; w1 = (ri - le) / 3 + le; w2 = ri - (ri - le) / 3; v1 = make(i, w1); v2 = make(i, w2); if (v1 &gt; v2) ri = w2 - 1; else le = w1 + 1;&#125;le DFS判断存在环]]></content>
      <tags>
        <tag>洛谷网课</tag>
        <tag>外出培训</tag>
      </tags>
  </entry>
</search>
