<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【luogu-3026】【USACO11OPEN】学习语言Learning Languages]]></title>
    <url>%2F%E3%80%90luogu-3026%E3%80%91%E3%80%90USACO11OPEN%E3%80%91%E5%AD%A6%E4%B9%A0%E8%AF%AD%E8%A8%80Learning%20Languages%2F</url>
    <content type="text"><![CDATA[A New Idea 提供一种新的思路，把每个语言和每只牛看成一个点。 如果某只牛会说这种语言，就让这个牛代表的节点向这个语言代表的节点连一条双向边。 然后判断图有几个连通块即可 连通块之间连边就相当于这条边的某一个牛需要一本书学语言。 我们可以知道如果有nnn个联通块，那么只需要n−1n - 1n−1条边就能使整个图联通。 code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*! * FileName: luogu-3026.cpp * This Problem is on luogu. The ID of the problem is 3026. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-09-03 17:07:16 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 11000;const int _M = 31000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m;int head[_N + _M];struct edges&#123; int node; int nxt;&#125;edge[1100000];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v;&#125;bool vis[_N + _M];void dfs(int now)&#123; vis[now] = true; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(vis[exNode]) continue; dfs(exNode); &#125;&#125;int main()&#123; n = read(), m = read(); for(register int i = 1;i &lt;= n;i++) &#123; int k = read(); for(register int j = 1;j &lt;= k;j++) &#123; int tmp = read(); add(i, n + tmp); add(n + tmp, i); &#125; &#125; int ans = 0 ; memset(vis, false, sizeof(vis)); for(register int i = 1;i &lt;= n;i++) if(!vis[i]) &#123; dfs(i); ans ++; &#125; printf("%d", ans - 1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-5091】【模板】欧拉定理]]></title>
    <url>%2F%E3%80%90luogu-5091%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于欧拉定理 定义 φ(n)​\varphi(n)​φ(n)​表示在区间[1,n−1]​[1, n - 1]​[1,n−1]​所有整数中，与n​n​n​互质的数字个数。 通项公式 φ(x)=x×∏1n(1−1pi)​\varphi(x) = x \times \prod_{1}^{n}(1 - \frac{1}{p_i})​ φ(x)=x×1∏n​(1−pi​1​)​ 性质 ab≡{ab%φ(n)( mod n) b&lt;φ(n)ab%φ(n)+φ(n)( mod n) b≥φ(n)a^b\equiv \left\{ \begin{aligned} a^{b\%\varphi(n)} (\bmod\ n)\ \ \ \ \ \ \ \ \ \ b&lt;\varphi(n)\\ a^{b\%\varphi(n)+\varphi(n)}(\bmod\ n)\ \ b\geq\varphi(n) \end{aligned} \right.ab≡{ab%φ(n)(mod n) b&lt;φ(n)ab%φ(n)+φ(n)(mod n) b≥φ(n)​ 积性函数： gcd(a,b)=1​gcd(a, b) = 1​gcd(a,b)=1​时，$ \varphi(a) \times \varphi(b) = \varphi(a \times b)​$ ppp为素数时，φ(p)=p−1\varphi(p) = p - 1φ(p)=p−1、φ(pk)=pk−pk−1\varphi(p^k) = p^k - p^{k - 1}φ(pk)=pk−pk−1 n&gt;2​n &gt; 2​n&gt;2​时，φ(n)​\varphi(n)​φ(n)​为偶数。因为gcd(n,m)=1​gcd(n, m) = 1​gcd(n,m)=1​那么gcd(m,n−m)=1​gcd(m, n - m) = 1​gcd(m,n−m)=1​，即互质的数字总是成对出现。 小于 nnn 的数中，与 nnn互质的数的总和为 φ(n)×n2\varphi(n) \times \frac {n}{2}φ(n)×2n​ n​n​n​ 的因数（包括1​1​1​和本身）的欧拉函数之和等于 nnn 求法 123456789101112131415int phi(int val)&#123; int ans = val; for(int i = 2;i * i &lt;= val;i++) &#123; if(val % i == 0) &#123; ans = ans - ans / i; while(val % i == 0) val /= i; &#125; &#125; if(val &gt; 1) ans = ans - ans / val; return ans; &#125; 模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*! * FileName: luogu-5091.cpp * This Problem is on luogu. The ID of the problem is 5091. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-15 21:21:04 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int phi(int val)&#123; int ans = val; for(int i = 2;i * i &lt;= val;i++) &#123; if(val % i == 0) &#123; ans = ans - ans / i; while(val % i == 0) val /= i; &#125; &#125; if(val &gt; 1) ans = ans - ans / val; return ans; &#125;int a, m, ph;int IsBiger = false;int getB()&#123; int ans = 0; int MOD = ph; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; ans = (ans &lt;&lt; 1) + (ans &lt;&lt; 3); ans += (c - '0'); if(ans &gt; ans % MOD) IsBiger = true; ans %= MOD; c = getchar(); &#125;// cout&lt;&lt;"% = "&lt;&lt;MOD&lt;&lt;" ^ = "&lt;&lt;ans&lt;&lt;endl; return ans % MOD;&#125; int ksm(int a, int b, int p)&#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = (ans * 1LL * a) % p; a = (a * 1LL * a) % p; b &gt;&gt;= 1; &#125; return ans % p;&#125;int main()&#123; a = read(), m = read(); ph = phi(m); int b = getB();// printf("%d %d %d\n", a, b + ph, m); if(IsBiger) printf("%d", ksm(a, b + ph, m)); else printf("%d", ksm(a, b, m)); return 0;&#125; WARNING 注意分b&lt;φ(n)b &lt; \varphi(n)b&lt;φ(n)和b&gt;=φ(n)b &gt;= \varphi(n)b&gt;=φ(n)两种情况。指数较大时，指数b%φ(n)+φ(n)​b \% \varphi(n) + \varphi(n)​b%φ(n)+φ(n)​]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4549】【模板】裴蜀定理]]></title>
    <url>%2F%E3%80%90luogu-4549%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于题目 S=∑1n(Ai⋅Si),S&gt;0S = \sum_{1}^{n} (A_i \cdot S_i),S &gt; 0 S=1∑n​(Ai​⋅Si​),S&gt;0 给出序列AAA,求最小的SSS。 关于裴蜀 已知方程ax+by=cax + by = cax+by=c，只有ccc是(a,b)(a, b)(a,b)的倍数时，此方程才有正整数解。 我自己的想法 已知a⋅x+b⋅y=(a,b)a \cdot x + b \cdot y = (a, b)a⋅x+b⋅y=(a,b) 设c=(a,b)×k​c = (a, b) \times k​c=(a,b)×k​ 所以ak⋅x+bk⋅y=c​ak \cdot x + bk \cdot y = c​ak⋅x+bk⋅y=c​ 也就是新的a′x+b′y=ca&#x27;x + b&#x27;y = ca′x+b′y=c 于是成功证明了“ccc是(a,b)(a, b)(a,b)的倍数”是“ax+by=cax + by = cax+by=c有解”的必要条件……。 很好。（个鬼）。 关于本题 多个数和两个数是一样的。 若想使∑1n(Ai⋅Si)=S\sum_{1}^{n} (A_i \cdot S_i) = S∑1n​(Ai​⋅Si​)=S有解，那么SSS必须是(a,b)(a, b)(a,b)的倍数，SSS又要最小，很好，一倍不就完了。 对数列AAA去gcdgcdgcd就是答案 负数取绝对值就好了，系数能变成负数。 123456789101112131415161718192021222324252627282930313233343536373839404142/*! * FileName: luogu-4549.cpp * This Problem is on luogu. The ID of the problem is 4549. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-15 20:30:54 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int gcd(int a, int b)&#123;return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; int n = read(); int ans = 0; while(n--) &#123; int x = abs(read()); ans = gcd(ans, x); &#125; printf("%d", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3386】【模板】二分图匹配]]></title>
    <url>%2F%E3%80%90luogu-3386%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*! * FileName: luogu-3386.cpp * This Problem is on luogu. The ID of the problem is 3386. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-15 17:21:05 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 4100;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m;vector&lt;int&gt;G[_];bool vis[_];int with[_];bool find(int now)&#123; for(register int i = 0;i &lt; G[now].size();i++) &#123; int exNode = G[now][i]; if(!vis[exNode]) &#123; vis[exNode] = true; if(with[exNode] == 0 || find(with[exNode])) &#123; with[now] = exNode; with[exNode] = now; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; n = read(), m = read(); int e = read(); for(register int i = 1;i &lt;= e;i++) &#123; int u = read(); int v = read(); if(u &gt; n || v &gt; m) continue; G[u].push_back(n + v); G[n + v].push_back(u); &#125; int tot = 0; for(register int i = 1;i &lt;= n;i++) &#123; memset(vis, false, sizeof(vis)); if(find(i)) tot++; &#125; printf("%d", tot); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2746】【USACO5.3】Network of Schools]]></title>
    <url>%2F%E3%80%90luogu-2746%E3%80%91%E3%80%90USACO5-3%E3%80%91Network-of-Schools%2F</url>
    <content type="text"><![CDATA[写在前面 Tarjan缩点经典问题，证明其他题解已经泛滥了。。。我写一写我自己想法。 技巧（KEYS） 任务A：入读为000的点的个数 任务B: 求入度为000的点数与出度为0的点的个数的最大值值。 缩完点之后，可以使用set去除重复的边，进行重新建图。QAQ 好方便！ 注意 需要注意缩完点之后，只剩下一个点的情况QAQ不判断会WA一个点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/*! * FileName: luogu-2746.cpp * This Problem is on luogu. The ID of the problem is 2746. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-13 21:37:29 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;stack&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 110;const int _M = _N * _N;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v;&#125;int n;int dfn[_N];int low[_N];int dfnClock = 0;int scc[_N];int sccCnt = 0;stack &lt;int&gt; S;void tarjan(int now)&#123; low[now] = dfn[now] = ++dfnClock; S.push(now); for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dfn[exNode] == 0) &#123; tarjan(exNode); low[now] = min(low[now], low[exNode]); &#125; else if(scc[exNode] == 0) low[now] = min(low[now], dfn[exNode]); &#125; if(low[now] == dfn[now]) &#123; sccCnt ++; while(true) &#123; scc[S.top()] = sccCnt; if(S.top() == now) &#123; S.pop(); break; &#125; S.pop(); &#125; &#125;&#125;int outd[_N];int ind[_N];int main()&#123; n = read(); for(register int i = 1;i &lt;= n;i++) &#123; int tmp; while(true) &#123; tmp = read(); if(tmp == 0) break; add(i, tmp); &#125; &#125; for(register int i = 1;i &lt;= n;i++) if(dfn[i] == 0) tarjan(i); set&lt;pair&lt;int,int&gt; &gt; S; for(register int i = 1;i &lt;= n;i++) &#123; for(register int j = head[i];j;j = edge[j].nxt) &#123; int exNode = edge[j].node; if(scc[i] != scc[exNode]) S.insert(make_pair(scc[i], scc[exNode])); &#125; &#125; for(set&lt;pair&lt;int, int &gt; &gt;::iterator i = S.begin();i != S.end();i++) &#123; outd[(*i).first] ++; ind[(*i).second] ++; &#125; int ans1 = 0; int ans2 = 0; for(register int i = 1;i &lt;= sccCnt;i++) &#123; if(ind[i] == 0) ans1 ++; if(outd[i] == 0) ans2 ++; &#125; printf("%d\n%d\n", ans1, sccCnt == 1 ? 0 : max(ans1, ans2)) ; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3203】【HNOI2010】弹飞绵羊]]></title>
    <url>%2F%E3%80%90luogu-3203%E3%80%91%E3%80%90HNOI2010%E3%80%91%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A%2F</url>
    <content type="text"><![CDATA[分块，代码思路很明显。 有很多细节，注意分块维护要维护整个区间的信息，不要只修改一个点。 细节死亡…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/*! * FileName: luogu-3203.cpp * This Problem is on luogu. The ID of the problem is 3203. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-14 10:18:06 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 201000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m;int num;int belong[_];int step[_];int NxtNode[_];int block;void updata(int x)&#123; int node = x; int sk = belong[x]; int S = 0; while(belong[x] == sk) &#123; S += step[x]; x = NxtNode[x]; &#125; step[node] = S; NxtNode[node] = x;&#125;int query(int x)&#123; int ans = 0; while(x &lt;= n) &#123; ans += step[x]; x = NxtNode[x]; &#125; return ans;&#125;int SP[_]; int main()&#123;// freopen("data.in", "r", stdin); n = read();block = sqrt(n); for(register int i = 1;i &lt;= n;i++) &#123; int tmp = read(); SP[i] = tmp; NxtNode[i] = tmp + i; step[i] = 1; &#125; num = 1; for(register int i = 1;i &lt;= n;i++) belong[i] = (i &gt; num * block) ? (++ num) : num; for(register int i = n;i &gt;= 1;i--) updata(i);// cout&lt;&lt;"belong: " ; for(register int i = 1;i &lt;= n;i++) printf("%d ", belong[i]) ;cout&lt;&lt;endl;// for(register int i = 1;i &lt;= n;i++)// &#123;// printf(":%d : ", i);// printf("step = %d, ", step[i]);// printf("NxtNode = %d \n", NxtNode[i]);// &#125; m = read(); while(m --) &#123; int opt = read(); if(opt == 1) &#123; int x = read() + 1; int ans = query(x); printf("%d\n", ans); &#125; if(opt == 2) &#123; int x = read() + 1; int val = read(); SP[x] = val; NxtNode[x] = x + val; step[x] = 1;// int nowk = belong[x]; int L = ((belong[x] - 1) * block) + 1; int R = ((belong[x]) * block);// printf("Updata %d to %d\n", x, L); for(register int i = L;i &lt;= R;i++) step[i] = 1, NxtNode[i] = i + SP[i]; for(register int i = x;i &gt;= L;i--) updata(i);// for(register int i = 1;i &lt;= n;i++)// &#123;// printf(":%d : ", i);// printf("step = %d, ", step[i]);// printf("NxtNode = %d \n", NxtNode[i]);// &#125;// &#125; &#125; return 0;&#125;/*61 2 3 2 5 1*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3469 】【POI2008】BLO-Blockade]]></title>
    <url>%2F%E3%80%90luogu-3469-%E3%80%91%E3%80%90POI2008%E3%80%91BLO-Blockade%2F</url>
    <content type="text"><![CDATA[写在前面 这是一道剖析算法本质的题目 关于Tarjan Tarjan的本质就是一个DFS ——苟新杰老师 既然是DFS，那么在执行的过程中会形成一颗DFS树。 如果这个树点是一个割点，那么思考一下这个点的几个孩子是什么？ Tarjan过程中形成的DFS树，如果这个点是割点，那么这个点的孩子们就是删去这个点后断开的几部分。 为什么？ 假设这个点的孩子（子树）分别有SonTree1、SonTree2 和SonTree3。 SonTree1、SonTree2 和SonTree3不会属于一个强连通分量。 因为如果这些儿子属于一个强连通分量，那么在遍历第一个儿子(SonTree1)的时候，其他儿子(SonTree2 和SonTree3)一定能被便利到，而绝对不会成为当前点的子树。 关于本题 两种情况： 如果当前点不是割点，那么删去之后影响不大，只能导致当前被封锁的点到不了其他点，其他点也到不了当前被封锁的点。 如果当前点是割点，那么删去之后会断成几大块儿。对于每一块，到剩下的每一个不属于这一块儿的点都不能继续拜访，设这一块大小为SSS，总点数为nnn，那么这一块儿产生的不能拜访数为：Ans+=S×(n−s)Ans += S \times (n - s) Ans+=S×(n−s) 对每一块儿都要这么做。统计答案即可。注意：这个点上面的所有也是一块儿，大小计算方法与求树的重心类似。就是用总点数减去当前点为根的子树大小。 关于代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/*! * FileName: luogu-3469.cpp * This Problem is on luogu. The ID of the problem is 3469. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-13 08:29:07 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 110000;const int _M = 1010000 ;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_N];int tot = 0;struct edges&#123; int node; int nxt;&#125;edge[_M];void add(int u, int v)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v;&#125;int n, m;int dfn[_N];int low[_N];int dfnClock = 0; bool isCut[_N];int size[_N];int Ans[_N];void tarjan(int now, int fa)&#123; low[now] = dfn[now] = ++dfnClock; size[now] = 1; int child = 0; Ans[now] = 0; int SumForSon = 0; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dfn[exNode] == 0) &#123; child ++; tarjan(exNode, now); size[now] += size[exNode]; low[now] = min(low[now], low[exNode]); if(low[exNode] &gt;= dfn[now]) &#123; SumForSon += size[exNode]; Ans[now] += (size[exNode] * (n - size[exNode])); isCut[now] = true; &#125; &#125; else low[now] = min(low[now], dfn[exNode]); &#125; if(child &lt; 2 &amp;&amp; fa &lt; 0) isCut[now] = false; if(!isCut[now]) Ans[now] = (n - 1) &lt;&lt; 1; else Ans[now] += (n - SumForSon - 1) * (SumForSon + 1) + (n - 1);&#125;signed main()&#123; n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(); add(tmpx, tmpy); add(tmpy, tmpx); &#125; memset(isCut, false, sizeof(isCut)); tarjan(1, -1); for(register int i = 1;i &lt;= n;i++) printf("%lld\n", Ans[i]); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2341】【HAOI2006】受欢迎的牛]]></title>
    <url>%2F%E3%80%90luogu-2341%E3%80%91%E3%80%90HAOI2006%E3%80%91%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B%2F</url>
    <content type="text"><![CDATA[题目描述 每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶 牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜 欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你 算出有多少头奶牛可以当明星。 输入格式 第一行：两个用空格分开的整数：N和M 第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B 输出格式 第一行：单独一个整数，表示明星奶牛的数量 思路 如果存在环，那么环上的点相当于同一头牛。 缩点之后的判断即可 注意 关于本题判断是否合法。 我有两种判断方法： 12345if(outd[i] &gt; 1)//缩点完成之后，找到一个出度大于1的点，就GG&#123; puts("0"); return 0;&#125; 或者 判断出度为0的点的个数是否为1 第一种是错的，一开始我觉得当这张图是一条链，才合法。但是并不是，只要保证最后的结束点唯一即可，中间有多少曲折都没必要管，如图： 所以这种方法是错误的： 12345if(outd[i] &gt; 1)//缩点完成之后，找到一个出度大于1的点，就GG&#123; puts("0"); return 0;&#125; CODE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/*! * FileName: luogu-2341.cpp * This Problem is on luogu. The ID of the problem is 2341. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-08 21:41:00 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 11000;const int _M = 51000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int sccNo[_N];int sccCnt = 0;int dfn[_N];int low[_N];int dfsClock = 0;stack&lt;int&gt;S;int maxN = 0;int Val[_N];void tarjan(int now)&#123; maxN = max(maxN, dfn[now] = low[now] = ++ dfsClock); S.push(now); for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dfn[exNode] == 0) &#123; tarjan(exNode); low[now] = min(low[now], low[exNode]); &#125; else if(sccNo[exNode] == 0)&#123; low[now] = min(low[now], dfn[exNode]); &#125; &#125; if(low[now] == dfn[now]) &#123; ++ sccCnt; while(true) &#123; sccNo[S.top()] = sccCnt; if(S.top() == now) &#123; S.pop(); break; &#125; S.pop(); &#125; &#125;&#125;set&lt;pair&lt;int, int &gt; &gt; _S;//int ind[_N];int outd[_N]; int main()&#123; int root = 0; int n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(); root = tmpx; add(tmpx, tmpy); &#125; for(register int i = 1;i &lt;= n;i++) if(dfn[i] == 0) tarjan(i); for(register int i = 1;i &lt;= n;i++) &#123; for(register int j = head[i];j;j = edge[j].nxt) &#123; int exNode = edge[j].node; if(sccNo[i] != sccNo[exNode]) _S.insert(make_pair(sccNo[i], sccNo[exNode])); &#125; &#125; for(set&lt;pair&lt;int, int &gt; &gt; :: iterator i = _S.begin();i != _S.end();i++) outd[(*i).first]++; for(register int i = 1;i &lt;= n;i++) Val[sccNo[i]]++; int ans = 0; int isZero = 0; for(register int i = 1;i &lt;= sccCnt;i++) &#123;// if(outd[i] &gt; 1)// &#123;// puts("0");// return 0;// &#125; if(outd[i] == 0) &#123; isZero ++; ans = Val[i]; &#125; &#125; if(isZero == 1) printf("%d\n",ans); else puts("0"); return 0;&#125; 注意 那个那个，用set统计缩完点之后的边超级方便]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1993】小K的农场]]></title>
    <url>%2F%E3%80%90luogu-1993%E3%80%91%E5%B0%8FK%E7%9A%84%E5%86%9C%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[差分约束系统 由nnn个变量X1,X2,X3….XnX_1, X_2, X_3 …. X_nX1​,X2​,X3​….Xn​和mmm个未知条件组成的nnn元一次不等式组， 其中，每个条件都形如Xi≤Xj+WkX_i \le X_j + W_kXi​≤Xj​+Wk​ 我们的问题是：如果有解给出一组满足所有条件的解，否则判断出无解 注意到，Xi≤Xj+WkX_i \le X_j + W_kXi​≤Xj​+Wk​与单源最短路中的三角不等式很相似。 建立nnn个节点对应nnn个变量。 对于每组条件，从XjX_jXj​向XiX_iXi​连一条权值为WkW_kWk​单向边。 同时虚构节点并向每一个节点连一条边，如果存在负环则无解。否则有解。 虚构节点到每个点的距离就是这个点的解 注意事项 需要注意要将题目里面的不等式形式转化为Xi≤Xj+WkX_i \le X_j + W_kXi​≤Xj​+Wk​ 在判断是否存在解的问题中，使用DFS-SPFA速度较快，在寻找解的过程中BFS-SPFA 不管使用哪种SPFA三角形不等式时，等于时，不更新答案。即，第一个是对的，第二个是错的。 dist[now]+edge[i].w&lt;dist[exNode]dist[now] + edge[i].w &lt; dist[exNode]dist[now]+edge[i].w&lt;dist[exNode] dist[now]+edge[i].w≤dist[exNode]dist[now] + edge[i].w \le dist[exNode]dist[now]+edge[i].w≤dist[exNode] Codes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/*! * FileName: luogu-1993.cpp * This Problem is on luogu. The ID of the problem is 1993. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-05 11:02:51 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 135000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int head[_];struct edges&#123; int node; int w; int nxt;&#125;edge[_];int tot = 0;void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;int n, m;//bool inque[_];//queue&lt;int&gt;Q;//int dist[_];//int inQueTime[_];//bool SPFA(int s)//&#123;// memset(dist, 0x3f, sizeof(dist));// dist[s] = 0;// Q.push(s);// inque[s] = true;// inQueTime[s] ++;// while(!Q.empty())// &#123;// int now = Q.front();// Q.pop();// inque[now] = false;// for(register int i = head[now];i;i = edge[i].nxt)// &#123;// int exNode = edge[i].node;// if(dist[now] + edge[i].w &lt; dist[exNode])// &#123;// dist[exNode] = dist[now] + edge[i].w;// if(!inque[exNode])// &#123;// Q.push(exNode);// inQueTime[exNode] ++;// if(inQueTime[exNode] &gt;= n) return false;// inque[exNode] = true;// &#125;// &#125;// &#125;// &#125;// return true;//&#125;int dist[_];bool InStack[_];bool SPFA(int now)&#123; InStack[now] = true; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(dist[now] + edge[i].w &lt; dist[exNode])/////////SPFA 对&lt;=敏感 &#123; dist[exNode] = dist[now] + edge[i].w; if(InStack[exNode]) return false; if(!SPFA(exNode)) return false; &#125; &#125; InStack[now] = false; return true;&#125;int main()&#123; n = read(); m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int opt = read(); int a, b, c; if(opt == 1) &#123; a = read(); b = read(); c = read(); add(a, b, -c); &#125; if(opt == 2) &#123; a = read(); b = read(); c = read(); add(b, a, c); &#125; if(opt == 3) &#123; a = read(); b = read(); add(a, b, 0); add(b, a, 0); &#125; &#125; int root = n + 1; for(register int i = 1;i &lt;= n;i++) add(root, i, 0); n++; memset(InStack, false, sizeof(InStack)); memset(dist, 0x3f, sizeof(dist)); dist[root] = 0; bool ans = SPFA(root); puts(ans ? "Yes" : "No"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1967】【NOIP2013】货车运输]]></title>
    <url>%2F%E3%80%90luogu-1967%E3%80%91%E3%80%90NOIP2013%E3%80%91%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%2F</url>
    <content type="text"><![CDATA[首先重新建图，构造出最大生成树，然后在最大生成树上求LCA来回答询问（倍增求树上路径上最小边权）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;#define inf 0x7fffffffusing namespace std;int n, m;const int _N = 10100;const int _M = 100100;const int _Lg = 20;inline int read()&#123; int x = 0; int sign = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') sign = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3); x += c - '0';c = getchar();&#125; return x * sign;&#125;struct __edges&#123; int u; int v; int w; bool operator &lt; (const __edges A) const &#123; return w &gt; A.w; &#125;&#125;E[_M];int f[_N];void init(int n)&#123; for(register int i = 1;i &lt;= n;i++) f[i] = i; &#125;int find(int x)&#123; return f[x] == x ? x : f[x] = find(f[x]); &#125;void marge(int x, int y)&#123; x = find(x); y = find(y);f[x] = y;&#125;bool ask(int x, int y)&#123; return find(x) == find(y); &#125;int head[_N];struct edges&#123; int node; int w; int nxt;&#125;edge[_M];int tot = 0;void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v; edge[tot].w = w;&#125;void MakeTree()&#123; for(register int i = 1;i &lt;= m;i++) if(!ask(E[i].u, E[i].v)) &#123; add(E[i].u, E[i].v, E[i].w); add(E[i].v, E[i].u, E[i].w); marge(E[i].u, E[i].v); &#125;&#125;int anc[_N][_Lg + 10];int Min[_N][_Lg + 10];int dep[_N];bool vis[_N];void dfs(int now, int fa, int deepth, int wToFa)&#123; if(vis[now]) return; vis[now] = true; dep[now] = deepth; anc[now][0] = fa; Min[now][0] = wToFa; for(register int i = head[now];i;i = edge[i].nxt) dfs(edge[i].node, now, deepth + 1, edge[i].w);&#125;int query(int x, int y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); int ans = inf; int Dis = (dep[x] - dep[y]); for(register int i = 0;Dis != 0;i ++, Dis &gt;&gt;= 1) if(Dis &amp; 1) ans = min(ans, Min[x][i]), x = anc[x][i]; if(x == y) return ans; for(register int i = _Lg;i &gt;= 0;i--) if(anc[x][i] != anc[y][i]) ans = min(ans, min(Min[x][i], Min[y][i])),x = anc[x][i], y = anc[y][i]; ans = min(ans, min(Min[x][0], Min[y][0])); return ans;&#125;int main()&#123; n = read(), m = read(); init(n); for(register int i = 1;i &lt;= m;i++) &#123; E[i].u = read(); E[i].v = read(); E[i].w = read(); &#125; sort(E + 1, E + 1 + m); MakeTree(); memset(vis, false, sizeof(vis)); for(register int i = 1;i &lt;= n;i++) if(!vis[i]) dfs(i, i, 1, 0); for(register int j = 1;j &lt;= _Lg;j++) for(register int i = 1;i &lt;= n;i++) anc[i][j] = anc[anc[i][j - 1]][j - 1]; for(register int j = 1;j &lt;= _Lg;j++) for(register int i = 1;i &lt;= n;i++) Min[i][j] = min(Min[i][j - 1], Min[anc[i][j - 1]][j - 1]); int Q = read(); while(Q--) &#123; int tmpu = read(), tmpv = read(); int ans; if(ask(tmpu, tmpv)) ans = query(tmpu, tmpv); else ans = -1; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3398】仓鼠找sugar]]></title>
    <url>%2F%E3%80%90luogu-3398%E3%80%91%E4%BB%93%E9%BC%A0%E6%89%BEsugar%2F</url>
    <content type="text"><![CDATA[这道题我服了 题意 询问树上aaa到bbb，ccc到ddd的两条路径是否相交。 做法 我们容易发现，如果相交，记x=lca(a,b)x=lca(a,b)x=lca(a,b)，y=lca(c,d)y=lca(c,d)y=lca(c,d)，则必有xxx在c−dc-dc−d路径上或yyy在a−ba-ba−b路径上。 对于判断在树上的一个点是否在一条路径(a,b)(a, b)(a,b)上有两种做法: 如果点kkk在路径(a,b)(a, b)(a,b)上，那么Deepthk≥DeepthLCA(a,b)Deepth_k \ge Deepth_{LCA(a, b)}Deepthk​≥DeepthLCA(a,b)​ 的情况下LCA(k,a)=kLCA(k, a) = kLCA(k,a)=k 或者 LCA(k,b)=kLCA(k, b) = kLCA(k,b)=k 如果点kkk在路径(a,b)(a, b)(a,b)上，那么dist(a,b)=dist(a,k)+dist(k,b)dist(a, b) = dist(a, k) + dist(k, b)dist(a,b)=dist(a,k)+dist(k,b) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/*! * FileName: luogu-3398.cpp * This Problem is on luogu. The ID of the problem is 3398. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-04 21:50:05 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 110000;const int Log = 20;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n;int q;struct edges&#123; int node; int nxt;&#125;edge[_ &lt;&lt; 1];int head[_];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int fa[_][Log + 10];int dep[_];bool vis[_];void dfs(int now, int father)&#123; vis[now] = true; fa[now][0] = father; dep[now] = dep[father] + 1; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(vis[exNode]) continue; dfs(exNode, now); &#125;&#125;void InitFor()&#123; for(register int j = 1;j &lt; Log;j++) for(register int i = 1;i &lt;= n;i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];&#125;int Query(int x, int y)&#123; if(dep[x] &lt; dep[y]) swap(x, y); int len = dep[x] - dep[y]; for(register int step = 0;len != 0;step ++) &#123; if(len &amp; 1) x = fa[x][step]; len &gt;&gt;= 1; &#125; if(x == y) return x; for(register int i = Log;i &gt;= 0;i--) if(fa[x][i] != fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; return fa[x][0];&#125;int main()&#123; n = read();q = read(); int root = 0; for(register int i = 1;i &lt; n;i++) &#123; int tmpx = read(), tmpy = read(); root = tmpx; add(tmpx, tmpy); add(tmpy, tmpx); &#125; dfs(root, 0); InitFor(); for(register int i = 1;i &lt;= q;i++) &#123; int a = read(); int b = read(); int c = read(); int d = read(); int LCA1 = Query(a, b); int LCA2 = Query(c, d); if( (dep[LCA1] &gt;= dep[Query(c, d)] &amp;&amp; (Query(LCA1, c) == LCA1 || Query(LCA1, d) == LCA1)) || (dep[LCA2] &gt;= dep[Query(a, b)] &amp;&amp; (Query(LCA2, a) == LCA2 || Query(LCA2, b) == LCA2)) ) puts("Y"); else puts("N"); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1352】没有上司的舞会]]></title>
    <url>%2F%E3%80%90luogu-1352%E3%80%91%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[树形DP 存在负点权，无法使用二分图染色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*! * FileName: luogu-1352.cpp * This Problem is on luogu. The ID of the problem is 1352. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-04 10:35:04 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 6100;//const int _M = inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int node; int nxt;&#125;edge[_];int head[_];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int n;int V[_];bool isNotMaster[_];int dp[_][2];void dfs(int now)&#123;// printf("now at %d\n", now); dp[now][1] = V[now]; dp[now][0] = 0; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; dfs(exNode); dp[now][0] += max(dp[exNode][1], dp[exNode][0]); dp[now][1] += dp[exNode][0]; &#125; return ;&#125; int main()&#123; n = read(); for(register int i = 1;i &lt;= n;i++) V[i] = read(); for(register int i = 1;i &lt; n;i++) &#123; int tmpx = read(), tmpy = read(); add(tmpy, tmpx); isNotMaster[tmpx] = true; &#125; int rot = 0; for(register int i = 1;i &lt;= n;i++) if(!isNotMaster[i]) &#123; rot = i; break; &#125; dfs(rot); printf("%d\n", max(dp[rot][0], dp[rot][1])); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3384】【模板】树链剖分]]></title>
    <url>%2F%E3%80%90luogu-3384%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define inf 0x7fffffffusing namespace std;const int _N = 2e5 + 100;const int _M = 2e5 + 100;int MOD;inline int read()&#123; int x = 0; int sign = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') sign = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3); x += c - '0';c = getchar();&#125; return x * sign;&#125;int NodeVal[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int head[_N];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; head[u] = tot; edge[tot].node = v;&#125;int fa[_N];int size[_N];int MaxSon[_N];int depth[_N];int _dfsClock = 0;int top[_N];int dfn[_N];int _rank[_N];void dfsinit(int now, int F)&#123; fa[now] = F; size[now] = 1; MaxSon[now] = 0; int nowMax = -inf; depth[now] = depth[F] + 1; for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(exNode == F) continue; dfsinit(exNode, now); size[now] += size[exNode]; if(nowMax &lt; size[exNode]) &#123; nowMax = size[exNode]; MaxSon[now] = exNode; &#125; &#125;&#125;void Dfs_Lct(int now, int Top)&#123; top[now] = Top; dfn[now] = ++_dfsClock; _rank[_dfsClock] = now; if(MaxSon[now] == 0) return; Dfs_Lct(MaxSon[now], Top); for(register int i = head[now];i;i = edge[i].nxt) &#123; int exNode = edge[i].node; if(exNode != MaxSon[now] &amp;&amp; exNode != fa[now]) Dfs_Lct(exNode, exNode); &#125; &#125;int Vall[_N];struct Node&#123; int sum; int tar; Node *lson, * rson; Node()&#123; sum = tar = 0;lson = rson = NULL; &#125; Node(int v)&#123;sum = v; tar = 0; lson = rson = NULL; &#125; void updata() &#123; sum = (lson -&gt; sum + rson -&gt; sum ) % MOD; &#125;&#125;*null;void build(Node *o, int l, int r)&#123; if(l == r) &#123; o -&gt; sum = NodeVal[_rank[l]] % MOD; o -&gt; lson = null; o -&gt; rson = null; return; &#125; int mid = (l + r) &gt;&gt; 1; o -&gt; lson = new Node(0); o -&gt; rson = new Node(0); build(o -&gt; lson, l, mid); build(o -&gt; rson, mid + 1, r); o -&gt; updata();&#125;void tar(Node *o, int l,int r,int v)&#123; if(o == NULL) return; o -&gt; sum += ((r - l + 1) * 1LL * v) % MOD; o -&gt; sum %= MOD; o -&gt; tar += v; o -&gt; tar %= MOD;&#125;void push(Node *o, int l, int r)&#123; int mid = (l + r) &gt;&gt; 1; if(o -&gt; tar == 0) return; tar(o -&gt; lson, l, mid, o -&gt; tar); tar(o -&gt; rson, mid + 1, r, o -&gt; tar % MOD); o -&gt; tar = 0;&#125;int query(Node *o, int nowl, int nowr, int l, int r)&#123; if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return o -&gt; sum; push(o, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; int ans = 0; if(l &lt;= mid) ans = (ans + query(o -&gt; lson, nowl, mid, l, r)) % MOD; if(r &gt; mid) ans = (ans + query(o -&gt; rson, mid + 1, nowr, l, r)) % MOD; return ans;&#125;void change(Node *o, int nowl, int nowr, int l, int r, int v)&#123; if(l &lt;= nowl &amp;&amp; nowr &lt;= r) &#123; tar(o, nowl, nowr, v); return ; &#125; push(o, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(o -&gt; lson, nowl, mid, l, r, v); if(r &gt; mid) change(o -&gt; rson, mid + 1, nowr, l, r, v); o -&gt; updata();&#125;void AddOnPath(Node *root, int L, int A, int B, int Val)&#123; while(top[A] != top[B]) &#123; if(depth[top[A]] &gt; depth[top[B]]) swap(A, B); change(root, 1, L, dfn[top[B]], dfn[B], Val); B = fa[top[B]]; &#125; change(root, 1, L, min(dfn[A], dfn[B]), max(dfn[A], dfn[B]), Val);&#125;int GetOnPath(Node *root, int L, int A, int B)&#123; int ans = 0; while(top[A] != top[B]) &#123; if(depth[top[A]] &gt; depth[top[B]]) swap(A, B); ans += query(root, 1, L, dfn[top[B]], dfn[B]); ans %= MOD; B = fa[top[B]]; &#125; ans += query(root, 1, L, min(dfn[A], dfn[B]), max(dfn[A], dfn[B])); ans %= MOD; return ans;&#125;inline void AddOnSub(Node * root, int L, int now, int V)&#123; change(root, 1, L, dfn[now], dfn[now] + size[now] - 1, V);&#125;inline int GetOnSub(Node *root, int L, int now)&#123; return query(root, 1, L, dfn[now], dfn[now] + size[now] - 1);&#125;int main()&#123; int n = read(); int m = read(), r = read(), p = read();MOD = p; for(register int i = 1;i &lt;= n;i ++) NodeVal[i] = read(); for(register int i = 1;i &lt; n;i++) &#123; int tmpx = read(), tmpy = read(); add(tmpx, tmpy); add(tmpy, tmpx); &#125; dfsinit(r, r); Dfs_Lct(r, r); Node *root = new Node(0); null = new Node(0); build(root, 1, n); for(register int i = 1;i &lt;= m;i++) &#123; int opt = read(); int A, B, Val, R; switch(opt) &#123; case 1 : A = read(), B = read(), Val = read()%MOD; AddOnPath(root, n, A, B, Val); break; case 2 : A = read(), B = read(); printf("%d\n", GetOnPath(root, n, A, B) % MOD); break; case 3 : R = read(), Val = read() % MOD; AddOnSub(root, n, R, Val); break; case 4 : R = read(); printf("%d\n", GetOnSub(root, n, R) % MOD); break; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-P3037】【USACO11DEC】简化的农场Simplifying the Farm]]></title>
    <url>%2F%E3%80%90luogu-P3037%E3%80%91%E3%80%90USACO11DEC%E3%80%91%E7%AE%80%E5%8C%96%E7%9A%84%E5%86%9C%E5%9C%BASimplifying-the-Farm%2F</url>
    <content type="text"><![CDATA[思路 如果没有边权相同的边，那么其实时不存在多种最小生成树的方案的。 题目中同一边权的个数不超过三个 按照Kruskal的建树流程进行模拟。 边权排完序后，边权相同的会聚到一起，然后在从小到大枚举的时候分类讨论即可。 流程 首先找到边权相同到的几条边。 这是我们需要在这些边中选出有用边。 所谓有用边就是加入其中一条边，不会产生环。因为之前已经加入的边是不能再反悔的，所以如果当前等待加入的边与之前的边存在矛盾的话，当前边一定是无用的。 如下图，下图的橙色边就是无用边： 然后我们考虑哪些情况会使最小生成树方案增加： 如过当前权值有两条边相同： 就有这两种情况： 对于第一种情况，这两条边只能同时加入其中任意一条，这样就有两种建树方案。 对于第二种情况，这两条边没有选择余地，必须都加入。 如过当前权值有三条边相同： 以下三种情况能产生多种建树方案： 这三种情况分别产生333（选其中一条不加入），222（选重复的两条中的一条），333（选三条中的任意一条）种生成树方案。 代码 使用set帮助区分三条边权相同时，第一种情况和第二种情况。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/*! * FileName: luogu-3037.cpp * This Problem is on luogu. The ID of the problem is 3037. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-03 22:47:58 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _M = 1e5 + 100;const int _N = 4e4 + 100;const int MOD = 1000000007;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int u; int v; int w; bool operator &lt; (const edges &amp; A) const &#123; return w &lt; A.w; &#125;&#125;E[_M];int n, m;//Kruskal 所用的并查集 Startint f[_N];int find(int x)&#123; return f[x] == x ? x : f[x] = find(f[x]); &#125;void initForSet()&#123; for(register int i = 1;i &lt;= n;i++) f[i] = i;&#125;void marge(int x, int y)&#123; x = find(x); y = find(y); if(x == y) return; f[x] = y;&#125;bool ask(int x, int y)&#123; return find(x) == find(y);&#125;//Kruskal 所用的并查集 Endint nxtIt(int now)//往下找最后一个边权相同的位置&#123; for(register int i = now;i &lt;= m;i++) if(E[now].w != E[i].w) return i - 1; return m;&#125;set &lt;pair&lt;int , int &gt; &gt; S;//int main()&#123; n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; E[i].u = read(); E[i].v = read(); E[i].w = read(); &#125; initForSet(); sort(E + 1, E + 1 + m); int ans1 = 0; int ans2 = 1; int nxt; for(register int i = 1;i &lt;= m;) &#123; S.clear(); nxt = nxtIt(i); int totEdge = 0; for(register int j = i;j &lt;= nxt;j++) if(!ask(E[j].u, E[j].v)) &#123; totEdge ++; int k1 = min(find(E[j].u), find(E[j].v)); int k2 = max(find(E[j].u), find(E[j].v)); S.insert(make_pair(k1, k2)); &#125; int totAdd = 0; for(register int j = i;j &lt;= nxt;j++) &#123; if(!ask(E[j].u, E[j].v)) &#123; marge(E[j].u, E[j].v); totAdd ++; ans1 = (ans1 + E[j].w) % MOD; &#125; &#125; if(totAdd == 1) ans2 = ans2 * 1LL * totEdge % MOD;//分别是两条边权相同时的第一种情况 和 三条边权相同时的第三种情况。 if(totAdd == 2 &amp;&amp; totEdge == 3) &#123; if(S.size() == 3) ans2 = ans2 * 3LL % MOD;//三条边权相同时的第一种情况 if(S.size() == 2) ans2 = ans2 * 2LL % MOD; //三条边权相同时的第二种情况 &#125; i = nxt + 1; &#125; printf("%d %d\n", ans1 % MOD, ans2 % MOD); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-UVA10366】【uva-10366】龙头滴水 Faucet Flow]]></title>
    <url>%2F%E3%80%90luogu-UVA10366%E3%80%91%E3%80%90uva-10366%E3%80%91%E9%BE%99%E5%A4%B4%E6%BB%B4%E6%B0%B4-Faucet-Flow%2F</url>
    <content type="text"><![CDATA[最初的想法 看到这道题给人的第一感觉是模拟。 我们来模拟一下 然后水往右边流 更快的方法 我们来模拟一个更复杂的情况 这里开始加水 我们发现一些柱子完全可以删掉，每次跳到有用的柱子之间后，水量可以直接计算出来。设HiH_iHi​为柱子iii高度，LLL，RRR代表已经有水的区间。 Ans=(R−L)∗min(HL,HR)Ans = (R - L) * min(H_L, H_R) Ans=(R−L)∗min(HL​,HR​) 好，现在我们的优化算法大体就是这样的流程： 从加水的位置开始，从那边开始溢水（即哪边柱子的高度小），就往后扩展哪边，去找下一个“有用柱子”。 扩展有水的范围后，更新答案。 重复以上两步 看图解： 我们用两个变量记录当前水已经覆盖的地方 右边低，水先往右边流 往右边第一个比当前右柱子高的（第一个能挡住水的）柱子就是下一个 继续 右边低，水先往右边流 往右边的下一个柱子比当前右柱子低，这个柱子是无用的，跳过。 这时，有用柱子已经找完了。 我们发现现在中间是一个完整的矩形。 这时水会继续往低的那一端流出去，这时仔细想想，水最后会流成阶梯状。 处理这里比较复杂，我们换张图。 这样的话，仔细观察会发现，其实还是找有用的柱子。但是这次是从最左边开始往右找有用柱子（第一个比它高的柱子）（橙色的） 设iii为第iii个柱子，nextnextnext为下一个有用柱子 Ans+=(next−i)∗HiAns += (next - i) * H_i Ans+=(next−i)∗Hi​ 计算阶梯是从最两端的柱子开始往中间找有用柱子，计算&quot;大矩形的时候&quot;是从开始区间的柱子往外开始找有用柱子。为什么呢？因为，这两种柱子，都能确定一定会限制水面高度。 特殊情况 这道题最难处理的就是柱子相等的问题，因为水会同时往两边流。 分两种情况： 如果这两个柱子都能继续往各自的方向拓展，同时拓展即可 如果两柱子都无法继续拓展，也就是将在当前大矩形两边形成“阶梯状”。找这两边的阶梯中的小的那个乘222加入答案即可（乘222是因为如果水往两边同时流，要形成一个阶梯，需要花费两倍的时间），因为越小，代表越早流出边界。 如果两柱子中只有一边无法继续拓展，注意这里不能直接乘222计入答案。 以左边无法拓展，开始形成阶梯为例： （底下的数字为柱子高度） 这时开始同时往两边溢水 这样其实就已经不再往右边溢水，继续全部往左边溢水了。 这样的话，对答案的贡献就是 Ans += min(向左边形成阶梯的花费 * 2, 向左边形成阶梯的花费 + 往右边溢出的水) 这样统计答案即可。 代码 题目给出的位置不好处理， 我把各各柱子都编号成1−n1 - n1−n 然后再换算一下起始区间。 一些变量 nowl和nowr表示当前被水覆盖的区间是[nowl, nowr] n表示柱子个数，高度分别存在H[1] ~ H[n] ans为答案，因为每个柱子之间间隔是222，所以最后答案需要乘222 一些函数 QueryToR和QueryToL分别是往右、左形成阶梯状的时间 GetNxt_R和GetNxt_L这里是往右、左找有用柱子，第二个bool变量是为了告诉函数，等于的情况算不算。在不同情况下是不一样的，请自己想一想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*! * FileName: uva-10366.cpp * This Problem is on uva. The ID of the problem is 10366. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool on 2019-08-01 20:57:59 written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1e4 + 100;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int tmpL, tmpR;int n;int H[_];inline int GetNxt_L(int now, bool isSame)&#123; for(register int i = now - 1;i &gt;= 0;i--) if(H[i] &gt; H[now] || (H[i] == H[now] &amp;&amp; isSame)) return i; return 0;&#125;inline int GetNxt_R(int now, bool isSame)&#123; for(register int i = now + 1;i &lt;= n + 1;i++) if(H[i] &gt; H[now] || (H[i] == H[now] &amp;&amp; isSame)) return i; return n + 1;&#125;inline int QueryToL(int L, int R)&#123; int ans = 0; for(register int i = L;i &lt;= R;i = GetNxt_R(i, true)) ans += H[i] * (GetNxt_R(i, true) - i); return ans; &#125;inline int QueryToR(int L, int R)&#123; int ans = 0; for(register int i = R;i &gt;= L;i = GetNxt_L(i, true)) ans += H[i] * (i - GetNxt_L(i, true)); return ans;&#125;void doit()&#123; n = ((abs(tmpL) + abs(tmpR)) &gt;&gt; 1) + 1; for(register int i = 1;i &lt;= n;i++) H[i] = read(); H[0] = H[n + 1] = inf; int nowl = ((abs(tmpL) + 1) &gt;&gt; 1); int nowr = nowl + 1; int ans = min(H[nowl], H[nowr]); while(true) &#123; int nxtL = GetNxt_L(nowl, false); int nxtR = GetNxt_R(nowr, false); if(nxtL == 0 || nxtR == n + 1)//NxtL == 0就代表往左已经找不到有用柱子了。NxtR == n + 1就代表往右已经找不到有用柱子了 &#123; bool flag = false;//是否更新成功标记。 if(nxtL == 0 &amp;&amp; nxtR == n + 1) flag = true, ans += (H[nowl] == H[nowr] ? min(QueryToL(1, nowl - 1) &lt;&lt; 1 , QueryToR(nowr + 1, n) &lt;&lt; 1) : (H[nowl] &lt; H[nowr] ? QueryToL(1, nowl - 1) : QueryToR(nowr + 1, n)));//请仔细查看这里，这里是处理柱子相同和不相同的情况。（第一个特殊情况） if(nxtL == 0 &amp;&amp; nxtR != n + 1 &amp;&amp; H[nowl] &lt;= H[nowr])//如果左边找不到有用柱子，且水的确要往左边流 flag = true, ans += QueryToL(1, nowl - 1) + (H[nowl] == H[nowr] ? min(QueryToL(1, nowl - 1), (nxtR - nowr) * H[nowr]) : 0);//这里是处理第二个特殊情况 if(nxtL != 0 &amp;&amp; nxtR == n + 1 &amp;&amp; H[nowl] &gt;= H[nowr])//如果右边找不到有用柱子，且水的确要往右边流 flag = true, ans += QueryToR(nowr + 1, n) + (H[nowl] == H[nowr] ? min(QueryToR(nowr + 1, n), (nowl - nxtL) * H[nowl]) : 0);//这里是处理第三个特殊情况 if(flag) break; &#125; int ToVal_L = (H[nowl] &lt;= H[nowr] ? nxtL : nowl); int ToVal_R = (H[nowl] &gt;= H[nowr] ? nxtR : nowr); //这种写法，区间两边高度相等的情况时，两边都能完成拓展。 nowl = ToVal_L; nowr = ToVal_R; ans = (nowr - nowl) * min(H[nowl], H[nowr]); &#125; printf("%d\n", ans &lt;&lt; 1); return ;&#125;int main()&#123; while(scanf("%d%d", &amp;tmpL, &amp;tmpR) == 2 &amp;&amp; tmpL != 0 &amp;&amp; tmpR != 0) doit(); return 0;&#125; 唔~ 写了好长。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【poj-2777】Count Color]]></title>
    <url>%2F%E3%80%90poj-2777%E3%80%91Count-Color%2F</url>
    <content type="text"><![CDATA[【poj-2777】Count Color 原题 题目描述 选择问题解决和程序设计作为选修课程，您需要解决各种问题。 在这里，我们遇到了一个新问题。 有一个很长的板长LLL厘米,LLL是一个正整数，所以我们可以将板均分为LLL段，从左到右标记为1,2，......L1,2，...... L1,2，......L，每个为111厘米 长。 现在我们必须给电路板上色 - 只有一种颜色的一个部分。 我们可以在董事会上进行以下两项操作： “C A B C”使用颜色CCC将电路板从AAA段到BBB段着色。 “P A B”输出段AAA和段BBB（包括）之间绘制的不同颜色的数量。 在我们的日常生活中，我们用很少的词来描述颜色（红色，绿色，蓝色，黄色…），因此您可以假设不同颜色T的总数非常小。 为了简单起见，我们将颜色的名称表示为颜色111，颜色222，…颜色TTT.开始时，板上涂有颜色111.现在剩下的问题留给你了。 输入描述 第一行输入包含L（1&lt;=L&lt;=100000）L（1 &lt;= L &lt;= 100000）L（1&lt;=L&lt;=100000），T（1&lt;=T&lt;=30）T（1 &lt;= T &lt;= 30）T（1&lt;=T&lt;=30）和O（1&lt;=O&lt;=100000）O（1 &lt;= O &lt;= 100000）O（1&lt;=O&lt;=100000）。 这里OOO表示操作次数。 在OOO行之后，每个包含“C A B C”或“P A B”（这里A，B，CA，B，CA，B，C是整数，AAA可以大于BBB）作为先前定义的操作。 输出描述 输出操作的输出结果按顺序，每行包含一个数字。 做法 显然是使用线段树，但是对于求区间互异元素个数来说，有一定难度。 TTT很小，只有303030，并且只有两种状态 考虑使用二进制 一个intintint有323232位，能存下所有信息， 合并节点信息的时候只需要将两节点存储的颜色信息按位或即可。 真·好强啊~~~~ Codes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;inline int read()&#123; int x = 0; int sign = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9')&#123; if(c == '-') sign = -1;c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0')&#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3);x += c - '0' ;c = getchar();&#125; return x * sign;&#125;void printBin(int v)&#123; printf("%d: ", v); bool S[40];int tot = 0; while(v != 0) &#123; S[++tot] = (v &amp; 1); v &gt;&gt;= 1; &#125; for(register int i = tot;i &gt;= 1;i --) printf("%d%c", S[i], ' '); putchar('\n');&#125;inline int GetNum(int v)&#123; int ans = 0; while(v != 0) &#123; ans += (v &amp; 1); v &gt;&gt;= 1; &#125; return ans;&#125;inline int GetColor(int v) &#123; return (1 &lt;&lt; (v - 1)); &#125;inline char readOpt()&#123; char c = getchar(); while(c != 'C' &amp;&amp; c != 'P') c = getchar(); return c;&#125;int L, T, O;struct Node&#123; int color; Node *lson, *rson; int tar; inline void maintain() &#123; color = lson -&gt; color | rson -&gt; color;&#125; Node()&#123;color = 1;lson = rson = NULL; tar = 0;&#125;&#125;*null;void build(Node *o, int l, int r)&#123; if(l == r) &#123; o -&gt; lson = o -&gt; rson = null; return ; &#125; int mid = (l + r) &gt;&gt; 1; o -&gt; lson = new Node(); o -&gt; rson = new Node(); build(o -&gt; lson, l, mid); build(o -&gt; rson, mid + 1, r); o -&gt; maintain();&#125;void tar(Node *o, int v)&#123; o -&gt; color = v; o -&gt; tar = v;&#125;void push(Node *o)&#123; if(o -&gt; tar == 0) return; tar(o -&gt; lson, o -&gt; tar); tar(o -&gt; rson, o -&gt; tar); o -&gt; tar = 0;&#125;void change(Node *o, int nowl, int nowr, int l , int r, int v)&#123;// printf("Now at [%d, %d] color: \n", nowl, nowr);// printBin(o -&gt; color); if(l &lt;= nowl &amp;&amp; nowr &lt;= r) &#123; tar(o, v); return; &#125; push(o); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(o -&gt; lson, nowl, mid, l, r, v); if(r &gt; mid) change(o -&gt; rson, mid + 1, nowr, l, r, v); o -&gt; maintain();&#125;int query(Node *o, int nowl, int nowr, int l, int r)&#123; if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return o -&gt; color; int mid = (nowl + nowr) &gt;&gt; 1; push(o); int ans = 0; if(l &lt;= mid) ans |= query(o -&gt; lson, nowl, mid, l, r); if(r &gt; mid) ans |= query(o -&gt; rson, mid + 1, nowr, l, r); return ans;&#125;int main()&#123;// freopen("test.in.txt", "r", stdin); //for(;;)printBin(read()); L = read(), T = read(), O = read(); null = new Node(); Node *root = new Node(); build(root, 1, L); while(O--) &#123; char opt = readOpt(); if(opt == 'C') &#123; int Lq = read(), Rq = read(), Val = read();// puts("change By");// printBin(GetColor(Val)); if(Lq &gt; Rq) swap(Lq, Rq); change(root, 1, L, Lq, Rq, GetColor(Val)); &#125; else &#123; int Lq = read(), Rq = read(); if(Lq &gt; Rq) swap(Lq, Rq); printf("%d\n", GetNum(query(root, 1, L, Lq, Rq))); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3374】【模板】树状数组 1]]></title>
    <url>%2F%E3%80%90luogu-3374%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-1%2F</url>
    <content type="text"><![CDATA[关于树状数组 转载自Small_Orange_five的树状数组彻底入门，算法小白都看得懂的超详细解析 再此对本数据结构的作者和本博文原作者表示由衷的敬意 导入 树状数组 重点是在树状的数组 大家都知道二叉树吧 叶子结点代表AAA数组 [A1,A8][A_1,A_8][A1​,A8​] 现在变形一下 CiC_iCi​代表 子树的叶子结点的权值之和 这里以求和举例 如图可以知道 C1=A1C_1=A_1C1​=A1​ C2=A1+A2;C_2=A_1+A_2;C2​=A1​+A2​; C3=A3;C_3=A_3;C3​=A3​; C4=A1+A2+A3+A4;C_4=A_1+A_2+A_3+A_4;C4​=A1​+A2​+A3​+A4​; C5=A5;C_5=A_5;C5​=A5​; C6=A5+A6;C_6=A_5+A_6;C6​=A5​+A6​; C7=A7;C_7=A_7;C7​=A7​; C8=A1+A2+A3+A4+A5+A6+A7+A8;C_8=A_1+A_2+A_3+A_4+A_5+A_6+A_7+A_8;C8​=A1​+A2​+A3​+A4​+A5​+A6​+A7​+A8​; 下面观察如下图 将C[]数组的结点序号转化为二进制 1=(001)1=(001)1=(001) C[1]=A[1];C[1]=A[1];C[1]=A[1]; 2=(010)2=(010)2=(010) C[2]=A[1]+A[2];C[2]=A[1]+A[2];C[2]=A[1]+A[2]; 3=(011)3=(011)3=(011) C[3]=A[3];C[3]=A[3];C[3]=A[3]; 4=(100)4=(100)4=(100) C[4]=A[1]+A[2]+A[3]+A[4];C[4]=A[1]+A[2]+A[3]+A[4];C[4]=A[1]+A[2]+A[3]+A[4]; 5=(101)5=(101)5=(101) C[5]=A[5];C[5]=A[5];C[5]=A[5]; 6=(110)6=(110)6=(110) C[6]=A[5]+A[6];C[6]=A[5]+A[6];C[6]=A[5]+A[6]; 7=(111)7=(111)7=(111) C[7]=A[7];C[7]=A[7];C[7]=A[7]; 8=(1000)8=(1000)8=(1000) C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8]; 对照式子可以发现 $ C[i]=A[i-2k+1]+A[i-2k+2]+…A[i];$ （k为i的二进制中从最低位到高位连续零的长度）例如i=8i=8i=8时，k=3k=3k=3; 可以自行带入验证; lowbit(x) lowbit(x)lowbit(x)lowbit(x) 其实就是取出x的最低位111 换言之 lowbit(x)=2klowbit(x)=2^klowbit(x)=2k kkk的含义与上面相同 理解一下 下面说代码 12345678910int lowbit(int t)&#123; return t&amp;(-t);&#125;//-t 代表t的负数 计算机中负数使用对应的正数的补码来表示//例如 :// t=6（0110） 此时 k=1//-t=-6=(1001+1)=(1010)// t&amp;(-t)=(0010)=2=2^1 C[i]=A[i−2k+1]+A[i−2k+2]+......A[i];C[i]=A[i-2^k+1]+A[i-2^k+2]+......A[i];C[i]=A[i−2k+1]+A[i−2k+2]+......A[i]; C[i]=A[i−lowbit(i)+1]+A[i−lowbit(i)+2]+......A[i];C[i]=A[i-lowbit(i)+1]+A[i-lowbit(i)+2]+......A[i];C[i]=A[i−lowbit(i)+1]+A[i−lowbit(i)+2]+......A[i]; 区间查询 ok 下面利用C[i]C[i]C[i]数组，求A数组中前i项的和 举个例子 i=7i=7i=7; sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7];sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7] ;sum[7]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]; 前i项和 C[4]=A[1]+A[2]+A[3]+A[4];C[6]=A[5]+A[6];C[7]=A[7];C[4]=A[1]+A[2]+A[3]+A[4]; C[6]=A[5]+A[6]; C[7]=A[7];C[4]=A[1]+A[2]+A[3]+A[4];C[6]=A[5]+A[6];C[7]=A[7]; 可以推出: sum[7]=C[4]+C[6]+C[7];sum[7]=C[4]+C[6]+C[7];sum[7]=C[4]+C[6]+C[7]; 序号写为二进制: sum[(111)]=C[(100)]+C[(110)]+C[(111)];sum[(111)]=C[(100)]+C[(110)]+C[(111)];sum[(111)]=C[(100)]+C[(110)]+C[(111)]; 再举个例子 i=5i=5i=5 sum[5]=A[1]+A[2]+A[3]+A[4]+A[5];sum[5]=A[1]+A[2]+A[3]+A[4]+A[5] ;sum[5]=A[1]+A[2]+A[3]+A[4]+A[5]; 前i项和 C[4]=A[1]+A[2]+A[3]+A[4];C[5]=A[5];C[4]=A[1]+A[2]+A[3]+A[4]; C[5]=A[5];C[4]=A[1]+A[2]+A[3]+A[4];C[5]=A[5]; 可以推出: sum[5]=C[4]+C[5];sum[5]=C[4]+C[5];sum[5]=C[4]+C[5]; 序号写为二进制: sum[(101)]=C[(100)]+C[(101)];sum[(101)]=C[(100)]+C[(101)];sum[(101)]=C[(100)]+C[(101)]; 细细观察二进制 树状数组追其根本就是二进制的应用 结合代码 1234567int getsum(int x)&#123;int ans=0;for(int i=x;i&gt;0;i-=lowbit(i))ans+=C[i];return ans；&#125; 对于$i=7 $进行演示 7(111)7(111)7(111) ans+=C[7]ans+=C[7]ans+=C[7] lowbit(7)=0017−lowbit(7)=6(110)ans+=C[6]lowbit(7)=001 7-lowbit(7)=6(110) ans+=C[6]lowbit(7)=0017−lowbit(7)=6(110)ans+=C[6] lowbit(6)=0106−lowbit(6)=4(100)ans+=C[4]lowbit(6)=010 6-lowbit(6)=4(100) ans+=C[4]lowbit(6)=0106−lowbit(6)=4(100)ans+=C[4] $lowbit(4)=100 4-lowbit(4)=0(000) $ 对于$i=5 $进行演示 5(101)5(101)5(101) ans+=C[5]ans+=C[5]ans+=C[5] lowbit(5)=0015−lowbit(5)=4(100)ans+=C[4]lowbit(5)=001 5-lowbit(5)=4(100) ans+=C[4]lowbit(5)=0015−lowbit(5)=4(100)ans+=C[4] lowbit(4)=1004−lowbit(4)=0(000)lowbit(4)=100 4-lowbit(4)=0(000)lowbit(4)=1004−lowbit(4)=0(000) 单点更新 当我们修改A[]A[]A[]数组中的某一个值时 应当如何更新C[]C[]C[]数组呢？ 回想一下 区间查询的过程，再看一下上文中列出的图 1234567void add(int x,int y)&#123; for(int i=x;i&lt;=n;i+=lowbit(i)) tree[i]+=y;&#125;//可以发现 更新过程是查询过程的逆过程//由叶子结点向上更新C[]数组 当更新A[1]A[1]A[1]时 需要向上更新C[1],C[2],C[4],C[8]C[1] ,C[2],C[4],C[8]C[1],C[2],C[4],C[8] C[1],C[2],C[4],C[8]C[1], C[2], C[4], C[8]C[1],C[2],C[4],C[8] 写为二进制 C[(001)],C[(010)],C[(100)],C[(1000)]C[(001)],C[(010)],C[(100)],C[(1000)]C[(001)],C[(010)],C[(100)],C[(1000)] 1(001)C[1]+=A[1]1(001) C[1]+=A[1]1(001)C[1]+=A[1] lowbit(1)=0011+lowbit(1)=2(010)C[2]+=A[1]lowbit(1)=001 1+lowbit(1)=2(010) C[2]+=A[1]lowbit(1)=0011+lowbit(1)=2(010)C[2]+=A[1] lowbit(2)=0102+lowbit(2)=4(100)C[4]+=A[1]lowbit(2)=010 2+lowbit(2)=4(100) C[4]+=A[1]lowbit(2)=0102+lowbit(2)=4(100)C[4]+=A[1] lowbit(4)=1004+lowbit(4)=8(1000)C[8]+=A[1]lowbit(4)=100 4+lowbit(4)=8(1000) C[8]+=A[1]lowbit(4)=1004+lowbit(4)=8(1000)C[8]+=A[1] 相关题目 http://poj.org/problem?id=2299 http://codeforces.com/contest/703/problem/D http://acm.zcmu.edu.cn/JudgeOnline/problem.php?cid=1270&amp;pid=3]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3387】【模板】缩点（DP）]]></title>
    <url>%2F%E3%80%90luogu-3387%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BC%A9%E7%82%B9%EF%BC%88DP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[【luogu-3387】【模板】缩点（DP） 【luogu-3387】【模板】缩点 这是一道模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*! * FileName: luogu-3387.cpp * This Problem is on luogu. The ID of the problem is 3387. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define inf 0x7fffffffusing namespace std;const int _N = 10010;const int _M = 100010;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int W[_N];struct edges&#123; int node; int nxt;&#125;edge[_M];int head[_N];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int n, m;int dfn[_N];int low[_N];int sccno[_N];int sccCnt = 0;int dfsCnt = 0;stack&lt;int&gt;S;void tarjan(int now)&#123; dfn[now] = low[now] = ++dfsCnt; S.push(now); for(register int i = head[now];i;i = edge[i].nxt) &#123; int node = edge[i].node; if(dfn[node] == 0) &#123; tarjan(node); low[now] = min(low[now], low[node]); &#125; else if(sccno[node] == 0) &#123; low[now] = min(low[now], dfn[node]); &#125; &#125; if(dfn[now] == low[now]) &#123; sccCnt ++; while(true) &#123; sccno[S.top()] = sccCnt; if(S.top() == now) &#123; S.pop();break; &#125; S.pop(); &#125; &#125;&#125;vector&lt;int&gt;G[_N];int val[_N];int sccNodeVal[_N];void findit(int now)&#123; val[now] = sccNodeVal[now];// printf("%d\n", now); int maxSon = 0; for(register int i = 0;i &lt; G[now].size();i++) &#123; int node = G[now][i]; if(node == now) continue; if(val[node] == 0) findit(node); maxSon = max(maxSon, val[node]); &#125; val[now] += maxSon;&#125;int main()&#123;// freopen("test.in.txt", "r", stdin); n = read(), m = read(); int s; for(register int i = 1;i &lt;= n;i++) W[i] = read(); for(register int i = 1;i &lt;= m;i++) add(s = read(), read()); for(register int i = 1;i &lt;= n;i++) if(dfn[i] == 0) tarjan(i);// for(register int i = 1;i &lt;= n;i++)// printf("Sccno[%d] = %d\n", i, sccno[i]);// puts("Ok"); for(register int i = 1;i &lt;= n;i++) for(int u = head[i];u;u = edge[u].nxt) G[sccno[i]].push_back(sccno[edge[u].node]);// puts("OK"); for(register int i = 1;i &lt;= n;i++) sccNodeVal[sccno[i]] += W[i];// puts("Ok"); for(register int i = 1;i &lt;= n;i++) if(val[sccno[i]] == 0) findit(sccno[i]); int maxAns = -inf; for(register int i = 1;i &lt;= n;i++) maxAns = max(maxAns, val[sccno[i]]); printf("%d", maxAns); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1522】 牛的旅行 Cow Tours]]></title>
    <url>%2F%E3%80%90luogu-1522%E3%80%91-%E7%89%9B%E7%9A%84%E6%97%85%E8%A1%8C-Cow-Tours%2F</url>
    <content type="text"><![CDATA[【luogu-1522】 牛的旅行 Cow Tours 原题 floyd挺好的。 坑点 保证精度符合题目要求 注意合并两条直径之后，距离不一定增大的问题，还需要使用每一个牧场的直径进行更新答案 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/*! * FileName: luogu-1886.cpp * This Problem is on luogu. The ID of the problem is 1886. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1e6 + 100;int A[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, k;struct AmazingQue&#123; int Que[_]; int head; int tail; AmazingQue()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &gt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q1;struct AmazingQue2&#123; int Que[_]; int head; int tail; AmazingQue2()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &lt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q2;int AnsA[_];int totA = 0;int main()&#123; n = read(), k = read(); for(register int i = 1;i &lt;= n;i++) A[i] = read(); for(register int i = 1;i &lt;= k;i++) Q1.push(A[i]); for(register int i = 1;i &lt;= k;i++) Q2.push(A[i]); for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q1.front()) == A[i - 1]) Q1.pop(); Q1.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); totA = 0; for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q2.front()) == A[i - 1]) Q2.pop(); Q2.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-5098】【USACO2004OPEN】Cave Cows 3 洞穴里的牛之三]]></title>
    <url>%2F%E3%80%90luogu-5098%E3%80%91%E3%80%90USACO2004OPEN%E3%80%91Cave-Cows-3-%E6%B4%9E%E7%A9%B4%E9%87%8C%E7%9A%84%E7%89%9B%E4%B9%8B%E4%B8%89%2F</url>
    <content type="text"><![CDATA[【luogu-5098】【USACO2004OPEN】Cave Cows 3 洞穴里的牛之三 原题 关于求曼哈夫距离的最大值，最小值存在一个O(n)O(n)O(n)做法。 见luogu日报 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*! * FileName: luogu-5098.cpp * This Problem is on luogu. The ID of the problem is 5098. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int main()&#123; int n = read(); int A1 = -inf, A2 = -inf, B1 = inf, B2 = inf; for(register int i = 1;i &lt;= n;i++) &#123; int tmpx = read(), tmpy = read(); A1 = max(A1, tmpx + tmpy); A2 = max(A2, tmpx - tmpy); B1 = min(B1, tmpx + tmpy); B2 = min(B2, tmpx - tmpy); &#125; printf("%d\n", max(A1 - B1, A2 - B2)); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1516】青蛙的约会]]></title>
    <url>%2F%E3%80%90luogu-1516%E3%80%91%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[青蛙的约会 原题 原题 今得青蛙两只，其一名为AAA， 另一名为BBB。 青蛙AAA从xxx开始跳，每次跳mmm米， 青蛙BBB从yyy开始跳，每次跳nnn米，两青蛙同时开始往同一方向跳，问跳几次可以跳到同一位置。（地球是圆得，周长是LLL） 如果不能跳到同一位置，就输出Impossible 分析 设一起跳KKK次能跳到同一位置。 x+mK≡y+nK(modL)x + mK \equiv y + nK \pmod L x+mK≡y+nK(modL) 移向得到 (x−y)+(m−n)K≡0(modL)\left ( x - y \right ) + \left ( m - n \right )K \equiv 0 \pmod L (x−y)+(m−n)K≡0(modL) 转换为欧几里得方程得到 (x−y)+(m−n)K+K′L=0\left ( x - y\right ) + (m - n)K + K&#x27;L = 0 (x−y)+(m−n)K+K′L=0 移向得到 (m−n)K+K′L=(y−x)(m - n)K + K&#x27;L = \left ( y - x\right ) (m−n)K+K′L=(y−x) (m−n)(m - n)(m−n)、(y−x)(y - x)(y−x)和LLL已经知道，拓展欧几里得求出一组KKK和K′K&#x27;K′即可 然后将KKK调整到最小正整数解。 关于不定方程从一组解得到其他解得过程： 设 d=gcd(a,b)d = gcd(a,b) d=gcd(a,b) d=ax+by=a(x+bd×t)+b(y−ad×t),t∈Zd = ax + by = a(x + \frac{b}{d} \times t) + b(y - \frac{a}{d} \times t) ,t \in \mathbb{Z} d=ax+by=a(x+db​×t)+b(y−da​×t),t∈Z 通过确定调整 ttt，即可调整一解到最小正整数解。 源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*! * FileName: luogu-1516.cpp * This Problem is on luogu. The ID of the problem is 1516. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define LL long longusing namespace std;const int _ = 233;inline LL read()&#123; char c = getchar(); LL sign = 1; LL x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;void exgcd(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;g)&#123; if(b == 0) &#123; g = a; x = 1;y = 0; &#125; else &#123;exgcd(b, a%b, x, y, g); int X = x; x = y; y = X - (a / b) * y;&#125;&#125;int main()&#123; LL x = read(), y = read(), m = read(), n = read(), L = read(), d, tx, ty;// exgcd(//, y, tx, ty, d);// cout&lt;&lt;tx&lt;&lt; ' '&lt;&lt; ty&lt;&lt;' '&lt;&lt;d&lt;&lt;endl; if(n &gt; m) swap(x, y), swap(m, n); exgcd(m - n, L, tx, ty, d); int k = (y - x) % d; if(k != 0) puts("Impossible"); else &#123; tx = (y - x) / d * tx;//调整方程`c`至gcd(a, b) printf("%lld", (tx % (L / d) + (L / d)) % (L / d)); &#125; return 0;&#125; tips 拓展欧几里得需要使a和b为正数，若 n &gt; m 时，交换两青蛙的信息。 对于调整到最小正整数解，例如得到一个解KKK，通过乘 ttt 倍的 ad\frac{a}{d}da​ 得到最小正整数解。只需要 K=((Kmodad)+ad)modadK = ((K mod \frac{a}{d} )+ \frac{a}{d})mod\frac{a}{d} K=((Kmodda​)+da​)modda​ 注意 longlonglong longlonglong。]]></content>
  </entry>
  <entry>
    <title><![CDATA[线性代数]]></title>
    <url>%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假INF - INF 第INF周计划]]></title>
    <url>%2F%E6%9A%91%E5%81%872019-7-1-2019-7-7%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[第三周计划 制定时间： 2019/6/30 执行时间： Inf Monday 学习Tarjan - 无向图相关 - 有向图强连通分量 习题 - 【luogu-3388】【模板】割点（割顶） - 【luogu-3387】【模板】缩点 - 【luogu-2341】【HAOI2006】受欢迎的牛 Tuesday 习题 【luogu-3132】【USACO16JAN】愤怒的奶牛Angry Cows 【luogu-3398】仓鼠找sugar 【luogu-1047】【国家集训队】稳定婚姻 Wednesday 完善前两天题目 完善任务列表内题目 Thursday 习题 【luogu-2668】【NOIP2015】斗地主 树（BZOJ 2466） 基因变异（CODEVS 3194） Friday 习题 同余方程（NOIP2012 提高组）（CODEVS 1200） 麦森数（CODEVS 1087） 统计公共子序列个数（CODEVS 1778） - Xn 数列（CODEVS1281） Saturday 洛谷网课进阶数学 洛谷网课进阶数据结构 Sunday 完善周四周五两天题目 完善任务列表内题目]]></content>
  </entry>
  <entry>
    <title><![CDATA[【unknow】木板（单调栈）]]></title>
    <url>%2F%E3%80%90unknow%E3%80%91%E6%9C%A8%E6%9D%BF%EF%BC%88%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述 地上从左到右竖立着nnn块木板，从 1 n1~n1 n依次编号. 如下图所示。我们知道每块木板的高度，在第nnn块木板右侧竖立着一块高度无限大的木板，现对每块木板依次做如下的操作： 对于第iii块木板，我们从其右侧开始倒水，直到水的高度等于第iii块木板的高度，倒入的水会淹没aia_iai​块木板（如果木板左右两侧水的高度大于等于木板高度即视为木板被淹没）. 求nnn次操作后，所有aia_iai​的和是多少。如图上所示，在第444块木板右侧倒水，可以淹没第555块和第666块一共222块木板,a4=2a_{4} = 2a4​=2。 单调栈 单调栈来求解的话，复杂度是O(n)O(n)O(n) 结合单调栈的性质：使用单调栈可以找到元素向左遍历第一个比他小的元素，也可以找到元素向左遍历第一个比他大的元素。 顾名思义，单调栈就是栈内元素单调递增或者单调递减的栈，这一点和单调队列很相似，但是单调栈只能在栈顶操作。 性质 若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。(数值单调性) 越靠近栈顶的元素越后进栈。（下标单调性） 进栈操作 元素进栈过程：对于单调递增栈，若当前进栈元素为e，从栈顶开始遍历元素，把小于e或者等于e的元素弹出栈，直接遇到一个大于e的元素或者栈为空为止，然后再把e压入栈中。对于单调递减栈，则每次弹出的是大于e或者等于e的元素。 数据模拟 思路：寻找比栈顶高的木板i，找到就出栈，不是就把木板i入栈，给出循环计数样例 10，5，8，12，6 从左往右扫描 栈为空，10入栈 栈：10 此时栈顶是10，也就是说要寻找比10大的木板 5比10小，5入栈 栈：5，10 此时栈顶是5，也就是说要寻找比5大的木板 8比5大，5出栈 栈：10 这个时候，第二个高度为5的木板右边比它高的木板已经找到了，是第三个木板8，所以5出栈，计算a2 = 3-2-1 = 0 8比10小，8入栈 栈：8，10 此时栈顶是8，也就是说要寻找比8大的木板 12比8大，8出栈 栈：10 第三个高度为8的木板右边比它高的木板已经找到了，是第四个木板12，8出栈，计算a3 = 4-3-1 = 0 12比10大，10出栈 栈：空 第一个高度为10的木板右边比它高的木板已经找到了，是第四个木板12，所以10出栈，计算a1 = 4-1-1 = 2 栈为空，12入栈 栈：12 此时栈顶是12，也就是说要寻找比12大的木板 6比12小，6入栈 栈：6，12 此时栈顶是6，也就是说要寻找比6大的木板 扫描完成结束 最后栈的结构是：6，12 栈顶为6 由于最右端竖立着一块高度无限大的木板，即存在第六块木板高度为无穷，所以剩余两块木板的算法如下 a5 = 6-5-1 =0 a4 = 6-4-1 = 1 sum = a1 + a2 +a3 +a4 +a5 = 3 因此本题可以在O(n)的时间内迎刃而解了。 从左往右将木板节点压栈，遇到比栈顶木板高的木板就将当前栈顶木板出栈并计算淹没的木板数，如此循环直到栈顶木板高度比当前木板高或者栈为空， 然后将此木板压栈。木板全都压栈完成后，栈内剩余的木板都是右侧没有比它们更高的木板的，所以一个个出栈并计算ai=n+1−tempid−1a_i= n+1-temp_id-1ai​=n+1−tempi​d−1(用最右边无限高的木板减)。 简述思路 对于一个栈中元素kkk,在把序列中kkk后面的元素加入栈中时，寻找在加栈过程中将kkk替换的元素，这个把kkk替换掉的元素就是kkk右边第一个比kkk小（大）的值。 code 12345678910111213141516171819202122int main() &#123; int n,ans=0; cin&gt;&gt;n; Stack&lt;Node&gt; stack(n); Node temp; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;temp.height; temp.id=i; //遇到了右侧第一个比栈顶元素大的元素,计算并出栈 while(!stack.empty()&amp;&amp;stack.top().height&lt;=temp.height)&#123; ans=ans+i-stack.top().id-1; stack.pop(); &#125; stack.push(temp); &#125; //现在栈中的木板右侧没有比它高的木板,用最右侧无限高的木板减 while(!stack.empty())&#123; ans=ans+n+1-stack.top().id-1; stack.pop(); &#125; cout&lt;&lt;ans&lt;&lt;endl; retur]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1886】【poj-2823】滑动窗口]]></title>
    <url>%2F%E3%80%90luogu-1886%E3%80%91%E3%80%90poj-2823%E3%80%91%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[【luogu-1886】【poj-2823】滑动窗口 单调队列 两种性质 - 单调队列中数据的顺序于原序列顺序相同 - 单调队列中数据数值上是单调的 用途 - 解决类似滑动窗口的问题（即：维护区间最值） - 优化DP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/*! * FileName: luogu-1886.cpp * This Problem is on luogu. The ID of the problem is 1886. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1e6 + 100;int A[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct AmazingQue&#123; int Que[_]; int head; int tail;// bool *optor(int a, int b); AmazingQue()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &gt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q1;struct AmazingQue2&#123; int Que[_]; int head; int tail; AmazingQue2()&#123; memset(Que, 0, sizeof(Que)); head = 0; tail = 0; &#125; inline int front()&#123; return Que[head]; &#125; inline void pop() &#123; head++; &#125; inline bool empty() &#123; return tail == head; &#125; inline void push(int x) &#123; while(Que[tail - 1] &lt; x &amp;&amp; tail &gt; head) tail --; Que[tail ++] = x; &#125; &#125;Q2;int AnsA[_];int totA = 0;int main()&#123;// Q1.optor = rule1;// Q2.optor = rule2; int n = read(), k = read(); for(register int i = 1;i &lt;= n;i++) A[i] = read(); for(register int i = 1;i &lt;= k;i++) Q1.push(A[i]); for(register int i = 1;i &lt;= k;i++) Q2.push(A[i]); for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q1.front()) == A[i - 1]) Q1.pop(); Q1.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); totA = 0; for(register int i = 2;i &lt;= n - k + 2;i ++) &#123; int newx = i + k - 1; if((AnsA[++totA] = Q2.front()) == A[i - 1]) Q2.pop(); Q2.push(A[newx]); &#125; for(register int i = 1;i &lt;= totA;i++) printf("%d ", AnsA[i]); printf("\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[知识树 && 注意事项 && 文章]]></title>
    <url>%2F%E7%9F%A5%E8%AF%86%E6%A0%91-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[index 算法 模拟 【luogu-UVA10366】【uva-10366】龙头滴水 Faucet Flow 图论 Tarjan 无向图割点And桥 · - 【luogu-3469 】【POI2008】BLO-Blockade 无向图双连通分量 有向图强连通分量 【luogu-3387】【模板】缩点 - 【luogu-2341】【HAOI2006】受欢迎的牛 - 【luogu-2746】【USACO5.3】Network of Schools 最短路 差分约束 - 【luogu-1993】小K的农场 Djikstra SPFA Folyd 【luogu-1522】 牛的旅行 Cow Tours 分层图最短路 - 【luogu-4822】【BJWC2012】冻结（Done） - 【luogu-4568】【JLOI2011】飞行路线（Done） 连通块 [【luogu-3026】【USACO11OPEN】学习语言Learning Languages](/【luogu-3026】【USACO11OPEN】学习语言Learning Languages/) 树相关 最小生（大）成树 Prim Kruskal 【luogu-2573】【SCOI2012】滑雪（Done） 最小生成树（Done） - 【luogu-P3037】【USACO11DEC】简化的农场Simplifying the Farm (最小生成树数量) - 【luogu-1967】【NOIP2013】货车运输 LCA - 【luogu-3398】仓鼠找sugar （判断树上两路径是否相交） 【luogu-1967】【NOIP2013】货车运输 瓶颈树 树的重心 【poj-1655】Balancing Act (树的重心)（Done） 树的直径 【luogu-4408】【NOI2003】逃学的小孩（Done） 【luogu-3304】【SDOI2013】直径（Done） 基环树 表达式树 tire树 topsort 欧拉回路 欧拉路径 【unknow】Ant-trip（Error） 树链剖分 【luogu-3384】【模板】树链剖分 二分图匹配\染色 【luogu-3386】【模板】二分图匹配 网络流 最大流问题 增广路算法 最小割最大流定理 最小费用最大流问题 搜索 DFS BFS 迭代加深 双端搜索 A* IDA* 数论 见到式子，先推导！！ 【luogu-2671】【NOIP2015】求和（Done） - 【luogu-2512】【HNOI2008】糖果传递（Done） 欧几里得算法(gcd、exgcd) - 【luogu-1516】青蛙的约会（Done） 唯一分解定理(NO) 同余 【luogu-4942】小凯的数字（Done） 筛法 不定方程 杨耀三角 二项式定理 概率 期望 编码解码 莫比乌斯反演 矩阵 欧拉 【luogu-5091】【模板】欧拉定理 字符串 KMP Manacher LCP-最长公共前缀 后缀数组 AC自动机 DP DAG上动态规划 线性DP 区间DP 各种背包 树上DP - 【luogu-1352】没有上司的舞会 数位DP 利用单调性 Two-Pointer 【luogu-1638】逛画展（Done） - 【USACO16OPEN】钻石收藏家Diamond Collector 二分答案 二分查找 - 【luogu-1083】【NOIP2012】借教室（Done） 单调队列 - 【luogu-1886】【poj-2823】滑动窗口（Done） 单调栈 【unknow】木板（单调栈）（Done） 其他 贪心 分治 OI中的距离应用 【luogu-5098】【USACO2004OPEN】Cave Cows 3 洞穴里的牛之三(Done) 递归 数据结构 并查集 朴素并查集 种类并查集 【luogu-2024】食物链（Done） 【luogu-1525】关押罪犯（Done） 链表 队列 栈 平衡树 Treap - 平衡树——Treap（Done） FHQ Treap splay 线段树 - 【luogu-1083】【NOIP2012】借教室（Done） 树状数组 - 【luogu-3374】【模板】树状数组 1 - 【poj-2777】Count Color 分块 【luogu-3203】【HNOI2010】弹飞绵羊 莫队 - 【luogu-1494】【国家集训队】小Z的袜子（Done） 主席树 堆 手写堆 Priority_Queue 可持久化 可持久化并查集 主席树 其他算法 《浅谈用极大化思想解决最大子矩形问题》 注意事项 关于编译 打开编译选项-Wall，能帮助检查语言类错误 容易和库文件重复的函数、变量名 - clock init - max不要宏定义，递归结构GG - min - abs自己写 - time - 语言规范 - 一切情况下禁止使用gets，gets在Linux编译异常 - read读取时，先存下返回值，再传入参数 - 使用stl时&lt; &lt; &gt; &gt;不要连着 做题需要注意的地方 一定注意题目是否需要开long long、long long、long long！ - [x] 无向图，边数开两倍 堆，平衡树相关，空间四倍 见到式子，先推导！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2671】【NOIP2015】求和]]></title>
    <url>%2F%E3%80%90luogu-2671%E3%80%91%E3%80%90NOIP2015%E3%80%91%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[【luogu-2671】【NOIP2015】求和 思路 看见这种一堆一堆一堆的式子的题目，赶紧先手推一下。 可以得到x+yx + yx+y是偶数 然后先按照颜色分类，再按照编号奇偶分类。 需要算一些东西 不好意思懒得写了 看代码吧…… 注意 最近做题老是被long long卡掉…… 以后交题前先检查long long。 要是NOIP被long long弄死 我直接从机房跳下去。 F**K Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/*! * FileName: luogu-2671.cpp * This Problem is on luogu. The ID of the problem is 2671. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 100100;const int _M = 100100;int Ai[_M];//oint An[_M];//oint Bi[_M];//jint Bn[_M];//jint tot[_M][2];//tot[a][b] 颜色a， b = 0 : 1 o数 j数 int color[_N];int N[_N];const int MOD = 10007;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;signed main()&#123; int n = read();int m = read(); for(register int i = 1;i &lt;= n;i++) N[i] = read(); for(register int i = 1;i &lt;= n;i++) color[i] = read(); for(register int i = 1;i &lt;= n;i++) &#123; if(i &amp; 1) &#123; Bi[color[i]] += i; Bn[color[i]] += N[i]; tot[color[i]][1] ++; &#125; else &#123; Ai[color[i]] += i; An[color[i]] += N[i]; tot[color[i]][0] ++; &#125; &#125; long long ans = 0; for(register int i = 1;i &lt;= m;i++) &#123; if(tot[i][1] &gt; 1) ans += (Bi[i] * 1LL * Bn[i]) % MOD; if(tot[i][0] &gt; 1) ans += (Ai[i]* 1LL * An[i]) % MOD; ans %= MOD; &#125; for(register int i = 1;i &lt;= n;i++) ans += (max(0, (tot[color[i]][i &amp; 1] - 2)) * i * 1LL * N[i]) % MOD, ans %= MOD; printf("%lld", ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【poj-1655】Balancing Act (树的重心)]]></title>
    <url>%2F%E3%80%90poj-1655%E3%80%91Balancing-Act-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%2F</url>
    <content type="text"><![CDATA[树的重心 概念 树的重心也叫树的质心。 找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。 其实我的理解就是（人话）：找一个点，把这个点删掉后，让得到的一堆小森林中最大的数最小。 性质 删掉这个点后，得到森林，森林中的每一棵树的大小$\max\left { A \right }\leq $$\frac{n}{2}(((A\epsilon$得到的森林 nnn为结点总数)；逆定理存在。 两棵树接起来，形成的树的重心一定在原来两棵数的重心形成的路径上。 一棵树最多有两个重心，且相邻。 一棵树添加或者删除一个节点，树的重心最多只移动一条边的位置。 树中所有点到某个点的距离和中，到重心的距离和是最小的，如果有两个距离和，他们的距离和一样。 求法 贼简单 到一个节点后，找他的儿子的子树大小，和去掉他本身这棵子树后，剩下的大小。如果这些值中的最大值最小，记录节点更新答案。 Code 原题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/*! * FileName: poj-1655.cpp * This Problem is on poj. The ID of the problem is 1655. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _N = 201000;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int node; int nxt;&#125;edge[_N];int head[_N];int tot = 0;void add(int u, int v)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; head[u] = tot;&#125;int n;int AnsId;int minSize = inf;int Size[_N];void dfs(int now, int parent)&#123; int res = 0; Size[now] = 1; for(register int i = head[now];i;i = edge[i].nxt) &#123; int sonNode = edge[i].node; if(sonNode == parent) continue; dfs(sonNode, now); Size[now] += Size[sonNode]; res = max(res, Size[sonNode]); &#125; res = max(res, n - Size[now]); if(res == minSize) AnsId = min(AnsId, now); else if(res &lt; minSize) AnsId = now, minSize = res; return;&#125;void doit()&#123; memset(Size, 0, sizeof(Size)); minSize = inf; n = read(); int k; memset(head, 0, sizeof(head)); tot = 0; for(register int i = 1;i &lt;= n - 1;i ++) &#123; int tmpx = read(), tmpy = read(); add(tmpx, tmpy); add(tmpy, tmpx); k = tmpx; &#125; dfs(k, 0); printf("%d %d\n", AnsId, minSize) ;&#125;int main()&#123; int T = read(); while(T--) &#123; doit(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4408】【NOI2003】逃学的小孩]]></title>
    <url>%2F%E3%80%90luogu-4408%E3%80%91%E3%80%90NOI2003%E3%80%91%E9%80%83%E5%AD%A6%E7%9A%84%E5%B0%8F%E5%AD%A9%2F</url>
    <content type="text"><![CDATA[【luogu-4408】【NOI2003】逃学的小孩 思路 为了让小孩的妈妈走的最远： 找一个最长的直径，直径两端就是小孩两朋友的家 求出在这条直径上的每一个点到叶节点的最长距离，对应叶节点就是小孩的家 这样的话，小孩的妈妈走的路就是最最最最远的 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/*! * FileName: luogu-4408.cpp * This Problem is on luogu. The ID of the problem is 4408. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 200100;const int _M = _N;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; &apos;9&apos; || c &lt; &apos;0&apos;) &#123; if(c==&apos;-&apos;)sign = -1; c = getchar(); &#125; while(c &lt;= &apos;9&apos; &amp;&amp; c &gt;= &apos;0&apos;) &#123; x *= 10; x += c - &apos;0&apos;; c = getchar(); &#125; return x * sign;&#125;void swap(int &amp; x, int &amp; y)&#123; int t = x; x = y; y = t;&#125;int n, m; struct edges&#123; int node; int w; int nxt;&#125;edge[_M &lt;&lt; 1];int tot = 0;int head[_N];void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;bool vis[_N];int dist[_N];void dfs(int nowNode)&#123; vis[nowNode] = true; for(register int i = head[nowNode];i;i = edge[i].nxt) &#123; if(vis[edge[i].node]) continue; dist[edge[i].node] = dist[nowNode] + edge[i].w; dfs(edge[i].node); &#125;&#125;float r;int dist_[_N];int tot_ = 0;int MaxId2, MaxId;int MaxDeep = -inf;bool flag = false;int path[_N];bool inPath[_N];int path_w[_N];void dfsForPath(int k,int deepth, int w)&#123; vis[k] = true; path[deepth] = k; path_w[deepth] = w; if(k == MaxId2) &#123; MaxDeep = deepth;flag = true;return; &#125; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(vis[SonNode]) continue; dfsForPath(SonNode, deepth + 1, edge[i].w); if(flag)return; &#125;&#125;int dfsLast(int k)&#123; int longest = 0; vis[k] = true; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(inPath[SonNode] || vis[SonNode]) continue; longest = max(longest, dfsLast(SonNode) + edge[i].w); &#125; return longest;&#125;signed main()&#123; memset(vis, false, sizeof(vis)); n = read(), m = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(), tmpz = read(); add(tmpx, tmpy, tmpz); add(tmpy, tmpx, tmpz); &#125; int MaxDis = 0; memset(dist, 0, sizeof(dist)); dfs(1); for(register int i = 1;i &lt;= n;i++) &#123; if(dist[i] &gt; MaxDis) &#123; MaxDis = dist[i]; MaxId = i; &#125; &#125; memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); dfs(MaxId); int MaxDis2 = 0; for(register int i = 1;i &lt;= n;i++) &#123; if(dist[i] &gt; MaxDis2) &#123; MaxDis2 = dist[i]; MaxId2 = i; &#125; &#125; memset(vis, false, sizeof(vis)); dfsForPath(MaxId, 1, 0); memset(inPath, false, sizeof(inPath)); for(register int i = 1;i &lt;= MaxDeep;i++) inPath[path[i]] = true;//求出数的最长直径，并标记最长直径上的点。 int ans = -inf; memset(vis, 0, sizeof(vis)); int now = 0; for(register int i = 1;i &lt;= MaxDeep;i++) &#123; now += path_w[i]; int tmp = min(now, MaxDis2 - now); int kk = dfsLast(path[i]);//求最长直径上的点到叶节点的最长距离（不走在最长直径上的点） ans = max(ans, kk + tmp + MaxDis2); &#125; printf(&quot;%lld&quot;, ans); return 0;&#125;/*4 31 2 12 4 12 3 2*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3304】【SDOI2013】直径]]></title>
    <url>%2F%E3%80%90luogu-3304%E3%80%91%E3%80%90SDOI2013%E3%80%91%E7%9B%B4%E5%BE%84%2F</url>
    <content type="text"><![CDATA[【luogu-3304】【SDOI2013】直径 前提 我们需要明确以下几个条件： 树的直径会有很多条 一般地，树的这些直径有且只有一段重合。特殊地，这一段可能是一个点。 如图路径3−1−43-1-43−1−4是重合的。 思路 求出重合的这一段的长度，就是最终答案。 求法 要求这条路径的长度，由于是在树上的，所以只需要求出路径两端的端点即可 这端点是什么呢 就是各直径在这条重合路径同侧的端点的LCA 例子就是上图中，第一条路径是3−23-23−2,第二条路径是3−63 - 63−6,重合路径是3−43-43−4。 两条直径的端点666和222在重合路径3−43-43−4的同侧。我们只需要求端点666和222的LCA即点444就是重合路径的一个端点。 同理，求出另一个端点即可。 特殊地，对于一个点的LCA就是它本身。 但是多个点的LCA我不会用倍增求……呜呜呜呜呜。 然后用欧拉序求出LCA即可，然后求两个LCA的距离。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213/*! * FileName: luogu-3304.cpp * This Problem is on luogu. The ID of the problem is 3304. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 200100;const int _M = _N;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;void swap(int &amp; x, int &amp; y)&#123; int t = x; x = y; y = t;&#125;int n, m; struct edges&#123; int node; int w; int nxt;&#125;edge[_M &lt;&lt; 1];int tot = 0;int head[_N];void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;bool vis[_N];int dist[_N];void dfs(int nowNode)&#123;// if(vis[edge[i].node]) continue; vis[nowNode] = true; for(register int i = head[nowNode];i;i = edge[i].nxt) &#123; if(vis[edge[i].node]) continue; dist[edge[i].node] = dist[nowNode] + edge[i].w; dfs(edge[i].node); &#125;&#125;bool B[_N];int Er[_N &lt;&lt; 1], tot_Er = 0;int first[_N], tot_F = 0;int MinId = inf;int MaxId = -inf;void dfsForLCA(int k)&#123; vis[k] = true; first[k] = ++tot_F; Er[++tot_Er] = k; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(vis[SonNode]) continue; dfsForLCA(SonNode); Er[++tot_Er] = k; &#125;&#125;int To;//, ansB;int ans = 0;int RunningAns = 0;void dfsLast(int k)&#123; if(k == To) &#123; ans = RunningAns; return; &#125; vis[k] = true; for(register int i = head[k];i;i = edge[i].nxt) &#123; int SonNode = edge[i].node; if(vis[SonNode]) continue; RunningAns++; dfsLast(SonNode); RunningAns--; &#125;&#125;signed main()&#123; // freopen("test.in.txt", "r", stdin); int k = 1; memset(vis, false, sizeof(vis)); n = read(), m = n - 1; for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(), tmpz = read(); add(tmpx, tmpy, tmpz); add(tmpy, tmpx, tmpz); k = tmpx; &#125; int MaxDis = 0, MaxId; memset(dist, 0, sizeof(dist));// printf("Start at %d\n", k); dfs(k); for(register int i = 1;i &lt;= n;i++) &#123;// printf("%d ", dist[i]); if(dist[i] &gt; MaxDis) &#123; MaxDis = dist[i]; MaxId = i; &#125; &#125;// printf("%d\n", MaxId); memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); dfs(MaxId); int MaxDis_ = 0; int MaxAns = -inf; for(register int i = 1;i &lt;= n;i++) MaxDis_ = max(MaxDis_, dist[i]); MaxAns = MaxDis_; for(register int i = 1;i &lt;= n;i++) B[i] = (dist[i] == MaxDis_); memset(first, -1, sizeof(first)); memset(vis, false, sizeof(vis)); dfsForLCA(MaxId); for(register int i = 1;i &lt;= tot_Er;i++) &#123;// printf("%d ", Er[i]); if(B[Er[i]]) &#123; MinId = min(MinId, i); MaxId = max(MaxId, i); &#125; &#125;//cout&lt;&lt;endl;// for(register int i = 1;i &lt;= tot_Er;i++) // printf("%d ", first[Er[i]]); //printf("\n%d %d\n", MinId, MaxId); int F_Min = inf; int LCA_Id; for(register int i = MinId;i &lt;= MaxId;i ++) &#123; //printf("at %d , Er[%d] = %d, First[%d] = %d\n", i, i, Er[i], Er[i], first[Er[i]]); if(F_Min &gt; first[Er[i]]) &#123; F_Min = first[Er[i]]; LCA_Id = Er[i]; &#125; &#125; //printf("LCA = %d\n", LCA_Id);// printf("MaxDist = %d, node = %d ,%d\n", MaxDis2, MaxId2, MaxId); memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); int S = Er[MinId]; dfs(S);//printf("%d", S); memset(first, -1, sizeof(first)); tot_Er = 0; tot_F = 0; for(register int i = 1;i &lt;= n;i++) B[i] = (dist[i] == MaxDis_); memset(vis, false, sizeof(vis)); dfsForLCA(S); MinId = inf; MaxId = -inf;//cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;"&amp;"&lt;&lt;endl; for(register int i = 1;i &lt;= tot_Er;i++) &#123;// printf("%d ", Er[i]); if(B[Er[i]]) &#123; MinId = min(MinId, i); MaxId = max(MaxId, i); &#125; &#125;// printf("MaxId = %d, MinId = %d\n", MaxId, MinId); F_Min = inf; int LCA_Id2; for(register int i = MinId;i &lt;= MaxId;i ++) &#123;// printf("at %d , Er[%d] = %d, First[%d] = %d\n", i, i, Er[i], Er[i], first[Er[i]]); if(F_Min &gt; first[Er[i]]) &#123; F_Min = first[Er[i]]; LCA_Id2 = Er[i]; &#125; &#125;// printf("\n###%d %d\n", LCA_Id2, LCA_Id); To = LCA_Id; memset(vis, false, sizeof(vis)); dfsLast(LCA_Id2); printf("%lld\n%lld", MaxAns, ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[做题计划]]></title>
    <url>%2F%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[Part 2.1 模拟 [ ][P2482 SDOI2010]猪国杀 [ ]P3693 琪露诺的冰雪小屋 [ ][P5380 THUPC2019]鸭棋 Part 2.2 排序算法 [ ]P1908 逆序对 Part 2.3 二分答案 [ ]P2678 跳石头 [ ]P1316 丢瓶盖 [ ]P1902 刺杀大使 [ ]P1314 聪明的质监员 [ ]P1083 借教室 [ ][P4343 SHOI2015]自动刷题机 Part 2.4 分治 [ ]P1257 平面上的最接近点对 [ ][P3612 USACO17JAN]Secret Cow Code秘密奶牛码 Part 2.5 贪心 [ ]P1090 合并果子 [ ][P1208 USACO1.3]混合牛奶 Mixing Milk [ ]P1094 纪念品分组 [ ]P1199 三国游戏 [ ]P2672 推销员 [ ]P1080 国王游戏 Part 2.6 高精度 [ ]P1601 A+B Problem（高精） [ ]P2142 高精度减法 [ ]P1303 A*B Problem [ ]P1480 A/B Problem [ ]P1009 阶乘之和 Part 3 搜索 Part 3.1 深度优先搜索 [ ]P1019 单词接龙 [ ][P5194 USACO05DEC]Scales 天平 [ ]P1378 油滴扩展 Part 3.2 广度优先搜索 [ ]P1032 字串变换 [ ]P1126 机器人搬重物 Part 3.3 记忆化搜索 [ ]P1535 游荡的奶牛 [ ][P1434 SHOI2002]滑雪 [ ]P3953 逛公园 Part 3.4 搜索的剪枝 [ ]P1120 小木棍 ［数据加强版］ [ ]P1312 Mayan游戏 [ ]P1074 靶形数独 Part 3.5 双向搜索 在搜索时，如果能从初态和终态出发，同时进行搜索，就可以减小搜索树的规模，提高时间效率。 [ ][P3067 USACO12OPEN]Balanced Cow Subsets [ ][P4799 CEOI2015 Day2]世界冰球锦标赛 [ ][P5195 USACO05DEC]Knights of Ni 骑士 Part 3.6 A* [ ]P1379 八数码难题 Part 3.7 IDA* 像 BFS 那样，每次只扩展一层节点，却采用 DFS 方式来遍历搜索树，这就是迭代加深搜索。 再加上一个估价函数来减小搜索量，就是 IDA*了。 [ ][P2324 SCOI2005]骑士精神 Part 4 动态规划 动态规划是一种重要的思维方法，通过利用已有的子问题信息高效求出当前问题的最优解。 Part 4.1 线性动态规划 线性动态规划，即具有线性阶段划分的动态规划。 [ ]P1216 数字三角形 [ ]P1020 导弹拦截 [ ]P1091 合唱队形 [ ]P1095 守望者的逃离 [ ]P1541 乌龟棋 [ ]P1868 饥饿的奶牛 [ ]P2679 子串 [ ][P2501 HAOI2006]数字序列 [ ][P3336 ZJOI2013]话旧 [ ][P3558 POI2013]BAJ-Bytecomputer [ ][P4158 SCOI2009]粉刷匠 [ ][P5301 GXOI/GZOI2019]宝牌一大堆 Part 4.2 背包动态规划 背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。 [ ]P1048 采药 [ ]P1060 开心的金明 [ ]P1855 榨取kkksc03 [ ]P5020 货币系统 [ ]P1064 金明的预算方案 [ ][P2946 USACO09MAR]牛飞盘队Cow Frisbee Team [ ]P1156 垃圾陷阱 [ ][P5322 BJOI2019]排兵布阵 [ ][P5289 十二省联考2019]皮配 Part 4.3 区间动态规划 区间动态规划一般以区间作为动态规划的阶段。 [ ][P1880 NOI1995]石子合并 [ ][P3146 USACO16OPEN]248 [ ]P1063 能量项链 [ ]P1005 矩阵取数游戏 [ ][P4170 CQOI2007]涂色 [ ][P4302 SCOI2003]字符串折叠 [ ][P2466 SDOI2008]Sue的小球 Part 4.4 树形动态规划 树形动态规划，即在树上进行的动态规划。 因为树的递归性质，树形动态规划一般都是递归求解的。 [ ]P1352 没有上司的舞会 [ ]P1040 加分二叉树 [ ]P1122 最大子树和 [ ]P1270 “访问”美术馆 [ ]P1273 有线电视网 [ ]P2014 选课 [ ][P3177 HAOI2015]树上染色 [ ][P4516 JSOI2018]潜入行动 Part 4.5 状态压缩动态规划 将一个状态压缩为一个整数（通常为二进制数），就可以在更为方便地进行状态转移的同时，达到节约空间的目的。 [ ][~~P2704 NOI2001]炮兵阵地~~ [ ][P1879 USACO06NOV]玉米田Corn Fields [ ][~~P1896 SCOI2005]互不侵犯~~ [ ][P3092 USACO13NOV]没有找零No Change [ ]P3694 邦邦的大合唱站队 [ ][P4925 1007]Scarlet的字符串不可能这么可爱 [ ][P3648 APIO2014]序列分割 [ ][P2157 SDOI2009]学校食堂 [ ][P2167 SDOI2009]Bill的挑战 [ ]P2396 yyy loves Maths VII [ ][P4363 九省联考2018]一双木棋chess [ ]P5005 中国象棋 – 摆上马 [ ][P2150 NOI2015]寿司晚宴 Part 4.6 倍增优化动态规划 利用倍增的方式，我们可以将状态转移的效率大大提高。 [ ]P1613 跑路 [ ]P1081 开车旅行 [ ]P5024 保卫王国 Part 4.7 数据结构优化动态规划 利用数据结构来维护已有信息，也可以达到优化状态转移的目的。 [ ]P4719 【模板】动态dp [ ]P4751 动态dp【加强版】 [ ][P3287 SCOI2014]方伯伯的玉米田 [ ][P2605 ZJOI2010]基站选址 Part 4.8 单调队列优化动态规划 如果决策具有单调性，就可以考虑运用单调队列来优化动态规划的效率。 [ ]P1776 宝物筛选_NOI导刊2010提高（02） [ ][P3089 USACO13NOV]POGO的牛Pogo-Cow [ ][P3572 POI2014]PTA-Little Bird [ ][P3522 POI2011]TEM-Temperature [ ][P4544 USACO10NOV]购买饲料Buying Feed [ ][P1973 NOI2011]Noi嘉年华 [ ][P2569 SCOI2010]股票交易 [ ]P4852 yyf hates choukapai Part 4.9 斜率优化动态规划 通过用单调队列维护一个凸壳，来达到优化转移的目的。 [ ][P2305 NOI2014]购票 [ ][P2900 USACO08MAR]土地征用Land Acquisition [ ][P3195 HNOI2008]玩具装箱TOY [ ][P3628 APIO2010]特别行动队 [ ][P4027 NOI2007]货币兑换 [ ][P4360 CEOI2004]锯木厂选址 Part 4.10 四边形不等式优化动态规划 利用四边形不等式，我们就可以提高一些区间动态规划的效率。 P3515 [POI2011]Lightning Conductor [ ][P4767 IOI2000]邮局 Part 4.11 数位统计类动态规划 统计一个区间中满足条件的数有多少，就是数位统计类动态规划。 [ ][P2602 ZJOI2010]数字计数 [ ][P3281 SCOI2013]数数 [ ][P2518 HAOI2010]计数 [ ][P2657 SCOI2009]windy数 [ ][P3286 SCOI2014]方伯伯的商场之旅 [ ][P4124 CQOI2016]手机号码 [ ][P2606 ZJOI2010]排列计数 Part 4.12 轮廓线动态规划 轮廓线动态规划（即常说的插头 DP）是一种特殊的状压动态规划，通过以轮廓线为状态来实现状态转移。 [ ]P5056 【模板】插头dp [ ][P2289 HNOI2004]邮递员 [ ][P2337 SCOI2012]喵星人的入侵 Part 5 字符串 字符串问题有很多自己的特点。 Part 5.1 字符串哈希 [ ]P3370 【模板】字符串哈希 [ ]P5270 无论怎样神树大人都会删库跑路 Part 5.2 KMP KMP 算法可以用来解决模式串匹配问题。 [ ]P3375 【模板】KMP字符串匹配 [ ][P4391 BOI2009]Radio Transmission 无线传输 [ ][P3435 POI2006]OKR-Periods of Words [ ][P2375 NOI2014]动物园 [ ][P3426 POI2005]SZA-Template [ ][P3193 HNOI2008]GT考试 [ ][P3435 POI2006]OKR-Periods of Words Part 5.3 Manacher Manacher 可以在线性时间内求出一个字符串的最长回文子串。 [ ]P3805 【模板】manacher算法 [ ][P4555 国家集训队]最长双回文串 [ ][P1659 国家集训队]拉拉队排练 Part 5.4 Trie树 [ ][P3879 TJOI2010]阅读理解 [ ][P2292 HNOI2004]L语言 [ ][P2922 USACO08DEC]秘密消息Secret Message [ ][P3065 USACO12DEC]第一!First! [ ][P3294 SCOI2016]背单词 [ ][P4407 JSOI2009]电子字典 [ ]P4551 最长异或路径 [ ][P4683 IOI2008] Type Printer 打印机 [ ][P3783 SDOI2017]天才黑客 Part 5.5 AC自动机 AC自动机可以看成是 KMP 和 Trie 的结合体，用于解决多字符串匹配问题。 [ ]P3808 【模板】AC自动机（简单版） [ ]P3796 【模板】AC自动机（加强版） [ ]P5357 【模板】AC自动机（二次加强版） [ ][P3121 USACO15FEB]审查（黄金）Censoring (Gold) [ ][P2414 NOI2011]阿狸的打字机 [ ][P3966 TJOI2013]单词 [ ][P2444 POI2000]病毒 [ ][P3311 SDOI2014]数数 [ ][P4052 JSOI2007]文本生成器 Part 5.6 后缀数组 后缀数组是处理字符串的有力工具。 [ ]P3809 【模板】后缀排序 [ ][P1117 NOI2016]优秀的拆分 [ ][P2178 NOI2015]品酒大会 [ ][P2463 SDOI2008]Sandy的卡片 [ ][P4051 JSOI2007]字符加密 [ ][P2336 SCOI2012]喵星球上的点名 [ ][P2852 USACO06DEC]牛奶模式Milk Patterns [ ][P5319 BJOI2019]奥术神杖 Part 5.7 后缀自动机 [ ]P3804 【模板】后缀自动机 [ ][P3649 APIO2014]回文串 [ ][P3975 TJOI2015]弦论 [ ][P4248 AHOI2013]差异 [ ][P5341 TJOI2019]甲苯先生和大中锋的字符串 [ ][P4770 NOI2018]你的名字 [ ][P5284 十二省联考2019]字符串问题 Part 6 数学 OI 中的数学知识很多，也有些杂乱。 Part 6.1 整除相关 与整除相关的概念有很多，比较常用的有素数，最大公约数和欧拉函数。 Part 6.1.1 素数 素数，指的是除 1 和它本身之外没有其他约数的数。 [ ]P3383 【模板】线性筛素数 [ ]P4718 【模板】Pollard-Rho算法 [ ]P1865 A % B Problem Part 6.1.2 最大公约数 如果两个数有一个共同的约数，那么这个约数就被称为公约数。最大公约数就是指这两个数的所有公约数中，最大的一个。 求解两个数的最大公约数，可以采用欧几里得算法解决。 [ ]P1029 最大公约数和最小公倍数问题 [ ][P2152 SDOI2009]SuperGCD [ ]P1072 Hankson 的趣味题 Part 6.1.3 欧拉函数 欧拉函数 $ \varphi (x) $ 表示了小于 $ x $ 的数字中，与 $ x $ 互质的数字个数。 [ ][P2158 SDOI2008]仪仗队 [ ]P2568 GCD [ ]P2398 GCD SUM Part 6.2 同余方程 求解不定方程往往可以引出不少话题。 Part 6.2.1 线性同余方程&amp;乘法逆元 [ ]P4549 【模板】裴蜀定理 [ ]P2613 【模板】有理数取余 [ ]P1082 同余方程 [ ]P1414 又是毕业季II [ ]P3951 小凯的疑惑 [ ]P1516 青蛙的约会 Part 6.2.2 中国剩余定理 中国剩余定理可以快速解一元线性同余方程组。 [ ]P4777 【模板】扩展中国剩余定理（EXCRT） [ ][P3868 TJOI2009]猜数字 [ ][P2480 SDOI2010]古代猪文 [ ][P4774 NOI2018]屠龙勇士 [ ]P5345 【XR-1】快乐肥宅 Part 6.2.3 BSGS BSGS 算法可以高效计算高次同余方程的解。 [ ]P4195 【模板】exBSGS/Spoj3105 Mod [ ][P3306 SDOI2013]随机数生成器 Part 6.3 博弈论 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。 [ ]P2197 【模板】nim游戏 [ ]P1288 取数游戏II [ ]P1290 欧几里德的游戏 [ ]P1247 取火柴游戏 [ ]P2252 取石子游戏 Part 6.4 概率与期望 概率和期望是紧密相连的，OI 中往往会出现和概率期望相关的动态规划问题。 [ ]P5104 红包发红包 [ ]P1837 单人纸牌_NOI导刊2011提高（04） [ ]P1850 换教室 [ ][P3830 SHOI2012]随机树 [ ][P4564 CTSC2018]假面 [ ][P2473 SCOI2008]奖励关 [ ][P2221 HAOI2012]高速公路 [ ][P3750 六省联考2017]分手是祝愿 [ ][P4284 SHOI2014]概率充电器 [ ][P5249 LnOI2019]加特林轮盘赌 [ ][P2081 NOI2012]迷失游乐园 [ ][P3343 ZJOI2015]地震后的幻想乡 [ ]P3600 随机数生成器 [ ][P5326 ZJOI2019]开关 Part 6.5 组合数学 Part 6.5.1 排列组合 [ ]P3807 【模板】卢卡斯定理 [ ]P2822 组合数问题 [ ]P1655 小朋友的球 [ ][P3197 HNOI2008]越狱 [ ][P2290 HNOI2004]树的计数 [ ]P4981 父子 [ ][P4769 NOI2018]冒泡排序 [ ]P4931 情侣？给我烧了！（加强版） Part 6.5.2 卡特兰数&amp;斯特林数 [ ]P5395 【模板】第二类斯特林数·行 [ ]P5396 【模板】第二类斯特林数·列 [ ]P5408 【模板】第一类斯特林数·行 [ ]P5409 【模板】第一类斯特林数·列 [ ][P2532 AHOI2012]树屋阶梯 [ ][P3200 HNOI2009]有趣的数列 [ ][P3978 TJOI2015]概率论 [ ][P4091 HEOI2016/TJOI2016]求和 [ ][P4827 国家集训队] Crash 的文明世界 Part 6.5.3 容斥原理 [ ][P1450 HAOI2008]硬币购物 [ ][P3214 HNOI2011]卡农 [ ][P3270 JLOI2016]成绩比较 [ ][P4336 SHOI2016]黑暗前的幻想乡 [ ][P4448 AHOI2018初中组]球球的排列 [ ][P4491 HAOI2018]染色 [ ][P5339 TJOI2019]唱、跳、rap和篮球 [ ][P5400 CTS2019]随机立方体 Part 6.6 线性代数 Part 6.6.1 矩阵 利用矩阵优化数列递推，可以实现复杂度从线性到对数级的转变。 [ ]P3390 【模板】矩阵快速幂 [ ]P1939 【模板】矩阵加速（数列） [ ]P4783 【模板】矩阵求逆 [ ]P1962 斐波那契数列 [ ]P1349 广义斐波那契数列 [ ]P4000 斐波那契数列 [ ]P5343 【XR-1】分块 [ ][P5337 TJOI2019]甲苯先生的字符串 [ ][P5303 GXOI/GZOI2019]逼死强迫症 Part 6.6.2 高斯消元 高斯消元可以用来求解方程组。 [ ]P3389 【模板】高斯消元法 [ ]P4387 付公主的函数 [ ][P4035 JSOI2008]球形空间产生器 [ ][P4111 HEOI2015]小Z的房间 [ ][P4457 BJOI2018]治疗之雨 Part 6.6.3 线性基 线性基可以求解最大异或和的一类问题。 [ ]P3812 【模板】线性基 [ ][P3857 TJOI2008]彩灯 [ ][P4301 CQOI2013]新Nim游戏 [ ][P3292 SCOI2016]幸运数字 [ ][P4151 WC2011]最大XOR和路径 Part 6.7 多项式 对多项式的运算进行优化，从而能够解决规模更大的问题。 [ ]P1919 【模板】A*B Problem升级版（FFT快速傅里叶） [ ]P3803 【模板】多项式乘法（FFT） [ ]P4238 【模板】多项式求逆 [ ]P4239 【模板】多项式求逆（加强版） [ ]P4245 【模板】任意模数NTT [ ]P4717 【模板】快速沃尔什变换 [ ]P4721 【模板】分治 FFT [ ]P4725 【模板】多项式对数函数 [ ]P4726 【模板】多项式指数函数 [ ]P4781 【模板】拉格朗日插值 [ ]P5050 【模板】多项式多点求值 [ ]P5158 【模板】多项式快速插值 [ ]P5205 【模板】多项式开根 [ ]P5245 【模板】多项式快速幂 [ ]P5264 【模板】多项式三角函数 [ ]P5265 【模板】多项式反三角函数 [ ]P5273 【模板】多项式幂函数 (加强版) [ ]P5277 【模板】多项式开根（加强版） [ ]P5282 【模板】快速阶乘算法 [ ]P5373 【模板】多项式复合函数 [ ]P5383 【模板】普通多项式转下降幂多项式 [ ]P5393 【模板】下降幂多项式转普通多项式 [ ]P5394 【模板】下降幂多项式乘法 [ ][P3338 ZJOI2014]力 [ ][P3723 AH2017/HNOI2017]礼物 [ ][P5293 HNOI2019]白兔之舞 Part 6.8 莫比乌斯反演 [ ]P3768 简单的数学题 [ ][P3172 CQOI2015]选数 [ ][P3455 POI2007]ZAP-Queries [ ][P3327 SDOI2015]约数个数和 [ ][P4619 SDOI2018]旧试题 Part 7 数据结构 灵活地运用数据结构可以高效地查询并处理需要的信息。 Part 7.1 链表 在一个数列中高效插入一个元素，链表毫无疑问是最好的选择。 [ ]P1996 约瑟夫问题 [ ]P1160 队列安排 Part 7.2 栈 栈，是一种后进先出（FILO）的数据结构。 [ ]P1449 后缀表达式 [ ]P1739 表达式括号匹配 [ ]P1981 表达式求值 [ ]P1175 表达式的转换 Part 7.3 队列 队列，是一种先进先出（FIFO）的数据结构。 [ ]P1540 机器翻译 Part 7.4 并查集 并查集常用于处理一些不相交集合的合并和查询问题。 [ ]P1111 修复公路 [ ]P3958 奶酪 [ ]P1525 关押罪犯 [ ][~~P2024 NOI2001]食物链~~ [ ][~~P1197 JSOI2008]星球大战~~ [ ][P1196 NOI2002]银河英雄传说 [ ][P1955 NOI2015]程序自动分析 Part 7.5 堆 堆总是一棵完全树，堆中某个节点的值总是不大于或不小于其父节点的值。 [ ]P3378 【模板】堆 [ ]P1168 中位数 [ ]P2085 最小函数值 [ ]P2827 蚯蚓 Part 7.6 树状数组 树状数组是一种简洁高效的树形数据结构。 [ ]P3374 【模板】树状数组 1 [ ]P3368 【模板】树状数组 2 [ ]P1908 逆序对 [ ]P1966 火柴排队 [ ][P1972 SDOI2009]HH的项链 [ ][P3586 POI2015]LOG [ ][P4054 JSOI2009]计数问题 [ ][P4113 HEOI2012]采花 [ ]P3960 列队 Part 7.7 线段树 线段树的通用性比树状数组更强，可以处理更多涉及区间操作的题目。 [ ]P3372 【模板】线段树 1 [ ]P3373 【模板】线段树 2 [ ]P1382 楼房 [ ]P1471 方差 [ ]P1502 窗口的星星 [ ][P2471 SCOI2007]降雨量 [ ][P2824 HEOI2016/TJOI2016]排序 [ ][P3722 AH2017/HNOI2017]影魔 [ ][P4097 HEOI2013]Segment [ ]P4198 楼房重建 [ ]P4513 小白逛公园 [ ][P5324 BJOI2019]删数 [ ][P5327 ZJOI2019]语言 Part 7.8 分块 分块是一种非常通用的暴力方法，虽然效率不如线段树和树状数组，但可以解决很多线段树和树状数组处理不了的问题。 [ ][P3870 TJOI2009]开关 [ ][P1972 SDOI2009]HH的项链 [ ]P3396 哈希冲突 [ ][P1494 国家集训队]小Z的袜子 [ ][P1903 国家集训队]数颜色 / 维护队列 [ ][P1975 国家集训队]排队 [ ]P3710 方方方的数据结构 [ ][P4074 WC2013]糖果公园 [ ][P4168 Violet]蒲公英 [ ][P4119 Ynoi2018]未来日记 [ ][P4117 Ynoi2018]五彩斑斓的世界 Part 7.9 点分治 点分治是一种可以高效统计树上路径信息的算法。 [ ]P3806 【模板】点分治1 [ ][P2634 国家集训队]聪聪可可 [ ]P2664 树上游戏 [ ][P4292 WC2010]重建计划 [ ][P4149 IOI2011]Race [ ][P3241 HNOI2015]开店 Part 7.10 主席树 [ ][P2468 SDOI2010]粟粟的书架 [ ][P3302 SDOI2013]森林 [ ][P3168 CQOI2015]任务查询系统 [ ][P4559 JSOI2018]列队 [ ]P2633 Count on a tree [ ][P3293 SCOI2016]美味 [ ][P4618 SDOI2018]原题识别 Part 7.11 平衡树 [ ]P3369 【模板】普通平衡树 [ ]P3391 【模板】文艺平衡树（Splay） [ ][P3850 TJOI2007]书架 [ ][P4008 NOI2003]文本编辑器 [ ][P5338 TJOI2019]甲苯先生的滚榜 [ ][P2042 NOI2005]维护数列 [ ][P1110 ZJOI2007]报表统计 [ ][P3644 APIO2015]八邻旁之桥 [ ]P3765 总统选举 [ ][P1486 NOI2004]郁闷的出纳员 [ ]P2710 数列 [ ][P3224 HNOI2012]永无乡 [ ][P3285 SCOI2014]方伯伯的OJ [ ][P5321 BJOI2019]送别 Part 7.12 树链剖分 树链剖分可以将任意一条树上路径划分成若干条连续的链，并用线段树等数据结构高效维护链上信息。 [ ]P3384 【模板】树链剖分 [ ][P3313 SDOI2014]旅行 [ ][P2590 ZJOI2008]树的统计 [ ][P2486 SDOI2011]染色 [ ][P2146 NOI2015]软件包管理器 [ ][P3178 HAOI2015]树上操作 [ ][P3258 JLOI2014]松鼠的新家 [ ][P4069 SDOI2016]游戏 [ ][P4211 LNOI2014]LCA [ ][P5305 GXOI/GZOI2019]旧词 Part 7.13 树套树 树套树可以用来维护多维度信息。 [ ]P3380 【模板】二逼平衡树（树套树） [ ][P1975 国家集训队]排队 [ ][P3332 ZJOI2013]K大数查询 [ ]P4278 带插入区间K小值 [ ][P1903 国家集训队]数颜色 / 维护队列 [ ][P3759 TJOI2017]不勤劳的图书管理员 [ ][P3242 HNOI2015]接水果 [ ][P3248 HNOI2016]树 Part 7.14 动态树 Link-Cut Tree 可以用来解决动态树一类问题。 [ ]P3690 【模板】Link Cut Tree （动态树） [ ][P3203 HNOI2010]弹飞绵羊 [ ][P1501 国家集训队]Tree II [ ][P4338 ZJOI2018]历史 [ ][P4312 COCI 2009] OTOCI / 极地旅行社 [ ][P2387 NOI2014]魔法森林 [ ][P3348 ZJOI2016]大森林 [ ][P3703 SDOI2017]树点涂色 [ ][P4172 WC2006]水管局长 [ ][P4219 BJOI2014]大融合 Part 7.15 CDQ分治&amp;整体二分 通过离线分治算法，我们可以避免使用一些高级数据结构。 [ ]P3810 【模板】三维偏序（陌上花开） [ ]P1393 动态逆序对 [ ]P2617 Dynamic Rankings [ ][P3332 ZJOI2013]K大数查询 [ ][P4169 Violet]天使玩偶/SJY摆棋子 Part 7.16 可持久化数据结构 可持久化数据结构实现了在更新信息的时候保留历史版本。 [ ]P3835 【模板】可持久化平衡树 [ ]P3919 【模板】可持久化数组（可持久化线段树/平衡树） [ ]P5055 【模板】可持久化文艺平衡树 [ ]P3834 【模板】可持久化线段树 1（主席树） [ ]P3402 【模板】可持久化并查集 [ ][P5283 十二省联考2019]异或粽子 Part 8 图论 图论是数学的一个分支，它以图为研究的对象。 Part 8.1 图的存储与遍历 这里的图论内容都比较简单，涉及图的存储以及遍历图的方式。 [ ]P2661 信息传递 [ ][P2921 USACO08DEC]在农场万圣节Trick or Treat on the Farm Part 8.2 最短路问题 很多题目都可以转化为最短路的模型。因此，掌握最短路算法非常重要。 [ ]P3371 【模板】单源最短路径（弱化版） [ ]P4779 【模板】单源最短路径（标准版） [ ]P1144 最短路计数 [ ]P5001 魔法祝福 [ ]P1462 通往奥格瑞玛的道路 [ ]P1522 牛的旅行 Cow Tours [ ]P1266 速度限制 [ ][P3238 HNOI2014]道路堵塞 [ ][P5304 GXOI/GZOI2019]旅行者 Part 8.3 树上问题 作为一种特殊的图，树上的问题具有很多鲜明的特点。 Part 8.3.1 二叉树 二叉树是一种特殊的树，它有很多特殊的性质。 [ ]P1087 FBI树 [ ]P1030 求先序排列 [ ]P1305 新二叉树 [ ]P1229 遍历问题 Part 8.3.2 树的直径 树的直径被定义为树上最远的两点间的距离。 计算树的直径，可以通过两遍 DFS 解决。 [ ]P2195 HXY造公园 [ ][P3629 APIO2010]巡逻 [ ]P1099 树网的核 Part 8.3.3 最近公共祖先 两个点的最近公共祖先，即两个点的所有公共祖先中，离根节点最远的一个节点。 求解最近公共祖先，常用的方法是树上倍增或者树链剖分。 [ ]P3379 【模板】最近公共祖先（LCA） [ ]P3938 斐波那契 [ ][P4281 AHOI2008]紧急集合 / 聚会 Part 8.4 生成树 用 $ n-1 $ 条边将图上的 $ n $ 个点连接起来，形成的树就被称为生成树。 [ ]P3366 【模板】最小生成树 [ ]P1546 最短网络 Agri-Net [ ][P2330 SCOI2005]繁忙的都市 [ ]P1991 无线通讯网 [ ]P1967 货车运输 Part 8.5 拓扑排序 将一个有向无环图排序，使得所有排在前面的节点不能依赖于排在后面的节点，这就是拓扑排序。 [ ]P1113 杂务 [ ]P1983 车站分级 [ ]P1038 神经网络 Part 8.6 差分约束 差分约束要解决的问题是：求出一组 $ n $ 元不等式的一组解，使得所有约束关系都能得到满足。 [ ][P3275 SCOI2011]糖果 [ ][P2294 HNOI2005]狡猾的商人 [ ][P4926 1007]倍杀测量者 Part 8.7 图的连通性相关 利用 Tarjan 算法，我们可以解决很多与图的连通性相关的问题。 [ ]P3387 【模板】缩点 [ ]P3388 【模板】割点（割顶） [ ][P2863 USACO06JAN]牛的舞会The Cow Prom [ ][P2746 USACO5.3]校园网Network of Schools [ ][P1407 国家集训队]稳定婚姻 [ ][P2341 HAOI2006]受欢迎的牛 [ ][P3225 HNOI2012]矿场搭建 [ ][P5058 ZJOI2004]嗅探器 [ ][P2515 HAOI2010]软件安装 Part 8.8 二分图 二分图上的不少问题都可以转化成网络流解决，当然也有独特的其他方法。 [ ]P3386 【模板】二分图匹配 [ ]P2756 飞行员配对方案问题 [ ]P1559 运动员最佳匹配问题 [ ][P2055 ZJOI2009]假期的宿舍 [ ][P2825 HEOI2016/TJOI2016]游戏 [ ][P3033 USACO11NOV]牛的障碍Cow Steeplechase [ ][P3731 HAOI2017]新型城市化 Part 8.9 网络流 网络流是图论中一个重要的分支，很多题目都可以通过建立网络流的模型来解决。 Part 8.9.1 最大流/最小割 最大流，即求网络中最大的流量。 最小割，即求一个边权最小的边集，使得源点和汇点不再连通。 可以证明，最大流=最小割，因此我们将最大流和最小割专题放在一起。 [ ]P3376 【模板】网络最大流 [ ]P4722 【模板】最大流 加强版 / 预流推进 [ ][P1345 USACO5.4]奶牛的电信Telecowmunication [ ][P2065 TJOI2011]卡片 [ ]P2774 方格取数问题 [ ]P2763 试题库问题 [ ][P2472 SCOI2007]蜥蜴 [ ]P2765 魔术球问题 [ ]P2764 最小路径覆盖问题 [ ]P2766 最长不下降子序列问题 [ ][P2805 NOI2009]植物大战僵尸 [ ][P3749 六省联考2017]寿司餐厅 [ ][P5039 SHOI2010]最小生成树 Part 8.9.2 费用流 在网络流中给边加上一个参数——费用，就出现了费用流。 [ ]P3381 【模板】最小费用最大流 [ ]P4016 负载平衡问题 [ ][P4452 国家集训队]航班安排 [ ][P2153 SDOI2009]晨跑 [ ][P2053 SCOI2007]修车 [ ][P3159 CQOI2012]交换棋子 [ ][P2604 ZJOI2010]网络扩容 [ ][P2050 NOI2012]美食节 [ ][P3980 NOI2008]志愿者招募 [ ][P4249 WC2007]剪刀石头布 [ ][P5331 SNOI2019]通信 Part 8.10 2-SAT [ ]P4782 【模板】2-SAT 问题 [ ][P3825 NOI2017]游戏 [ ][P5332 JSOI2019]精准预测 Part 8.11 虚树 [ ][P2495 SDOI2011]消耗战 [ ][P3233 HNOI2014]世界树 [ ][P5360 SDOI2019]世界地图 Part 8.12 矩阵树定理 矩阵树定理可以解决图的生成树计数问题。 [ ][P4111 HEOI2015]小Z的房间 [ ][P2144 FJOI2007]轮状病毒 [ ][P3317 SDOI2014]重建 [ ][P4208 JSOI2008]最小生成树计数 Part 9 计算几何 试着用计算机来解决几何问题吧！ Part 9.1 凸包 [ ]P2742 【模板】二维凸包 [ ][P2287 HNOI2004]最佳包裹 [ ][P3829 SHOI2012]信用卡凸包 [ ][P4680 Ynoi2018]末日时在做什么?有没有空?可以来拯救吗? [ ][P4557 JSOI2018]战争 [ ][P5403 CTS2019]田野 Part 9.2 旋转卡壳 [ ]P1452 Beauty Contest [ ][P3187 HNOI2007]最小矩形覆盖 Part 9.3 半平面交 [ ][P3256 JLOI2013]赛车 [ ][P2600 ZJOI2008]瞭望塔 [ ][P4196 CQOI2006]凸多边形 [ ][P3297 SDOI2013]逃考 [ ][P4250 SCOI2015]小凸想跑步 [ ][P5328 ZJOI2019]浙江省选 Part 10 杂项 Part 10.1 模拟退火 模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。 [ ][P1337 JSOI2004]平衡点 / 吊打XXX [ ][P2503 HAOI2006]均分数据 [ ][P3878 TJOI2010]分金币 Part 10.2 0/1 分数规划 [ ][P4377 USACO18OPEN]Talent Show [ ][P3199 HNOI2009]最小圈 [ ][P3288 SCOI2014]方伯伯运椰子 [ ][P3705 SDOI2017]新生舞会 [ ][P4322 JSOI2016]最佳团体 Part 10.3 奇怪的题目 OI 界中有一些非常规套路的题目，这里放出来分享。 [ ][P4920 WC2015]未来程序 [ ][P5042 国家集训队] 丢失的题面（ydc的题面） [ ][P5285 十二省联考2019]骗分过样例 [ ][P5246 集训队互测2016] 消失的源代码 Part 10.4 非传统题 在 NOI 等比赛中，非传统题正越来越频繁出现。 非传统题主要包括以下几类：提交答案题，交互题，通信题。 因为洛谷目前只支持提交答案题，因此这里暂时只列出提交答案题。 Part 10.4.1 提交答案题 给你一些输入，你只需要提交这些输入对应的答案，即为提交答案题。 [ ][P1335 NOI2013]小Q的修炼 [ ][P1737 NOI2016]旷野大计算 [ ]P3614 yyy棋 II [ ][P3640 APIO2013]出题人 [ ][P3782 WC2017]排序 [ ]P3836 Nowruz 诺鲁孜节 [ ][P4920 WC2015]未来程序 [ ][P5402 CTS2019]无处安放]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2573】【SCOI2012】滑雪]]></title>
    <url>%2F%E3%80%90luogu-2573%E3%80%91%E3%80%90SCOI2012%E3%80%91%E6%BB%91%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[数据丢失，详见题解 第一次知道有向图也是可以最小生成树的…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/*! * FileName: luogu-2573.cpp * This Problem is on luogu. The ID of the problem is 2573. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffff#define int long longusing namespace std;const int _N = 100100;const int _M = 1000100;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;struct edges&#123; int node; int w; int nxt;&#125;edge[_M &lt;&lt; 1];int tot = 0;int head[_N];void add(int u, int v, int w)&#123; edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot;&#125;struct Ew&#123; int u; int v; int w; int h; inline bool operator &lt; (const Ew A) const &#123; if(h == A.h) return w &lt; A.w; else return h &gt; A.h; &#125;&#125;_edge[_M];int totE = 0;int H[_N];bool vis[_N];int sum = 0;void Shu_Yu_Mo_Jia_You(int k)&#123; sum ++; vis[k] = true; for(register int i = head[k];i;i = edge[i].nxt) &#123; int &amp;node = edge[i].node; _edge[++totE].u = k; _edge[totE].v = node; _edge[totE].w = edge[i].w; _edge[totE].h = H[node]; if(!vis[node]) Shu_Yu_Mo_Jia_You(node); &#125;&#125;int F[_N];void init(int n) &#123; for(register int i = 1;i &lt;= n;i++) F[i] = i; &#125;int find(int x) &#123; return F[x] == x ? x : F[x] = find(F[x]); &#125;void marge(int x, int y) &#123; x = find(x);y = find(y);if(x == y) return; F[x] = y; &#125;int ask(int x, int y) &#123; return find(x) == find(y); &#125;signed main()&#123; memset(vis, false, sizeof(vis)); int n = read(), m = read(); for(register int i = 1;i &lt;= n;i++) H[i] = read(); for(register int i = 1;i &lt;= m;i++) &#123; int tmpx = read(), tmpy = read(), tmpz = read(); if(H[tmpx] &gt;= H[tmpy]) add(tmpx, tmpy, tmpz); if(H[tmpx] &lt;= H[tmpy]) add(tmpy, tmpx, tmpz); &#125; Shu_Yu_Mo_Jia_You(1); sort(_edge + 1, _edge + 1 + totE); init(n); int ans = 0; for(register int i = 1;i &lt;= totE;i++) &#123; Ew &amp; now = _edge[i];// printf("#%d %d %d %d\n", now.u, now.v,now.w,now.h); if(!ask(now.u, now.v)) &#123;// printf("marge %d %d\n", now.u, now.v); marge(now.u, now.v); ans += now.w; &#125; &#125; printf("%lld %lld", sum, ans); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1638】逛画展]]></title>
    <url>%2F%E3%80%90luogu-1638%E3%80%91%E9%80%9B%E7%94%BB%E5%B1%95%2F</url>
    <content type="text"><![CDATA[原题 Tow Point算法 利用单调性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*! * FileName: luogu-1638.cpp * This Problem is on luogu. The ID of the problem is 1638. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 1000100;const int _M = 2010;int A[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m;int sum = 0;int book[_M];void del(int x)&#123; book[x] --; if(book[x] == 0) sum --;&#125;void add(int x)&#123; book[x] ++; if(book[x] == 1) sum ++;&#125;int main()&#123;// freopen("test.in.txt", "r", stdin); memset(book, 0, sizeof(book)); n = read(); m = read(); for(register int i = 1;i &lt;= n;i++) A[i] = read(); int l = n, r = n; add(A[n]); int ansA; int ansB; int MinC = inf; while(l &lt;= r) &#123;// printf("[%d, %d] , sum = %d\n", l, r, sum); while(sum &lt; m &amp;&amp; l &gt; 1) add(A[--l]); if(r - l &lt;= MinC &amp;&amp; sum == m &amp;&amp; l &gt; 0 &amp;&amp; r &gt; 0) &#123;// printf("updated [%d, %d], sum = %d\n", l, r, sum); MinC = r - l; ansA = l; ansB = r; &#125; if(sum != m) break; del(A[r--]); if(r &lt; 1) break; &#125; printf("%d %d", ansA, ansB); return 0;&#125;]]></content>
      <categories>
        <category>Tow-pointer</category>
      </categories>
      <tags>
        <tag>Tow-pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4942】小凯的数字]]></title>
    <url>%2F%E3%80%90luogu-4942%E3%80%91%E5%B0%8F%E5%87%AF%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[原题 9是一个神奇的数字 设一个数xxx xmod9=x mod 9 =xmod9=把x拆开，每个数位加起来再mod9mod 9mod9 所以就好做了啊QAQQAQQAQ 等差数列求和，计算机中如果直接乘起来再除以222，会导致严重的溢出(1012∗101210^{12} * 10^{12}1012∗1012) 正解先找其中一个偶数除以222，然后分别对999去余，相乘即可 反正还是同余啊。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*! * FileName: luogu-4942.cpp * This Problem is on luogu. The ID of the problem is 4942. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int main()&#123; long long a, b; int Q = read(); while(Q--) &#123; scanf("%lld%lld", &amp;a, &amp;b); int ans; if((a + b) % 2 == 0) ans = ((a + b) &gt;&gt; 1) % 9 * ((b - a + 1) % 9), ans %= 9; else ans = (((b - a + 1) &gt;&gt; 1) % 9) * ((a + b) % 9), ans %= 9; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2512】【HNOI2008】糖果传递]]></title>
    <url>%2Fe3-80-90luogu-2512-e3-80-91-e3-80-90hnoi2008-e3-80-91-e7-b3-96-e6-9e-9c-e4-bc-a0-e9-80-92%2F</url>
    <content type="text"><![CDATA[原题 解 设： XiX_{i}Xi​为第$ i 个人给第个人给第个人给第i - 1个人的糖果（个人的糖果（个人的糖果（X_i$可以为负数）。 A_iA\_iA_i为第iii个人原有的糖果。 可得： 第一个人：A_1−X_1+X_2=aveA\_1 - X\_1 + X\_2 = aveA_1−X_1+X_2=ave X_2=ave−A_1+X_1X\_2 = ave -A\_1 + X\_1X_2=ave−A_1+X_1 第二个人：A_2−X_2+X_3=aveA\_2 - X\_2 + X\_3 = aveA_2−X_2+X_3=ave $X_3 = ave -A_2 + X_2 =&gt; 2 * ave + X_1 - A_1-A_2 $ 第三个人：A_3−X_3+X_4=aveA\_3 - X\_3 + X\_4 = aveA_3−X_3+X_4=ave $X_4 = ave -A_3 + X_3 =&gt; 3 * ave + X_1 - A_1-A_2-A_3 $ …… 对于第n个小朋友，An-Xn+X1=ave。 我们希望Xi的绝对值之和尽量小，即|X1| + |X1-C1| + |X1-C2| + ……+ |X1-Cn-1|要尽量小。 注意到|X1-Ci|的几何意义是数轴上的点X1到Ci的距离，所以问题变成了：给定数轴上的n个点，找出一个到他们的距离之和尽量小的点，而这个点就是这些数中的中位数。(蓝书P6) 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;#define LL long longconst int _ = 1e6 + 10;int A[_];int S[_];int C[_];int main()&#123; int n; scanf("%d", &amp;n); LL Ave = 0; for(register int i = 1;i &lt;= n;i++) scanf("%d", A + i), Ave += A[i]; Ave /= n; for(register int i = 1;i &lt;= n;i++) S[i] = S[i - 1] + A[i]; for(register int i = 1;i &lt;= n;i++)// cout&lt;&lt;(C[i] = S[i - 1] - (i - 1) * Ave)&lt;&lt;" "; C[i] = S[i - 1] - (i - 1) * Ave;// printf("Ave = %d \n", Ave); sort(C + 1, C + 1 + n); int mid; mid = C[(n + 1) &gt;&gt; 1]; LL ans = 0; for(int i = 1;i &lt;= n;i++) ans += abs(mid - C[i]); cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【unknow】Ant-trip]]></title>
    <url>%2Fant-trip%2F</url>
    <content type="text"><![CDATA[蚂蚁国家包含NNN个村庄，这里有MMM条道路连接这些村庄 蚂蚁tonytonytony和他的朋友想访问国家的每一个部分。 他们打算访问每一条路，并且每一条道只能访问一次。 然而，可能仅仅一组人没有办法完成这个任务。 所以，他们试图把这些蚂蚁朋友分成好几个组，从不同的地方开始。他想知道至少需要多少组才能完成这个任务。 输入包含多组样例，魅族阳历以好几行空白行隔开。每一组阳历以连个整数 N(1&lt;=N&lt;=100000),M(0&lt;=M&lt;=200000)开始。分别表示N个村庄和M条道路。接下来的M行，每行包含两个整数 a,b,(1&lt;=a,b&lt;=N) 。表示有一条路连接a和b。每条路都是不同的，没有路连接两个相同的村庄。 没有写完QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/*! ** have NOT Finished** ** https://www.luogu.org/blog/TheDawn/qian-xi-lca ** * FileName: luogu-3379.cpp * This Problem is on luogu. The ID of the problem is 3379. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define inf 0x7fffffffusing namespace std;const int _ = 233;const int _N = 1e5 + 100;const int _M = 5 * 1e5 + 100; inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;int n, m, s;namespace Graph&#123; struct _edges&#123; int node; int w; int nxt; &#125;edge[_M]; int head[_N]; int tot = 0; void add(int u, int v,int w) &#123; // printf("added %d %d\n", u, v); // printf("%d--%d[lable=\"%d\"];\n", u, v, w); edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot; swap(u, v); edge[++tot].nxt = head[u]; edge[tot].node = v; edge[tot].w = w; head[u] = tot; &#125; struct edges&#123; int a; int b; int c; &#125;e[_M];&#125;namespace LCA&#123; const int LOG = 23; int anc[_N][LOG]; int MinW[_N][LOG]; int depth[_N]; inline void dfs(int u, int p, int P_Udist, int d) &#123; anc[u][0] = p; depth[u] = d; MinW[u][0] = P_Udist; for(register int i = Graph::head[u];i != 0;i = Graph::edge[i].nxt) &#123; int node = Graph::edge[i].node; if(node == p) continue; dfs(node, u, Graph::edge[i].w, d + 1); &#125; &#125; inline void init() &#123; dfs(root, 0, 0, 1); for(register int j = 1; j &lt; LOG;j++) for(register int i = 1; i &lt;= n;i++) ans[i][j] = anc[ anc[i][j - 1] ][j - 1]; &#125; inline void swim(int &amp;x, int h) &#123; for(register int i = 0;h &gt; 0;i++) &#123; if(h &amp; 1) x = anc[x][i]; h &gt;&gt; 1; &#125; &#125; inline int query(int x, int y) &#123; &#125;&#125;int main()&#123; n = read(), m = read(), s = read(); for(register int i = 1;i &lt;= n - 1;i++)// int tmpx = read(), tmpy = read(); Graph::add(read(), read()); for(register int i = 1;i &lt;= m;i++) return 0;&#125;]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两段视频]]></title>
    <url>%2Fe4-b8-a4-e6-ae-b5-e8-a7-86-e9-a2-91%2F</url>
    <content type="text"><![CDATA[注意：两段视频已迁移到BiliBili 地址 第一段视频 [plyr poster=“http://47.92.113.238/Shu_Yu_Mo/wp-content/uploads/2019/06/1.mp4”]http://47.92.113.238/Shu_Yu_Mo/wp-content/uploads/2019/06/1.mp4[/plyr] 第二段视频 [plyr poster=“http://47.92.113.238/Shu_Yu_Mo/wp-content/uploads/2019/06/2.mp4”]http://47.92.113.238/Shu_Yu_Mo/wp-content/uploads/2019/06/2.mp4[/plyr]]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡树——Treap]]></title>
    <url>%2Fe5-b9-b3-e8-a1-a1-e6-a0-91-treap%2F</url>
    <content type="text"><![CDATA[记录几个坑点： 可以修改节点times来插入删除时，记得修改times和子树大小 插入删除函数，指针引用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/*! * This Problem is on Luogu. The ID of the problem is 1000. * Github :https://github.com/oldsuold/ * Gitee :https://gitee.com/Shu_Yu_Mo/ * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * These words were created by an amazing tool written by Shu_Yu_Mo. */#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;const int inf = 2147483647;using namespace std;//inline int randed()//&#123;// static unsigned int seed = 233;// return (seed *= 48271LL + 1000007) % 100000007; //&#125;inline int max(int x, int y) &#123; return x &lt; y ? y : x; &#125;inline int min(int x, int y) &#123; return x &lt; y ? x : y; &#125;inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') &#123; if(c=='-')sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x *= 10; x += c - '0'; c = getchar(); &#125; return x * sign;&#125;void print(int x)&#123; if(x &gt; 9) print(x / 10); putchar((x % 10) + '0');&#125;inline void writeln(int x)&#123; if(x &lt; 0) putchar('-'), print(-x); else print(x); putchar('\n');&#125;struct Node&#123; Node *ch[2]; int r; int v; int s; int times; Node(int v):v(v) &#123; ch[0] = ch[1] = NULL; r = rand(); s = times = 1;&#125; bool operator &lt; (const Node &amp; rhs) const &#123; return r &lt; rhs.r; &#125; int cmp(int x) &#123; if(x == v) return -1; return x &lt; v ? 0 : 1; &#125; void maintain() &#123; s = times; s += ch[0] -&gt; s; s += ch[1] -&gt; s; &#125; &#125;;Node *null;void rotate(Node *&amp;o, int d)&#123; Node *k = o -&gt; ch[d ^ 1]; o -&gt; ch[d ^ 1] = k -&gt; ch[d]; k -&gt; ch[d] = o; o -&gt; maintain(); k -&gt; maintain(); o = k;&#125;void insert(Node *&amp;o, int x)&#123; if(o == null) &#123; o = new Node(x); o -&gt; ch[0] = o -&gt; ch[1] = null; &#125; //, printf("create a node val = %d\n", x); else &#123; int d = o -&gt; cmp(x); if(d == -1) o -&gt; times++, o -&gt; s++; else &#123; insert(o -&gt; ch[d], x); if(o -&gt; ch[d] -&gt; r &gt; o -&gt; r) rotate(o, d ^ 1); &#125; &#125; o -&gt; maintain();&#125;void remove(Node *&amp;o,int x)&#123; int d = o -&gt; cmp(x); if(d == -1) &#123; if(o -&gt; times &gt; 1) &#123;o -&gt; times --;o -&gt; s -- ; return;&#125; Node *u = o; if(o -&gt; ch[0] != null &amp;&amp; o -&gt; ch[1] != null) &#123; int d2 = (o -&gt;ch[0]-&gt;r &gt; o-&gt;ch[1]-&gt;r ? 1 : 0); rotate(o, d2); remove(o -&gt; ch[d2], x); &#125; else &#123; if(o -&gt; ch[0] == null) o = o -&gt; ch[1]; else o = o -&gt; ch[0]; delete u; &#125; &#125; else remove(o -&gt; ch[d], x); o -&gt; maintain();&#125;//int rank(Node * o, int x)//&#123;// int ans = 0;// while(o -&gt; v != x)// &#123;// int leftSize = (o -&gt; ch[0] == NULL ? 0 : o -&gt; ch[0] -&gt; s);// if(o -&gt; v &lt; x)// ans += leftSize + o -&gt; times;// o = o -&gt; ch[o -&gt; cmp(x)];// &#125;// return ++ans;//&#125;int rank(Node *o, int x) &#123; if(o == null) return 0; if(o -&gt; v == x)return o -&gt; ch[0] -&gt; s + 1; if(o -&gt; v &lt; x) return o -&gt; ch[0] -&gt; s + o -&gt; times + rank(o -&gt; ch[1], x) ; if(o -&gt; v &gt; x) return rank(o -&gt; ch[0], x) ;&#125;//int find(Node * o, int x)//&#123;// if(o == NULL) return 0;// int leftSize = (o -&gt; ch[0] == NULL ? 0 : o -&gt; ch[0] -&gt; s);// if(leftSize &gt; x)// return find(o -&gt; ch[0], x);// else// if(leftSize + o -&gt; times &lt; x)// return find(o -&gt; ch[1], x - leftSize - (o -&gt; times));// else// return o -&gt; v;//&#125;int kth(Node *o, int x)&#123; Node *now = o; for(int leftSize = now -&gt; ch[0] -&gt; s; (x &lt;= leftSize || x &gt; leftSize + now -&gt; times); leftSize = now -&gt; ch[0] -&gt; s) if(x &gt; leftSize + now -&gt; times) &#123; x -= leftSize + now -&gt; times; now = now -&gt; ch[1]; &#125; else now = now -&gt; ch[0]; return now -&gt; v;&#125;int pre(Node *o, int x)&#123; if(o == null) return -inf; if(x &lt;= o -&gt; v) return pre(o -&gt; ch[0], x); else return max(o -&gt; v, pre(o -&gt; ch[1], x));&#125;int suf(Node *o, int x)&#123; if(o == null) return inf; if(x &gt;= o -&gt; v) return suf(o -&gt; ch[1], x); else return min(o -&gt; v, suf(o -&gt; ch[0], x));&#125;void check(Node *o)&#123; puts("# Node info:"); if(o == null) puts("This Node is NULL"); else &#123; printf(" value = %d\n times = %d\n rand = %d\n size = %d\n", o -&gt; v, o -&gt; times, o -&gt; r, o -&gt; s); printf("Into %d left son:\n", o -&gt; v); check(o -&gt; ch[0]); printf("Into %d right son:\n", o -&gt; v); check(o -&gt; ch[1]); &#125;&#125;int main()&#123;// writeln(233);// writeln(-233);// freopen("test.in.txt", "r", stdin);// freopen("test.out.txt", "w", stdout); null = new Node(0);null -&gt; Node *root = null; int n; n = read(); srand((n &gt;&gt; 1) + 233); for(register int i = 1; i &lt;= n;i++) &#123; int opt ; opt = read(); if(opt == 1) &#123; int val = read(); insert(root, val); &#125; if(opt == 2) &#123; int val = read(); remove(root, val); &#125; if(opt == 3) &#123; int val = read(); writeln(rank(root, val)); &#125; if(opt == 4) &#123; int val = read(); writeln(kth(root, val)); &#125; if(opt == 5) &#123; int val = read(); writeln(pre(root, val)); &#125; if(opt == 6) &#123; int val = read(); writeln(suf(root, val)); &#125; if(opt == 9) &#123; check(root); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>模板</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2Fe6-9c-80-e5-b0-8f-e7-94-9f-e6-88-90-e6-a0-91%2F</url>
    <content type="text"><![CDATA[最小生成树模板 prim /*! * FileName: luogu-3366.cpp * This Problem is on luogu. The ID of the problem is 3366. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */ #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff using namespace std; const int _ = 5100; inline int read() { char c = getchar(); int sign = 1; int x = 0; while(c &gt; '9' || c &lt; '0') { if(c=='-')sign = -1; c = getchar(); } while(c &lt;= '9' &amp;&amp; c &gt;= '0') { x *= 10; x += c - '0'; c = getchar(); } return x * sign; } int n, m; int g[_][_]; int Min[_]; bool vis[_]; int main() { n = read(), m = read(); memset(Min, 0x7f, sizeof(Min)); memset(g, 0x7f, sizeof(g)); memset(vis, false, sizeof(vis)); Min[1] = 0; for(register int i = 1;i &lt;= m;i++) { int tmpx = read(), tmpy = read(),tmpz = read(); g[tmpy][tmpx] = g[tmpx][tmpy] = min(g[tmpx][tmpy], tmpz); } for(register int i = 1;i &lt;= n;i++) { int k = 0; for(register int j = 1;j &lt;= n;j++) { if(!vis[j] &amp;&amp; Min[k] &gt; Min[j]) k = j; } // printf(&quot;find %d\n&quot;, k); vis[k] = true; for(register int j = 1;j &lt;= n;j++) if(!vis[j] &amp;&amp; Min[j] &gt; g[k][j]) Min[j] = g[k][j]; } int total = 0; bool flag = true; // for(register int i = 1;i &lt;= n;i++) // printf(&quot;%d : %d\n&quot;, i, Min[i]); for(register int i = 1;i &lt;= n;i++) { total += Min[i]; if(Min[i] == 0x7f7f7f7f) { flag = false; break; } } if(flag) cout&lt;&lt;total&lt;&lt;endl; else puts(&quot;orz&quot;); return 0; } Kruskal /*! * FileName: luogu-3366.cpp * This Problem is on luogu. The ID of the problem is 3366. * Copyright(c) 2019 Shu_Yu_Mo * MIT Licensed * Luogu: https://www.luogu.org/space/show?uid=44615 * Github: https://github.com/oldsuold/ * Gitee: https://gitee.com/Shu_Yu_Mo/ * These words were created by an amazing tool written by Shu_Yu_Mo. */ #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int MAX_M=200100; int n,m; struct www{ int u; int v; int w; // int id; }edge[MAX_M]; int f[MAX_M];//并查集 bool cmp(const www &amp; x,const www &amp; y){return x.w&lt;y.w;} void init() { for(int i=1;i&lt;=n;i++) f[i]=i; } int find(int k){return f[k]==k?k:f[k]=find(f[k]);} int Kruskal() { int ans=0; sort(edge+1,edge+1+m,cmp); for(int i=1;i&lt;=m;i++) { int x=find(edge[i].u); int y=find(edge[i].v); if(x!=y) { ans+=edge[i].w; f[x]=y; } } int caset=find(f[1]); for(int i=1;i&lt;=n;i++) if(caset!=find(f[i])) // printf(&quot;%d &quot;,find(f[i])), ans=-1; return ans; } int main() { int x,y,z; ios::sync_with_stdio(false); // ios::setstate() cin&gt;&gt;n&gt;&gt;m; init(); for(int i=1;i&lt;=m;i++) cin&gt;&gt;edge[i].u&gt;&gt;edge[i].v&gt;&gt;edge[i].w; int ans=Kruskal(); if(ans==-1) printf(&quot;orz\n&quot;); else printf(&quot;%d&quot;,ans); return 0; }]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1494】【国家集训队】小Z的袜子]]></title>
    <url>%2F192%2F</url>
    <content type="text"><![CDATA[莫对算法 对于L,RL,RL,R的询问。 其中颜色为$ x,y,z 的袜子的个数为的袜子的个数为的袜子的个数为 a,b,c $… 那么答案即为 $(a_(a-1) / 2+b_(b-1) / 2 + c_(c-1)/2…) / ((R-L+1)(R-L)/2) $ 化简得: $(a2+b2+c2+…x2-(a+b+c+d+…)) / ((R-L+1)(R-L)) $ 即： $ (a2+b2+c2+…x2-(R-L+1)) / ((R-L+1)_(R-L)) $ 我们需要解决的一个问题 求一个区间内每种颜色数目的平方和 Set记录颜色出现个数会TLE40。 开O2O_2O2​才30分。 坑点： 快读 100 -&gt; 40 long long 100 -&gt; 60 多次提交之后心态爆炸。。。。 _MMP_ 啥破题目 原题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define int long long using namespace std;const int _ = 5e4 + 10;int _n;int A[_];struct Query&#123; int le; int ri; int I; inline bool operator &lt; (const Query X ) const &#123; return (le / _n == X.le / _n) ? ri &lt; X.ri : le &lt; X.le; &#125;&#125;Q[_];inline int read()&#123; char c = getchar(); int sign = 1; int x = 0; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') sign = -1; c = getchar(); &#125; while(c &lt;= '9' &amp;&amp; c &gt;= '0') &#123; x = (x &lt;&lt; 3) + (x &lt;&lt; 1); x += (c - '0'); c = getchar(); &#125; return x * sign;&#125;struct ANS&#123; int x; int y; int gcd(int a, int b) &#123; return b == 0 ? a : this -&gt; gcd(b, a%b); &#125; inline void init(int _x, int _y) &#123; int g; if(_x != 0 &amp;&amp; _y != 0) g = this -&gt; gcd(_x, _y); else g = 1; if(_x == 0 || _y == 0) &#123; x = 0;y = 1;return; &#125; x = _x / g; y = _y / g; &#125;&#125;Ans[_];int book[_];int NOW = 0;inline void add(int x)&#123;// printf("add : %d NOW = %d\n", A[x], NOW); if(x == 0) return; NOW -= book[A[x]] * book[A[x]]; book[A[x]]++; NOW += book[A[x]] * book[A[x]];&#125;inline void del(int x)&#123;// printf("del : %d NOW = %d\n", A[x], NOW); if(x == 0) return; NOW -= book[A[x]] * book[A[x]]; book[A[x]]--; NOW += book[A[x]] * book[A[x]];&#125; main()&#123;// freopen("test.txt", "r", stdin);freopen("test.out.txt", "w", stdout); memset(book, 0, sizeof(book)); int n, m; n = read(); m = read(); _n = sqrt(n); for(register int i = 1;i &lt;= n;i++) A[i] = read(); for(register int i = 1;i &lt;= m;i++) Q[i].le = read(), Q[i].ri = read(), Q[i].I = i; sort(Q + 1, Q + 1 + m); register int nowl = 0, nowr = 0; for(register int i = 1;i &lt;= m;i++) &#123; register int &amp;Tl = Q[i].le; register int &amp;Tr = Q[i].ri; while(nowl &lt; Tl) del(nowl ++); while(nowl &gt; Tl) add(-- nowl); while(nowr &lt; Tr) add(++ nowr); while(nowr &gt; Tr) del(nowr --); int Y = (nowr - nowl + 1) * (nowr - nowl); int X = NOW - (nowr - nowl + 1); Ans[Q[i].I].init(X, Y); &#125; for(register int i = 1;i &lt;= m;i++) printf("%lld/%lld\n", Ans[i].x, Ans[i].y); return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>国家集训队</category>
        <category>模板</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2024】食物链]]></title>
    <url>%2Fe3-80-90luogu-2024-e3-80-91-e9-a3-9f-e7-89-a9-e9-93-be%2F</url>
    <content type="text"><![CDATA[种类并查集 原题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int _ = 3 * 1e5 + 10;struct Tree&#123; int f[_]; void initTree(int n) &#123; for(register int i = 0;i &lt;= n;i++) f[i] = i; &#125; int find(int x) &#123; return f[x] == x ? x :f[x] = find(f[x]); &#125; inline void marge(int x, int y) &#123; int f1 = find(x); int f2 = find(y); if(f1 == f2) return; f[f1] = f2; &#125; inline bool ask(int x, int y) &#123; return find(x) == find(y); &#125;&#125;S;int main()&#123; int n, k; scanf("%d%d", &amp;n, &amp;k); S.initTree(n * 3 + 5);//zzzzxcccc int tot = 0; for(register int i = 1;i &lt;= k;i++) &#123; int op;int x, y; scanf("%d", &amp;op); scanf("%d%d", &amp;x, &amp;y); if(x &gt; n || y &gt; n) &#123; tot++; continue; &#125; if(op == 1) &#123; int ans = true; if(S.ask(x, y + n) || S.ask(x + n , y)) &#123; tot++; continue; &#125; else &#123; S.marge(x, y); S.marge(x + n, y + n); S.marge(x + n + n, y + n + n); &#125; &#125; else &#123; if(x == y || S.ask(x, y) || S.ask(x + n, y)) &#123; tot++; continue; &#125; S.marge(x, y + n) ; S.marge(x + n, y + n + n); S.marge(x + n + n, y); &#125; &#125; printf("%d", tot); return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1525】关押罪犯]]></title>
    <url>%2Fe3-80-90luogu-1525-e3-80-91-e5-85-b3-e6-8a-bc-e7-bd-aa-e7-8a-af%2F</url>
    <content type="text"><![CDATA[原题 分类并查集 https://www.luogu.org/blog/812-xiao-wen/solution-p1525 // luogu-judger-enable-o2 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;map&gt; using namespace std; const int _N = 21000; const int _M = 110000; struct Find_Union_Set{ int F[_N &lt;&lt; 1]; Find_Union_Set(){} Find_Union_Set(int n){ for(register int i = 0;i &lt;= n;i++) F[i] = i;} int find(int x) { return F[x] == x ? F[x] : F[x] = find(F[x]); } bool ask(int x, int y) { return this -&gt; find(x) == this -&gt; find(y) ; } void marge(int x, int y) { int f1 = this -&gt; find(x), f2 = this -&gt; find(y); if(f1 == f2) return; F[f1] = f2; } }; Find_Union_Set set; struct Edge{ int a; int b; int w; bool operator &lt; (const Edge &amp; X) const { return w &gt; X.w; } }E[_M]; int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); set = Find_Union_Set((n &lt;&lt; 1) + 10); for(register int i = 1;i &lt;= m;i++) scanf(&quot;%d%d%d&quot;, &amp;E[i].a, &amp;E[i].b, &amp;E[i].w); sort(E + 1, E + 1 + m); int ans = 0; for(register int i = 1;i &lt;= m;i++) { int &amp;A = E[i].a, &amp;B = E[i].b; if(!set.ask(A, B)) { set.marge(A, B + n); set.marge(A + n, B); } else { ans = E[i].w; break; } } printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1083】【NOIP2012】借教室]]></title>
    <url>%2Fe3-80-90luogu-1083-e3-80-91-e3-80-90noip2012-e3-80-91-e5-80-9f-e6-95-99-e5-ae-a4%2F</url>
    <content type="text"><![CDATA[原题 二分做法 O(mlogn)O(mlogn)O(mlogn)的复杂度，常数还挺大的。。一直以为过不了，但是其实跑的挺快的。 你会发现，其实就是在枚举某个订单能否被接受，如果能，那这个点前面的都能；如果不能，那这个点后面的都不能；符合单调性,直接瞎∗∗**∗∗二分。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; const int _ = 1e6 + 100; struct Need{ int d; int s; int t; }ned[_]; int A[_]; int n, m; int C[_]; inline bool check(int k) { memset(C, 0, sizeof(C)); // printf(&quot;Id = %d : &quot;, k); for(register int i = 1;i &lt;= k;i++) { C[ned[i].s] -= ned[i].d; C[ned[i].t + 1] += ned[i].d; } int now = 0; for(register int i = 1;i &lt;= n;i++) { now += C[i]; if(A[i] + now &lt; 0) { // printf(&quot;false\n&quot;); return false; } } // printf(&quot;true\n&quot;); return true; } int work() { int le = 1, ri = n; int ans; while(le &lt;= ri) { int mid = (le + ri) &gt;&gt; 1; if(check(mid)) ans = mid, le = mid + 1; else ri = mid - 1; } return ans + 1; } int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(register int i = 1;i &lt;= n;i++) scanf(&quot;%d&quot;, A + i); for(register int i = 1;i &lt;= m;i++) scanf(&quot;%d%d%d&quot;, &amp;ned[i].d, &amp;ned[i].s, &amp;ned[i].t); int ans = work(); if(ans &gt; n) puts(&quot;0&quot;); else printf(&quot;-1\n%d&quot;, ans); return 0; } /* 4 3 20 20 20 20 2 1 3 3 2 4 4 2 4 */ 线段树做法 O(mlogn)O(mlogn)O(mlogn)以为数据结构能跑的呲呲的，但是线段树的常数……是一个尴尬的问题。。 O(mlogn)O(mlogn)O(mlogn)的复杂度，过10510^{5}105的数据竟然困难……（吸一口O2O_2O2​才能勉强过） 在使用define定义min()时，（#define min(a, b) (a)&lt;(b)?(a):(b)）一定不要把它使用在递归结构中，他会访问两次以上的参数，对于递归，这是致命的。 结果就是，好好的线段树跑的比暴力慢…… #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff using namespace std; const int _NODE = 3100000; const int _N = 1000000; inline int min(int x, int y) { if(x &lt; y) return x; else return y; } struct Node{ int MIN; int Sum; int tar; Node *lson, *rson; Node() { MIN = 0; tar = 0; } }POOL[_NODE]; int __tot__ = 0; Node * malloc_() { return &amp; POOL[__tot__++]; } Node * null; inline void updata(Node *tree) { tree -&gt; MIN = min(tree -&gt; rson -&gt; MIN, tree -&gt; lson -&gt; MIN); } inline void initNode(Node * tree) { tree -&gt; lson = tree -&gt; rson = null; } inline void build(Node *tree, int l, int r) { if(l == r) { scanf(&quot;%d&quot;, &amp;tree -&gt; MIN); return ; } tree -&gt; lson = malloc_(); initNode(tree -&gt; lson); tree -&gt; rson = malloc_(); initNode(tree -&gt; rson); int mid = (l + r) &gt;&gt; 1; build(tree -&gt; lson, l, mid); build(tree -&gt; rson, mid + 1, r); updata(tree); } inline void tar(Node * tree, int l, int r, int val) { if(tree == null) return; tree -&gt; MIN -= val; tree -&gt; tar += val; } inline void push(Node * tree, int nowl, int nowr) { if(nowl == nowr || tree == null) return; int mid = (nowl + nowr) &gt;&gt; 1; tar(tree -&gt; lson, nowl, mid, tree -&gt; tar); tar(tree -&gt; rson, mid + 1, nowr, tree -&gt; tar); tree -&gt; tar = 0; } inline void change(Node * tree, int l, int r, int val, int nowl,int nowr) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) { tar(tree, nowl, nowr, val); return ; } push(tree, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(tree -&gt; lson, l, r, val, nowl, mid); if(r &gt; mid) change(tree -&gt; rson, l, r, val, mid + 1, nowr); updata(tree); } inline int query(Node * tree, int l, int r, int nowl, int nowr) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return tree -&gt; MIN; int mid = (nowl + nowr) &gt;&gt; 1; push(tree, nowl, nowr); int ans = inf ; if(l &lt;= mid) ans = min(ans, query(tree -&gt; lson, l, r, nowl, mid)) ; if(r &gt; mid) ans = min(ans, query(tree -&gt; rson, l, r, mid + 1, nowr)); return ans; } int main() { // freopen(&quot;1083.in.txt&quot;, &quot;r&quot;, stdin); null = malloc_(); int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); Node * root = malloc_(); build(root, 1, n); // puts(&quot;Build Dnoe&quot;); /// printf(&quot;Memory = %d MiB\n&quot;, (sizeof(POOL)/1024/1024)); for(register int i = 1;i &lt;= m;i++) { int s, t, d; scanf(&quot;%d%d%d&quot;, &amp;d, &amp;s, &amp;t); change(root, s, t, d, 1, n); // puts(&quot;change Dnoe&quot;); int VAL = query(root, s, t, 1, n); // puts(&quot;query Dnoe\n&quot;); // printf(&quot;now ans = %d\n&quot;, VAL); if(VAL &lt; 0) { printf(&quot;-1\n%d&quot;, i); return 0; } // int op; // scanf(&quot;%d&quot;, &amp;op); // if(op == 2) // { // int x, y; // scanf(&quot;%d%d&quot;, &amp;x, &amp;y); // printf(&quot;In [%d, %d] Min Val = %d\n&quot;, x, y, query(root, x, y, 1, n)); // } // else // { // int x, y, val; // scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;val); // change(root, x, y, val, 1, n); // } } puts(&quot;0&quot;); return 0; } 另外还有几点注意：]]></content>
      <categories>
        <category>luogu</category>
        <category>NOIP</category>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4822】【BJWC2012】冻结]]></title>
    <url>%2Fe3-80-90luogu-4822-e3-80-91-e3-80-90bjwc2012-e3-80-91-e5-86-bb-e7-bb-93%2F</url>
    <content type="text"><![CDATA[分层图最短路问题 分层图最短路是指在可以进行分层图的图上解决最短路问题。 一般模型是： 在图上，有KKK次机会可以直接通过一条边，问起点与终点之间的最短路径。 P4822 【BJWC2012】冻结 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff //#include&lt;pair&gt; #include&lt;queue&gt; using namespace std; const int _M = 5100000; const int _N = 1100000; struct edges{ int node; int w; int nxt; edges() {} edges(int _node, int _w, int _nxt) { node = _node; w = _w; nxt = _nxt; } }edge[_M]; int head[_N]; int tot = 0; int N = -inf; inline void add(int u, int v,int w) { N = max(N, max(u, v)); edge[++tot] = edges(v, w, head[u]); head[u] = tot; } int n, m, k; int s, t; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; Q; int dist[_N]; bool vis[_N]; void dijkstra() { memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; Q.push(make_pair(0, s)); while(!Q.empty()) { int now = Q.top().second; Q.pop(); if(!vis[now]) { vis[now] = true; for(register int i = head[now];i;i = edge[i].nxt) { edges exNode = edge[i]; if(dist[exNode.node] &gt; dist[now] + exNode.w) { dist[exNode.node] = dist[now] + exNode.w; Q.push(make_pair(dist[exNode.node], exNode.node)); } } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); // scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s = 1;t = n; for(register int i = 1;i &lt;= m;i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); for(register int j = 1;j &lt;= k;j++) { add(u + j * n, v + j * n, w); add(v + j * n, u + j * n, w); add(u + (j - 1) * n, v + j * n, w &gt;&gt; 1); add(v + (j - 1) * n, u + j * n, w &gt;&gt; 1); } } // for(register int i = 1;i &lt;= k;i++) // add(t + (i - 1) * n, t + i * n, 0); dijkstra(); int ans = inf; for(register int i = 1;i &lt;= k + 1;i++) ans = min(ans, dist[t + (i - 1) * n]); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>NOIP</category>
        <category>OI</category>
        <category>模板</category>
        <category>省选题目</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4568】【JLOI2011】飞行路线]]></title>
    <url>%2Fe3-80-90luogu-4568-e3-80-91-e3-80-90jloi2011-e3-80-91-e9-a3-9e-e8-a1-8c-e8-b7-af-e7-ba-bf%2F</url>
    <content type="text"><![CDATA[分层图最短路问题 分层图最短路是指在可以进行分层图的图上解决最短路问题。 一般模型是： 在图上，有KKK次机会可以直接通过一条边，问起点与终点之间的最短路径。 P4568 [JLOI2011]飞行路线 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #define inf 0x7fffffff //#include&lt;pair&gt; #include&lt;queue&gt; using namespace std; const int _M = 5100000; const int _N = 1100000; struct edges{ int node; int w; int nxt; edges() {} edges(int _node, int _w, int _nxt) { node = _node; w = _w; nxt = _nxt; } }edge[_M]; int head[_N]; int tot = 0; int N = -inf; inline void add(int u, int v,int w) { N = max(N, max(u, v)); edge[++tot] = edges(v, w, head[u]); head[u] = tot; } int n, m, k; int s, t; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; Q; int dist[_N]; bool vis[_N]; void dijkstra() { memset(vis, false, sizeof(vis)); memset(dist, 0x3f, sizeof(dist)); dist[s] = 0; Q.push(make_pair(0, s)); while(!Q.empty()) { int now = Q.top().second; Q.pop(); if(!vis[now]) { vis[now] = true; for(register int i = head[now];i;i = edge[i].nxt) { edges exNode = edge[i]; if(dist[exNode.node] &gt; dist[now] + exNode.w) { dist[exNode.node] = dist[now] + exNode.w; Q.push(make_pair(dist[exNode.node], exNode.node)); } } } } } int main() { scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k); // scanf(&quot;%d%d&quot;, &amp;s, &amp;t); s = 1;t = n; for(register int i = 1;i &lt;= m;i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); for(register int j = 1;j &lt;= k;j++) { add(u + j * n, v + j * n, w); add(v + j * n, u + j * n, w); add(u + (j - 1) * n, v + j * n, w &gt;&gt; 1); add(v + (j - 1) * n, u + j * n, w &gt;&gt; 1); } } // for(register int i = 1;i &lt;= k;i++) // add(t + (i - 1) * n, t + i * n, 0); dijkstra(); int ans = inf; for(register int i = 1;i &lt;= k + 1;i++) ans = min(ans, dist[t + (i - 1) * n]); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>OI</category>
        <category>省选题目</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分层最短路]]></title>
    <url>%2Fe5-88-86-e5-b1-82-e6-9c-80-e7-9f-ad-e8-b7-af%2F</url>
    <content type="text"><![CDATA[分层最短路 适用情况 分层图最短路是指在可以进行分层图的图上解决最短路问题. 在图上，有kkk次机会可以直接通过一条边或者改变一条边的边权，问起点与终点之间的最短路径。 或者经过某个点需要对答案造成额外的贡献。 实现套路 DPDPDP实现（没写过） 建立多层图 把原图拆成很多层，这一层的点向下一层的点连单向边。同时改变点的编号。 注意 如果不需要KKK次，我们的操作是把在每层的结束点使用边权为000的边连起来。 建图类似于这样 for(register int i = 1;i &lt;= m;i++) { int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); for(register int j = 1;j &lt;= k;j++) { add(u + j * n, v + j * n, w); add(v + j * n, u + j * n, w); add(u + (j - 1) * n, v + j * n, w &gt;&gt; 1); add(v + (j - 1) * n, u + j * n, w &gt;&gt; 1); } } //add()用来建立单向边 例题 【JLOI2011】飞行路线 【BJWC2012】冻结 #### Blog 【JLOI2011】飞行路线 【BJWC2012】冻结]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1341】无序字母对]]></title>
    <url>%2Fe3-80-90luogu-1341-e3-80-91-e6-97-a0-e5-ba-8f-e5-ad-97-e6-af-8d-e5-af-b9%2F</url>
    <content type="text"><![CDATA[欧拉回环裸题 无向图 图联通 有两个或者没有奇点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;#define max(a, b) (a)&gt;(b)?(a):(b)#define min(a, b) (a)&lt;(b)?(a):(b)#define inf 0x7fffffffusing namespace std;const int _M = 6100;const int _N = 60;vector&lt;int&gt; G[_N];bool vis[_N][_N];int maxNode = -inf;int minNode = inf;//string Ans;std::stack &lt;char&gt; Ans;inline int GetHash(char x)&#123; if('A' &lt;= x &amp;&amp; x &lt;= 'Z') return x - 'A'; else if('a' &lt;= x &amp;&amp; x &lt;= 'z') return x - 'a' + 30;&#125;inline char SrcHash(int x)&#123; if(0 &lt;= x &amp;&amp; x &lt;= 25) return (char)(x + 'A'); else if(30 &lt;= x &amp;&amp; x &lt;= 55) return (char)(x - 30 + 'a');&#125;void dfs(int k)&#123;// printf("%c \n", SrcHash(k)); for(register int i = 0;i &lt; G[k].size();i++) &#123; int exNode = G[k][i]; if(!vis[k][exNode]) &#123; vis[k][exNode] = vis[exNode][k] = true; dfs(exNode); &#125; &#125; Ans.push(SrcHash(k));&#125;int main()&#123; int n; scanf("%d", &amp;n); for(register int i = 1;i &lt;= n;i++) &#123; char a, b; cin &gt;&gt; a &gt;&gt; b; int _a = GetHash(a), _b = GetHash(b); G[_a].push_back(_b); G[_b].push_back(_a); maxNode = max(maxNode, max(_a, _b)); minNode = min(minNode, min(_a, _b)); &#125;//QuMengYan@ for(register int i = 0;i &lt;= maxNode;i++) if(G[i].size() != 0) sort(G[i].begin(), G[i].end());// for(register int i = 0;i &lt;= maxNode;i++)// &#123;// if(G[i].size() == 0) continue;// printf("%c to :", SrcHash(i));// for(register int j = 0;j &lt; G[i].size();j++)// printf("%c ", SrcHash(G[i][j]));// cout&lt;&lt;endl;// &#125; int Sum = 0 ; int id = minNode; for(register int i = 0;i &lt;= maxNode;i++) if(G[i].size() % 2 == 1) &#123; Sum ++; if(Sum == 1) id = i;// printf("d = %d \n", i); &#125; dfs(id); int haveAns = true; if(Sum != 2 &amp;&amp; Sum != 0) haveAns = false; if(Ans.size() != n + 1) haveAns = false; if(haveAns) while(!Ans.empty())putchar(Ans.top()), Ans.pop(); else puts("No Solution"); return 0;&#125;]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉回路（路径）]]></title>
    <url>%2Fe6-ac-a7-e6-8b-89-e5-9b-9e-e8-b7-af-ef-bc-88-e8-b7-af-e5-be-84-ef-bc-89%2F</url>
    <content type="text"><![CDATA[用处 简单说就是在一张图上的一笔画问题。 要求 对于无向图 底图联通 有两个或者没有奇点 没有奇点就从任意点出发均可。 对于有向图 底图联通（忽略边） 最多只有两个点的入度不等于出度。而且必须是一个点入度比出度大111；另一个点的出度比入度大111。 void dfs(int k) { // printf(&quot;%d\n&quot;, k);不要在这里输出 for(int i = 0;i &lt; G[k].size();i++) { int exNode = G[k][i]; if(vis[k][exNode] &gt; 0) { vis[k][exNode]–; vis[exNode][k]–; dfs(exNode); } } stack.push(k);//先记录入栈 } 模板题]]></content>
      <categories>
        <category>OI</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2731】【USACO】骑马修栅栏 Riding the Fences]]></title>
    <url>%2Fe3-80-90luogu-2731-e3-80-91-e3-80-90usaco-e3-80-91-e9-aa-91-e9-a9-ac-e4-bf-ae-e6-a0-85-e6-a0-8f-riding-the-fences%2F</url>
    <content type="text"><![CDATA[欧拉路径 原题 找一个奇点，开始跑。 注意DFS统计答案要在最后面把结点压入栈中。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #define max(a, b) (a)&gt;(b)?(a):(b) #define min(a, b) (a)&lt;(b)?(a):(b) #define inf 0x7fffffff using namespace std; const int _ = 521; vector&lt;int&gt; G[_]; int vis[_][_]; stack&lt;int&gt;Ans; void dfs(int k) { // printf(&quot;%d\n&quot;, k); for(int i = 0;i &lt; G[k].size();i++) { int exNode = G[k][i]; if(vis[k][exNode] &gt; 0) { vis[k][exNode]--; vis[exNode][k]--; dfs(exNode); } } Ans.push(k); } int main() { memset(vis, 0, sizeof(vis)); int F, MaxNode = -inf, MinNode = inf; scanf(&quot;%d&quot;, &amp;F); for(register int i = 1;i &lt;= F;i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); vis[x][y] ++; vis[y][x] ++; G[x].push_back(y); G[y].push_back(x); MaxNode = max(MaxNode, x); MaxNode = max(MaxNode, y); MinNode = min(MinNode, x); MinNode = min(MinNode, y); } for(register int i = 1;i &lt;= MaxNode;i++) if(G[i].size()) sort(G[i].begin(), G[i].end()); int S = -1;; for(register int i = 1;i &lt;= MaxNode;i++) if(G[i].size() % 2 == 1) { S = i; break; } if(S != -1) dfs(S); else dfs(1); while(!Ans.empty()) { cout&lt;&lt;Ans.top()&lt;&lt;endl; Ans.pop(); } return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1983】【NOIP2012】车站分级]]></title>
    <url>%2Fe3-80-90luogu-1983-e3-80-91-e3-80-90noip2012-e3-80-91-e8-bd-a6-e7-ab-99-e5-88-86-e7-ba-a7%2F</url>
    <content type="text"><![CDATA[原题 非常恶心的一道题（坑多） 调试记录： - RE - 需要手写队列 - 访问下标为负数的内存 - 邻接表开大点…… - MLE - 邻接表开的太大了………… - 稠密图使用邻接矩阵存图 - TLE(Point #7) - 稠密图使用邻接矩阵存图 - 建立图方式尽量优化 - 去除重边 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;vector&gt; #define LL long long #define max(a, b) (a)&gt;(b)?(a):(b) using namespace std; const int _ = 1000010; //1000343 const int __ = 1100; //struct Node { // int node; // int nxt; //}edge[_]; //int head[__]; //int tot = 0; int ind[__]; //vector&lt;int&gt; G[__]; bool map[__][__]; void add(int u, int v) { if(map[u][v]) return; ind[v] ++; // G[u].push_back(v); map[u][v] = 1; // edge[++tot].nxt = head[u]; // edge[tot].node = v; // head[u] = tot; // printf(&quot;tot = %d \n&quot;, tot); } //queue&lt;int&gt;Q; int n, m; int ans = 0; int Time[__]; struct Queue{ int Q[_]; int head; int tail; Queue(){ head = tail = 0; } inline bool empty() { return head == tail; } inline void push(int x){ Q[tail++] = x; } inline void pop() { head++; } inline int top() { return Q[head]; } }Q; void topsort() { for(int i = 1;i &lt;= n;i++) if(ind[i] == 0) { Q.push(i); Time[i] = 1; } // puts(&quot;Done Init topsort&quot;); while(!Q.empty()) { int nowNode = Q.top();Q.pop(); ans = max(ans, Time[nowNode]); // puts(&quot;After pop --&quot;); for(int i = 1;i &lt;= n;i++) { if(map[nowNode][i]) { int exNode = i; ind[exNode]--; // puts(&quot;After ind --&quot;); // printf(&quot;i == %d&quot;, i); if(ind[exNode] == 0) { Q.push(exNode); Time[exNode] = Time[nowNode] + 1; } } // puts(&quot;After push --&quot;); // printf(&quot;Queue size = %d \n&quot;, Q.size()); // printf(&quot;Node = %d\n&quot;, edge[i].node); } } } int S[__]; int tot_S = 0; int uS[__]; int tot_uS = 0; int main() { // freopen(&quot;1983.in.txt&quot;, &quot;r&quot;, stdin); // freopen(&quot;1983.out.txt&quot;, &quot;w&quot;, stdout); memset(ind, 0, sizeof(ind)); memset(map, 0, sizeof(map)); scanf(&quot;%d%d&quot;, &amp;n, &amp;m) ; // puts(&quot;Running Begin&quot;); // cout&lt;&lt;n&lt;&lt;m&lt;&lt;endl; for(int i = 1;i &lt;= m;i++) { tot_S = tot_uS = 0; int s; scanf(&quot;%d&quot;, &amp;s); int a, b; scanf(&quot;%d&quot;, &amp;a); S[++tot_S] = a; for(register int j = 2;j &lt;= s;j++) { scanf(&quot;%d&quot;, &amp;b); S[++tot_S] = b; for(register int k = a + 1;k &lt; b;k++) uS[++tot_uS] = k; a = b; } for(register int j = 1;j &lt;= tot_S;j++) for(register int k = 1;k &lt;= tot_uS;k++) add(S[j], uS[k]); } // printf(&quot;Build Done\n&quot;); topsort(); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>NOIP</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1396】营救]]></title>
    <url>%2Fe3-80-90luogu-1396-e3-80-91-e8-90-a5-e6-95-91%2F</url>
    <content type="text"><![CDATA[原题 第一道二分答案。 要求最大值最小。 注意DFS在无向图上跑的时候需要vis判断重复 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;cmath&gt; #define max(a, b) (a)&gt;(b)?(a):(b) #define min(a, b) (a)&lt;(b)?(a):(b) #define inf 0x7fffffff using namespace std; const int _M = 40100; const int _N = 10100; int s, t; struct edges{ int node; int w; int nxt; }edge[_M]; int head[_N]; int tot = 0; void add(int u, int v,int w) { edge[++tot].node = v; edge[tot].w = w; edge[tot].nxt = head[u]; head[u] = tot; edge[++tot].node = u; edge[tot].w = w; edge[tot].nxt = head[v]; head[v] = tot; } bool HaveAns; bool vis[_N]; void dfs(int nowNode, int val) { if(nowNode == t) { HaveAns = true; return ; } if(vis[nowNode]) return; vis[nowNode] = true; for(int i = head[nowNode];i;i = edge[i].nxt) { if(edge[i].w &gt; val) continue; dfs(edge[i].node, val); if(HaveAns) return; } } inline bool check(int val) { memset(vis, false, sizeof(vis)); HaveAns = false; dfs(s, val); return HaveAns; } int MaxW = 0; int MinW = inf; int work() { int le = MinW, ri = MaxW; int ans = 0; while(le &lt;= ri) { int mid = (le + ri) &gt;&gt; 1; if(check(mid)) ans = mid, ri = mid - 1; else le = mid + 1; } return ans; } int main() { int n, m; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); for(register int i = 1;i &lt;= m;i++) { int tmpx, tmpy, tmpw; scanf(&quot;%d%d%d&quot;, &amp;tmpx, &amp;tmpy, &amp;tmpw); add(tmpx, tmpy, tmpw); MaxW = max(MaxW, tmpw); MinW = min(MinW, tmpw); } int ans = work(); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3143】【USACO16OPEN】钻石收藏家Diamond Collector]]></title>
    <url>%2Fe3-80-90luogu-e3-80-91-e3-80-90usaco16open-e3-80-91-e9-92-bb-e7-9f-b3-e6-94-b6-e8-97-8f-e5-ae-b6diamond-collector%2F</url>
    <content type="text"><![CDATA[**two-pointer问题， ** 类似于二分的思想， 利用数组的单调性。 简单的题意就是，需要解决在一个有序序列上面找一个最长的子序列，使子序列两极值相差小于K。 Luogu钻石收藏家 因为是要寻找两个子序列，我们使用两个数组维护答案： per[i]表示区间全部在i前面的最大区间。 suf[i] 表示区间全部在i后面的最大区间。 调试记录 两个区间端点不能重合 注意维护suf数组 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #define max(a, b) (a)&gt;(b)?(a):(b) using namespace std; const int _ = 50100; int A[_]; int per[_]; int suf[_]; int main() { int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(register int i = 1;i &lt;= n;i++) scanf(&quot;%d&quot;, A + i); sort(A + 1, A + 1 + n); int l = 1; for(register int r = 2;r &lt;= n;r++) { int backL = l; while(l &lt;= r &amp;&amp; A[r] - A[l] &gt; k) l ++; suf[l] = r - l + 1; for(register int i = backL;i &lt;= l;i++) suf[i] = max(suf[i], suf[l]) ; per[r] = max(per[r - 1], (r - l + 1)); } int ans = 0; for(register int i = 1;i &lt;= n;i++) ans = max(ans, per[i] + suf[i + 1]); printf(&quot;%d&quot;, ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【nowcoder 18985】数字权重]]></title>
    <url>%2Fe3-80-90nowcoder-18985-e3-80-91-e6-95-b0-e5-ad-97-e6-9d-83-e9-87-8d%2F</url>
    <content type="text"><![CDATA[题目描述 小AAA有一个nnn位的数字，但是它忘了各个位上的数是什么，现在请你来确定各个位上的数字，满足以下条件： - left(sumi=2nleft(ai−ai−1right)right)=K\\left ( \\sum_{i=2}^{n} \\left ( a_{i}-a_{i-1} \\right )\\right )=Kleft(sumi=2n​left(ai​−ai−1​right)right)=K - 不含前导000 设第iii位的数为aia_{i}ai​，其中a1.1a1. _{1}a1.1​为最高位，ana_{n}an​为最低位，KKK为给定的数字。 输入描述: 两个整数nnn, KKK 若存在无解的情况，请输出000 输出描述: 一个整数表示答案，对109+710^{9} + 7109+7取模 输入输出样例 输入：2 3 输出：6 输入：2 -3 输出：7 输入：4 3 输出：600 输入：4 -3 输出：700 数据范围 对于30%的数据 n,∣k∣=5n, |k| = 5n,∣k∣=5 对于60%的数据 n,∣k∣leq1013n, |k| \\leq 10^{13}n,∣k∣leq1013 对于1000%的数据 n,∣k∣leq1013,n&gt;0n, |k| \\leq 10^{13} , n &gt; 0n,∣k∣leq1013,n&gt;0 题解 left(sumi=2nleft(ai−ai−1right)=Kright)Rightarrowleft(left(a2−a1right)+left(a3−a2right)+left(a4−a3right)+cdots+left(an−an−1right)right)Rightarrowleft(a2−a1+a3−a2+a4−a3+cdots+an−an−1right)Rightarrowleft(an−a1right)\\left ( \\sum_{i=2}^{n} \\left ( a_{i}-a_{i-1} \\right )=K \\right) \\Rightarrow \\left( \\left( a_{2}-a_{1} \\right)+\\left( a_{3}-a_{2} \\right)+\\left( a_{4}-a_{3} \\right)+\\cdots +\\left( a_{n}-a_{n-1} \\right)\\right) \\Rightarrow \\left( a_{2}-a_{1} + a_{3}-a_{2} + a_{4}-a_{3} +\\cdots + a_{n}-a_{n-1} \\right)\\Rightarrow \\left( a_{n} - a_{1} \\right)left(sumi=2n​left(ai​−ai−1​right)=Kright)Rightarrowleft(left(a2​−a1​right)+left(a3​−a2​right)+left(a4​−a3​right)+cdots+left(an​−an−1​right)right)Rightarrowleft(a2​−a1​+a3​−a2​+a4​−a3​+cdots+an​−an−1​right)Rightarrowleft(an​−a1​right) 保证第一个数和最后一个数的差是KKK即可。 然后中间的差值有101010种，一共有10n−210^{n-2}10n−2种，快速幂求值即可。 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long const int P = 1000000007; long long Pow(long long a,long long b) { long long ans=1; while(b) { if(b&amp;1) ans=(ans*a)%P; a=(a*a)%P; b&gt;&gt;=1; } return ans; } int main() { long long n, k; cin &gt;&gt; n &gt;&gt; k; int p; if (k&gt;0)p = 9 - k; if (k&lt;0)p = 10 + k; if (k == 0)p = 9; long long sum = Pow(10, n - 2) % P; long long out = 0; for (int i = 0; i &lt; p; i++) out = (out + sum) % P; cout &lt;&lt; out &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>NewCoder</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-1080】【NOIP-2012】国王游戏]]></title>
    <url>%2Fe3-80-90luogu-1080-e3-80-91-e3-80-90noip-2012-e3-80-91-e5-9b-bd-e7-8e-8b-e6-b8-b8-e6-88-8f%2F</url>
    <content type="text"><![CDATA[原题 一道比较顺畅的贪心 当然要给大臣排序。 考虑一个排序规则，现在有两个大臣。X 和Y； Xa,XbX_{a}, X_{b}Xa​,Xb​分别代表其左手和右手数字的值； 如果X在Y前面，那么X会对Y做出贡献。 如果Y在X前面，那么Y会对X做出贡献。 哪个更好？ 根据Xa/YbX_{a}/Y_{b}Xa​/Yb​和Ya/XbY_{a}/X_{b}Ya​/Xb​的大小即可判断哪个在前面。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define LL long long #define max(a, b) (a)&gt;(b)?(a):(b) using namespace std; const int _ = 10100; struct person{ int a; int b; bool operator &lt; (const person &amp; x) const { return a / x.b &lt; x.a /b; } }P[_]; LL S = 1; int main() { int n; int a, b; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%d%d&quot;, &amp;a, &amp;b); for(register int i = 1;i &lt;= n;i++) scanf(&quot;%d%d&quot;, &amp;P[i].a, &amp;P[i].b); sort(P + 1, P + 1 + n); LL ans = 0; S = a; for(register int i = 1;i &lt;= n;i++) { ans = max(ans ,S / P[i].b); S *= P[i].a; } printf(&quot;%lld&quot;, ans); return 0; } 没有考虑高精度，只是贪心思想。]]></content>
      <categories>
        <category>luogu</category>
        <category>NOIP</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-2820】局域网]]></title>
    <url>%2F106%2F</url>
    <content type="text"><![CDATA[原题 最小生成树 而且我绝对不会说：我其实考试的时候没看出来…… 让删去的边最大。。那不就是让生成树最小吗。。。 于是，……最小生成树…… #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int _ = 310; struct edge{ int u; int v; int w; }; edge G[_]; int tot = 0; bool __CMP(const edge &amp;x, const edge &amp;y) { return x.w &lt; y.w; } struct Tree{ int F[_]; Tree (){} Tree(int n){ for(register int i = 1;i &lt;= n;i++)F[i] = i; } int find(int x) { return F[x] == x ? (F[x]):(find(F[x])); } void marge(int x, int y) { int f1 = this -&gt; find (x); int f2 = this -&gt; find (y); F[f1] = f2; } bool ask(int x, int y) { return this -&gt; find(x) == this -&gt; find(y); } }; Tree T; int main() { int n, k, sum = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(register int i = 1; i&lt;= k;i++) scanf(&quot;%d%d%d&quot;, &amp;G[i].u, &amp;G[i].v, &amp;G[i].w) , sum += G[i].w; sort(G + 1, G + 1 + k, __CMP); T = Tree(n); int ans = 0; for(register int i = 1;i &lt;= k;i++) { if(!T.ask(G[i].u, G[i].v)) { T.marge(G[i].u, G[i].v); ans += G[i].w; } } printf(&quot;%d&quot;, sum - ans); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错题集]]></title>
    <url>%2Fe9-94-99-e9-a2-98-e9-9b-86%2F</url>
    <content type="text"><![CDATA[堆 - 2019-1-29 记得pop()循环结束条件为now&lt;&lt;1&lt;=tot而不是now&lt;=tot。 记得pop()和push()循环结束条件都带着个等于号。 记得Z[]开四倍。 struct _heap{ private: int Z[40010]; int tot; void swap(int x,int y) { int tmp=Z[x]; Z[x]=Z[y]; Z[y]=tmp; } public: _heap() { tot=0; } void push(int x) { Z[++tot]=x; int now=tot; while((now&gt;&gt;1)&gt;=1) { int parent=now&gt;&gt;1; if(Z[now]&gt;=Z[parent])break; this-&gt;swap(now,parent); now=parent; } } void print() { for(int i=1;i&lt;=tot;i++) printf(&quot;%d &quot;,Z[i]); putchar('\n'); } void pop() { Z[1]=Z[tot]; tot--; int now=1; while(now&lt;&lt;1&lt;=tot) { int son=now&lt;&lt;1; if(son+1&lt;=tot &amp;&amp; Z[son]&gt;Z[son+1])son++; if(Z[son]&gt;Z[now])break; this-&gt;swap(son,now); now=son; } } int top() { return Z[1]; } };]]></content>
      <categories>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营day1]]></title>
    <url>%2Fluogu-e6-98-a5-e4-bb-a4-e8-90-a5day1%2F</url>
    <content type="text"><![CDATA[this博客没有写完，有空再写…… 二分&amp;三分 之所以一开始就聊二/三分，是因为我觉得这东西比较有意思，而且主要是我一直不会。。。。 首先，最大值最小化和最小值最大化是两个二分的_标志_，当然没有这两个标志的问题也可能用二分。 二分，一般有两种情况：最小值最大化和最小值最大化。 最大值最小化二分 一般的二分答案，其实就是在一个单调的函数上**摩擦**的操作。 这个函数可以不存在解析式，但是这个函数可以通过自变量取值得到函数值即可。 如果f(x)这个函数是判断取X是否合法的函数，而且具有单调性，那么其实这个函数的图像是这样的 或者 当x的值可以的时候，函数返回值为true，即为1。 当x的值不可以的时候，函数返回值为false，即为0。 二分查找的目的就在于找到函数图像的那个折点。 当然更复杂的就是函数值小于某个值的最大的x和函数值大于某个值的最小x（函数单调递增）。 来看一道例题。 题目描述： 输入N个数，把这N个数划分为M段，SUM(i)表示第i段的区间和，现在需要得到一中划分方法，使最大的区间和最小。 解题思路： 既然要求最大的区间和最小，那我们先分解这个问题；第一步是求出最大的区间和；然后第二步就是找出最小的那一个最大区间和。废话 我们先设最大的区间和为x，易得:任意一个i都可以使SUM(i)&lt;=x成立。 然后通过二分答案的方法查找一个在满足条件的情况下最小的x。 这样问题就转化为找下图中的折点。 //最大值最小化 int le = 1, ri = n, mid, ans; while (le &lt;= ri) { mid = (le + ri) / 2; if (check(mid)) ans = mid, ri = mid - 1; else le = mid + 1; } ans //最小值最大化 int le = 1, ri = n, mid, ans; while (le &lt;= ri) { mid = (le + ri) / 2; if (check(mid)) ans = mid, le = mid + 1; else ri = mid - 1; } ans //求实数 double le = 1, ri = n, mid; for (int i = 1; i &lt;= 50; i++) { mid = (le + ri) / 2; if (check(mid)) ri = mid; else le = mid; } ans //三分 le = 0; ri = min(i - 1, n - i); while (le + 1 &lt;= ri) { w1 = (ri - le) / 3 + le; w2 = ri - (ri - le) / 3; v1 = make(i, w1); v2 = make(i, w2); if (v1 &gt; v2) ri = w2 - 1; else le = w1 + 1; } le DFS判断存在环]]></content>
      <categories>
        <category>OI</category>
        <category>培训</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营 2]]></title>
    <url>%2F90%2F</url>
    <content type="text"><![CDATA[很多来自WJH老师的课件，若侵权then删除 TopSort 很少有特别裸的，图论反正都是这熊样，先建图，然后各种套模板 适用性 TopSort适用于DAG。 判断题目的关系是否能构成DAG。 int ind[MAXN]; int d[MAXN]; int q[MAXN], qhead = 0, qtail = 0;//队列相关 void topo() { for (int i = 1; i &lt;= n; i++) { if (!ind[i]) q[qtail++] = i; } while (qhead != qtail) { int now = q[qhead++]; for (int i = he[now]; i; i = ne[i]) { Edge &amp;e = ed[i]; d[e.to] = max(d[e.to], d[now] + 1);//DAG上最长路 if (!--ind[e.to]) q[qtail++] = e.to; } } } 待做例题 luoguP1983 车站分级 最小生成树&amp;并查集 struct UnionSet { int f[MAXN]; UnionSet(int n) { for (int i = 1; i &lt;= n; i++) { f[i] = i; } } UnionSet(){} void uni(int x, int y) { f[find(x)] = find(y); } bool query(int x, int y) { return find(x) == find(y); } int find(int x) { return f[x] == x ? x : (f[x] = find(f[x])); } } us; void kruskal() { sort(edges, edges+m); us = UnionSet(n); for (int i = 0; i &lt; m &amp;&amp; etop &lt; n * 2 - 1; i++) { Edge &amp;e = edges[i]; if (!us.query(e.from, e.to)) { insert(e.from, e.to, e.dist); insert(e.to, e.from, e.dist); us.uni(e.from, e.to); } } } 待做例题 luogu 模板题 P3366 luogu 买礼物P1194 最短路 两大“冤家”算法比较 Dijkstra算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：O(n²)（原版）/O(mlogn)(堆优化) 无法处理负权 每次找到离当前结点直接相连且最短的点，设置为确定点（这里可以看初如果边权为负的话，就不能确定这个点是确定点=GG）。再以当前点为当前结点，继续松弛。 SPFA算法，即队列优化的Bellman-Ford算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：声称为O(m)，最坏O(nm)，容易卡到最坏 可以处理负权边，可以判断负权环 其实就是在用边松弛的时候，没必要用每一条边松弛这个图，只需要使用那些上一次被更新答案的边松弛即可。 大概就是如果有负权就用 dijkstra代码 int d[MAXN]; bool vis[MAXN]; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q; int dijkstra(int s, int t){ memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while(!q.empty()){ int now = q.top().second; q.pop(); if(!vis[now]){ vis[now] = true; for(int i = he[now]; i; i = ne[i]){ Edge&amp; e = ed[i]; if(d[e.to] &gt; d[now] + e.dist){ d[e.to] = d[now] + e.dist; q.push(make_pair(d[e.to], e.to)); } } } } return d[t] == INF ? -1 : d[t]; } SPFA代码 bool inq[MAXN]; queue&lt;int&gt; q; inline int spfa(int s, int t) { q.push(s); inq[s] = true; memset(d, 0x3f, sizeof(d)); d[s] = 0; while (!q.empty()) { int now = q.front(); q.pop(); inq[now] = false; for (int i = he[now]; i; i = ne[i]) { Edge &amp;e = ed[i]; if (d[now] + e.dist &lt; d[e.to]) { d[e.to] = d[now] + e.dist; if (!inq[e.to]) { q.push(e.to); inq[e.to] = true; } } } } return d[t] == INF ? -1 : d[t]; } 待做例题 luogu模板题 P3371 luoug P1119 灾后重建(感受一下离线) luogu P1629 邮递员送信（反图） Tarjan 用途 很多很多很多…… 如果用来缩点。就是在一个有环有向图里面，我们可以用tarjan把强连通分量_们_弄成一个点，当然这个点权可能就是_最大/最小值_或者_和_。然后肯定就成DAG了，然后可以尽情的TopSort了。 四种边： 为了更好理解tarjan我们定义四种边。 P.S:只要_DFN小_那就在以其为根的子树中。 树枝边：A边终点未访问过（找到一个有边相连而且没有被访问的就好） 前向边：B边终点已被访问过，且dfn[v]&gt;dfn[u]，说明在子树中（只需要判断是否有边相连而且在栈内即可） 后向边：C边终点已被访问过且不在子树中，终点在栈中 横叉边：D边终点已被访问过且不在子树中 且 已经出栈 分别操作： 图自老师的PPT 维护一个数组low，low[u]代表点u所能到达的，深度最小的点的dfs序编号。 更新LOW 对于边(u,v) 若为树枝边，则用low[v]更新 若为后向边，则用dfn[v]更新 后向边一定已经更新过，所以不需要处理 横叉边属于别的强连通分量，别瞎操心 简单来说，若使用边(u,v)更新LOW[u]，那么: LOW[u]=MIN{ DFN(v)//后向边 LOW(v)//树枝边 DFN(u)//当然初始化就是自己的dfs序。特别想一下这个点没有出边的情况。 } 示例代码 int s[MAXN], stop; int dfn[MAXN], low[MAXN]; int scccnt, sccnum[MAXN];//属于同一个强连通分量的，sccnum的值相同。 int dfscnt; inline void tarjan(int now){ dfn[now] = low[now] = ++dfscnt; s[stop++] = now; for (int i = he[now]; i != 0 ; i = ne[i]){ if (!dfn[ed[i]]) { tarjan(ed[i]); low[now] = min(low[now], low[ed[i]]); } else if(!sccnum[ed[i]]) { low[now] = min(low[now], dfn[ed[i]]); } } if (dfn[now] == low[now]) { scccnt++; do { sccnum[s[--stop]] = scccnt; } while(s[stop] != now); } } 待做例题 luogu模板 P3387]]></content>
      <categories>
        <category>OI</category>
        <category>培训</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-3372】【模板】线段树 1]]></title>
    <url>%2Fe3-80-90luogu-3372-e3-80-91-e3-80-90-e6-a8-a1-e6-9d-bf-e3-80-91-e7-ba-bf-e6-ae-b5-e6-a0-91-1%2F</url>
    <content type="text"><![CDATA[#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; using namespace std; const int _ = 400010; #define ll long long struct Node{ ll S; ll tar; Node * lson, * rson; Node(){ S = tar = 0; lson = rson = NULL; } }POOL[_]; int __tot__ = 0; inline Node * malloc_(){return &amp;POOL[__tot__++];} inline void updata(Node * tree) { tree -&gt; S = tree -&gt; lson -&gt; S + tree -&gt; rson -&gt; S; } void build(Node * tree, int l, int r) { if(l == r) { scanf(&quot;%lld&quot;, &amp;tree -&gt; S); return ; } int mid = (l + r) &gt;&gt; 1; tree -&gt; lson = malloc_(); tree -&gt; rson = malloc_(); build(tree -&gt; lson, l, mid); build(tree -&gt; rson, mid + 1, r); updata(tree); } void tar(Node * tree, int l, int r, ll val) { if(tree == NULL) return; tree -&gt; S += (r - l + 1) * val; tree -&gt; tar += val; } void push(Node * tree, int l, int r) { if(tree == NULL || l == r) return;///////////// int mid = (l + r) &gt;&gt; 1; tar(tree -&gt; lson, l, mid, tree -&gt; tar); tar(tree -&gt; rson, mid + 1, r, tree -&gt; tar); tree -&gt; tar = 0; } void change(Node * tree, int nowl, int nowr, ll val, int l, int r) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) { tar(tree, nowl, nowr, val); return ; } push(tree, nowl, nowr); int mid = (nowl + nowr) &gt;&gt; 1; if(l &lt;= mid) change(tree -&gt; lson, nowl, mid, val, l, r); if(r &gt; mid) change(tree -&gt; rson, mid + 1, nowr, val, l, r); updata(tree); } ll query(Node * tree, int nowl,int nowr, int l, int r) { if(l &lt;= nowl &amp;&amp; nowr &lt;= r) return tree -&gt; S; int mid = (nowl + nowr) &gt;&gt; 1; ll ans = 0; push(tree, nowl, nowr); if(l &lt;= mid) ans += query(tree -&gt; lson, nowl, mid, l, r); if(r &gt; mid) ans += query(tree -&gt; rson, mid + 1, nowr, l, r); return ans ; } int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); Node * root = malloc_(); build(root, 1, n); for(register int i = 1;i &lt;= m;i++) { int op; scanf(&quot;%d&quot;, &amp;op); if(op == 1) { int x, y; ll k; scanf(&quot;%d%d%lld&quot;, &amp;x, &amp;y, &amp;k); change(root, 1, n, k, x, y); } else { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); printf(&quot;%lld\n&quot;, query(root, 1, n, x, y)); } } return 0; } #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #define root 1,n,1 #define lson l,m,rt&lt;&lt;1 #define rson m+1,r,rt&lt;&lt;1|1 #define nownode l,r,rt #define max(a,b) (a)&gt;(b)?(a):(b)//虽然可以用stl或者自己写个正儿八经的函数，但是这样写起来据说能快一点，毕竟调用栈空间也是需要时间的。。。 #define min(a,b) (a)&lt;(b)?(a):(b) //同上 #define LL long long using namespace std; const int MAXN=100000+10; long long z[MAXN&lt;&lt;2];//位运算，相当于MAXN*4 long long col[MAXN&lt;&lt;2];//同上 void updata(int rt)//更新数据函数，rt为待更新的结点编号 { z[rt]=z[rt&lt;&lt;1]+z[rt&lt;&lt;1|1];//位运算，相当于z[rt/2]+z[rt/2+1] } void color(int l,int r,int rt,LL v) //参数说明：区间【l，r】，编号为rt，打上“加上V”的标记 { z[rt]+=(r-l+1)*v;//区间修改的话，需要打lazy标记， //也就是需要先将此处结点（被修改区间完全覆盖的）数据更新（因为是在某一段区间的所有数都加一个数V，所以这段区间的和就要加上【区间长度】*V就好） col[rt]+=v; //为它这个结点打lazy，表示rt这个结点的孩子们都要加上V，（现在还没加上V，先打标记，不继续操作）。 //标记颜色需要累加，不能col[rt]=v; } void push_color(int l,int r,int rt)//下放标记 //参数说明：区间【l，r】，编号为rt { if(col[rt]!=0)//如果这个结点有标记的话 //（废话。。没标记还下放个pi { int m=(l+r)&gt;&gt;1;//相当于（l+r）/2 color(lson,col[rt]);//为rt结点的左儿子打标记 color(rson,col[rt]);//为rt结点的左儿子打标记 col[rt]=0;//因为已经下放了，就清除这个结点的标记 } } void build(int l,int r,int rt)//建立这个线段树 //建立区间【l，r】，编号为rt的结点 //虽然根据rt就可以算出来区间【l，r】，但是这样写会方便很多 { if(l==r)//已经是叶子结点了 { scanf(&quot;%lld&quot;,&amp;z[rt]);//直接读入就好 return ;//建立完成此节点就GG } int m=(l+r)&gt;&gt;1;//相当于（l+r）/2 build(lson);//建立左儿子 build(rson);//建立右儿子 //WARNING：以上两行顺序不可换。 updata(rt);//俩儿子建立完成了，那就根据俩儿子的数据，来更新自己的数据就欧克。 } void modify(int l,int r,int rt,int nowl,int nowr,LL v)//修改函数 //参数说明：在区间【l，r】（编号为rt）内为【nowl,nowr】区间加上V //貌似很难懂 //其实就是，我们始终要修改【nowl,nowr】这个很大的区间，但是现在我们现在管不了那么多，就先修改【nowl,nowr】在【l，r】里面的部分。 { if(nowl&lt;=l&amp;&amp;r&lt;=nowr)//如果这个【l，r】区间已经被【nowl,nowr】完全包含了，也就是【l，r】里面的数据都要修改。 { color(nownode,v);//直接打标记就欧克 return ; } push_color(nownode);//下放标记，没错，千辛万苦打的标记就是在修改/查询的时候下放 int m=(l+r)&gt;&gt;1;////相当于（l+r）/2 if(nowl&lt;=m)modify(lson,nowl,nowr,v);//如果需要修改左儿子，那就修改它 if(nowr&gt;m)modify(rson,nowl,nowr,v);//如果需要修改右儿子，那就修改它 updata(rt);//俩儿子修改完后，更新这个结点数据 } LL query(int l,int r,int rt,int nowl,int nowr)//终于写到查询了。。。。 //参数说明：在区间【l，r】，编号rt，查询sum（【nowl，nowr】） //貌似又很难懂 //其实就是，我们始终要查询【nowl,nowr】这个很大的区间和，但是现在我们现在管不了那么多，就先查询【nowl,nowr】在【l，r】里面的部分数据的和。 { if(nowl&lt;=l&amp;&amp;r&lt;=nowr) { return z[rt]; } int m=(l+r)&gt;&gt;1; LL ans=0;//WARNKING ::: VAL ans MUST INIT push_color(nownode); //下放标记，没错，千辛万苦打的标记就是在修改/查询的时候下放 if(nowl&lt;=m)ans+=query(lson,nowl,nowr); //如果右儿子在查询的区间里面，那就ans再加上右儿子的和 if(nowr&gt;m)ans+=query(rson,nowl,nowr);//如果右儿子在查询的区间里面，那就ans再加上右儿子的和 return ans; } int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); build(root); int op,x,y;LL k; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;op); if(op==1) { scanf(&quot;%d%d%lld&quot;,&amp;x,&amp;y,&amp;k); modify(root,x,y,k); } else { scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%lld\n&quot;,query(root,x,y)); } } return 0; //不要忘了好习惯。 }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-AT46 】【AtCoder】リモコン]]></title>
    <url>%2Fe3-80-90luogu-at46-e3-80-91-e3-80-90atcoder-e3-80-91-e3-83-aa-e3-83-a2-e3-82-b3-e3-83-b3%2F</url>
    <content type="text"><![CDATA[推荐一个做法：迭代加深搜索 感觉比广搜要好写一些，其实就是加了一点别的东西的DFS 这里是luogu网校提高组讲义里的一段话，供参考。 具体来看下代码。 希望通过此题，大家能了解到这个比较冷门的算法，自我感觉挺好用。。。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; int A,B; bool haveAns=false;//用途如名，判断是否已经找到解 void DFS(int x,int deep,const int maxDeep) //x是当前已经调到的值；deep是迭代深度；maxDeep是规定的最大迭代深度，目的就是我们不会让dfs沿着解答树的一边一头扎下去。 { if(haveAns)return; if(x==B){//找到解 haveAns=true;//更新状态 return; } if(deep&gt;maxDeep)return;//限制最大迭代深度 DFS(x+5,deep+1,maxDeep); DFS(x+1,deep+1,maxDeep); DFS(x+10,deep+1,maxDeep); DFS(x-1,deep+1,maxDeep); DFS(x-5,deep+1,maxDeep); DFS(x-10,deep+1,maxDeep); } int main() { scanf(&quot;%d%d&quot;,&amp;A,&amp;B); if(A==B){cout&lt;&lt;0&lt;&lt;endl;return 0;}//之前的温度和调完的温度一样那还调啥，直接输出0步。 int deep=abs(A-B)+5;//我们规定一个最大的深度（即每次调高或者调低一度，最大需要调节abs（A-B）次） //至于+5.。。这个是玄学，反正大一点总是好的。。+1就可以其实，但是时间充足，不差钱（时间）。。 int i; for(i=1;i&lt;=deep&amp;&amp;!haveAns;i++)//循环条件，就是没有超过最大深度，而且没找到解。 DFS(A,1,i); //这样答案就是i-1。我们来考虑一下这东西的流程。 //我先用dfs判断，如果调1步行不行； //如果不行，那就调两步行不行； //如果还不行，那就调三步行不行 //如果还不行，那就调四步行不行 //…………………… //最后总有一种步数是可以的，这时候跳出循环，然后输出结果。 cout&lt;&lt;--i&lt;&lt;endl; return 0; } //其实代码炒鸡短。。去掉注释大概30行左右。（当然还能更短）]]></content>
      <categories>
        <category>AtCoder</category>
        <category>luogu</category>
        <category>OI</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-4051】【JSOI2007】字符加密]]></title>
    <url>%2Fe3-80-90luogu-4051-e3-80-91-e3-80-90jsoi2007-e3-80-91-e5-ad-97-e7-ac-a6-e5-8a-a0-e5-af-86%2F</url>
    <content type="text"><![CDATA[提供一种思路，不保证是最好的，但是代码好像是最短的。。。。。 例如JSOI07， 可以读作： - JSOI07 - SOI07J - OI07JS - I07JSO - 07JSOI - 7JSOI0 把它们按照字符串的大小排序： - 07JSOI - 7JSOI0 - I07JSO - JSOI07 - OI07JS - SOI07J 读出最后一列字符：I0O7SJ， 对于此题，其实还有一种比较恶心（玄学）的做法。 对，没错确实恶心。 其实对于给出的字符串S，我们可以有strlen(S)种读法，其实我们不关心这些读法到底是什么，我们只需要关心这些读法的最后一个字符是什么。 那么如何得知最后一个字符是什么呢？ 显然，你只需要知道这一个读法第一个字符就可以。 去观察一下那些字符串： 原字符串：JSOI07 可以读作： - JSOI07 - SOI07J - OI07JS - I07JSO - 07JSOI - 7JSOI0 //以这个为例，最后一个字符是0，第一个是7 我们可以得到如下结论，如果最后一个字符是原字符串的第i个，那它对应的第一个字符是原字符串的第i + 1个。 所以我们知道这个字符串各种读法 排好序后的第一个字符就可以了， 那这个又咋求呢？ （直接排原字符串就好了啊。。。。） 嗯对， 就这么骚。。 简单说就是把源字符串本身进行排序，然后对于每个字符找到原来字符串的前一个，组成字符串输出就可以了。。。 代码如下： //代码中，我没有直接对原字符串排序，我排了一下这个字符串的顺序，就是我没有改变原字符串，而是记录了某个字符排序前的位置。 //紫书里面说过好像。叫什么间接排序之类的。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int _ = 200010; char S[_]; int S_id[_]; int len; bool __CMP(const int &amp;x, const int &amp;y) { int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) {px++;py++;k++;} return S[px] &lt; S[py]; }//排序规则这里，while循环是为了防止字符重复，重复的话就往后找（字典序哦~）， //k的话。。。为了防止全都是重复的，然后找个不停。。。 //有一个点就卡这个东西。。 int main() { scanf(&quot;%s&quot;, S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i];//把原来的串再接到原来的串后面，找“前一个”字符时比较方便。 for (int i = 0; i &lt; len; i++) S_id[i] = i;//记录原来字符串，每个字符的位置，没排序前，第一个就在原来字符串的第一个，第二个就在第二个 sort(S_id, S_id + len, __CMP); //对这个记录序号的数组排序。 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]);//这里输出就好了，三目运算符自己看一下就欧克了。 return 0; } 最后再展示一下没有注释的代码，得瑟一下代码长度 数据可能再稍微强一点我就GG了…… #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int _ = 200010; char S[_]; int S_id[_]; int len; bool oldsu(const int &amp;x, const int &amp;y) { int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) {px++;py++;k++;} return S[px] &lt; S[py]; } int main() { scanf(&quot;%s&quot;, S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i]; for (int i = 0; i &lt; len; i++) S_id[i] = i; sort(S_id, S_id + len, oldsu); //100000 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]); return 0; }]]></content>
      <categories>
        <category>luogu</category>
        <category>OI</category>
        <category>省选题目</category>
      </categories>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【luogu-P4051】【JSOI2007】字符加密]]></title>
    <url>%2F%E3%80%90luogu-P4051%E3%80%91%E3%80%90JSOI2007%E3%80%91%E5%AD%97%E7%AC%A6%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[提供一种思路，不保证是最好的，但是代码好像是最短的。。。。。 例如JSOI07， 可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ， 对于此题，其实还有一种比较恶心（玄学）的做法。 对，没错确实恶心。 其实对于给出的字符串S，我们可以有strlen(S)种读法，其实我们不关心这些读法到底是什么，我们只需要关心这些读法的最后一个字符是什么。 那么如何得知最后一个字符是什么呢？ 显然，你只需要知道这一个读法第一个字符就可以。 去观察一下那些字符串： 原字符串：JSOI07 可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 //以这个为例，最后一个字符是0，第一个是7 我们可以得到如下结论，如果最后一个字符是原字符串的第i个，那它对应的第一个字符是原字符串的第i + 1个。 所以我们知道这个字符串各种读法 排好序后的第一个字符就可以了， 那这个又咋求呢？ （直接排原字符串就好了啊。。。。） 嗯对， 就这么骚。。 简单说就是把源字符串本身进行排序，然后对于每个字符找到原来字符串的前一个，组成字符串输出就可以了。。。 代码如下： 1234567891011121314151617181920212223242526272829//代码中，我没有直接对原字符串排序，我排了一下这个字符串的顺序，就是我没有改变原字符串，而是记录了某个字符排序前的位置。//紫书里面说过好像。叫什么间接排序之类的。#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int _ = 200010;char S[_];int S_id[_];int len;bool __CMP(const int &amp;x, const int &amp;y)&#123; int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) &#123;px++;py++;k++;&#125; return S[px] &lt; S[py];&#125;//排序规则这里，while循环是为了防止字符重复，重复的话就往后找（字典序哦~），//k的话。。。为了防止全都是重复的，然后找个不停。。。//有一个点就卡这个东西。。int main()&#123; scanf("%s", S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i];//把原来的串再接到原来的串后面，找“前一个”字符时比较方便。 for (int i = 0; i &lt; len; i++) S_id[i] = i;//记录原来字符串，每个字符的位置，没排序前，第一个就在原来字符串的第一个，第二个就在第二个 sort(S_id, S_id + len, __CMP); //对这个记录序号的数组排序。 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]);//这里输出就好了，三目运算符自己看一下就欧克了。 return 0;&#125; 最后再展示一下没有注释的代码，得瑟一下代码长度 数据可能再稍微强一点我就GG了…… 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int _ = 200010;char S[_];int S_id[_];int len;bool oldsu(const int &amp;x, const int &amp;y)&#123; int px = x, py = y, k = 0; while (S[px] == S[py] &amp;&amp; k &lt; 50) &#123;px++;py++;k++;&#125; return S[px] &lt; S[py];&#125;int main()&#123; scanf("%s", S); len = strlen(S); for (int i = 0; i &lt; len; i++) S[i + len] = S[i]; for (int i = 0; i &lt; len; i++) S_id[i] = i; sort(S_id, S_id + len, oldsu); //100000 for (int i = 0; i &lt; len; i++) putchar(S[(S_id[i] == 0 ? (len - 1) : (S_id[i] - 1))]); return 0;&#125;]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营-Day2]]></title>
    <url>%2Fluogu%E6%98%A5%E4%BB%A4%E8%90%A5-Day2%2F</url>
    <content type="text"><![CDATA[很多来自WJH老师的课件，若侵权then删除 TopSort 很少有特别裸的，图论反正都是这熊样，先建图，然后各种套模板 适用性 TopSort适用于DAG。 判断题目的关系是否能构成DAG。 123456789101112131415161718int ind[MAXN];int d[MAXN];int q[MAXN], qhead = 0, qtail = 0;//队列相关void topo() &#123; for (int i = 1; i &lt;= n; i++) &#123; if (!ind[i]) q[qtail++] = i; &#125; while (qhead != qtail) &#123; int now = q[qhead++]; for (int i = he[now]; i; i = ne[i]) &#123; Edge &amp;e = ed[i]; d[e.to] = max(d[e.to], d[now] + 1);//DAG上最长路 if (!--ind[e.to]) q[qtail++] = e.to; &#125; &#125;&#125; 待做例题 luoguP1983 车站分级 最小生成树&amp;并查集 1234567891011121314151617181920212223242526272829303132333435struct UnionSet &#123; int f[MAXN]; UnionSet(int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; f[i] = i; &#125; &#125; UnionSet()&#123;&#125; void uni(int x, int y) &#123; f[find(x)] = find(y); &#125; bool query(int x, int y) &#123; return find(x) == find(y); &#125; int find(int x) &#123; return f[x] == x ? x : (f[x] = find(f[x])); &#125;&#125; us;void kruskal() &#123; sort(edges, edges+m); us = UnionSet(n); for (int i = 0; i &lt; m &amp;&amp; etop &lt; n * 2 - 1; i++) &#123; Edge &amp;e = edges[i]; if (!us.query(e.from, e.to)) &#123; insert(e.from, e.to, e.dist); insert(e.to, e.from, e.dist); us.uni(e.from, e.to); &#125; &#125;&#125; 待做例题 luogu 模板题 P3366 luogu 买礼物P1194 最短路 两大“冤家”算法比较 Dijkstra算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：O(n²)（原版）/O(mlogn)(堆优化) 无法处理负权 每次找到离当前结点直接相连且最短的点，设置为确定点（这里可以看初如果边权为负的话，就不能确定这个点是确定点=GG）。再以当前点为当前结点，继续松弛。 SPFA算法，即队列优化的Bellman-Ford算法： 单源最短路，求出某个点s到所有点的最短路长度 时间复杂度：声称为O(m)，最坏O(nm)，容易卡到最坏 可以处理负权边，可以判断负权环 其实就是在用边松弛的时候，没必要用每一条边松弛这个图，只需要使用那些上一次被更新答案的边松弛即可。 大概就是如果有负权就用 dijkstra代码 1234567891011121314151617181920212223int d[MAXN];bool vis[MAXN];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q;int dijkstra(int s, int t)&#123; memset(d, 0x3f, sizeof(d)); d[s] = 0; q.push(make_pair(0, s)); while(!q.empty())&#123; int now = q.top().second; q.pop(); if(!vis[now])&#123; vis[now] = true; for(int i = he[now]; i; i = ne[i])&#123; Edge&amp; e = ed[i]; if(d[e.to] &gt; d[now] + e.dist)&#123; d[e.to] = d[now] + e.dist; q.push(make_pair(d[e.to], e.to)); &#125; &#125; &#125; &#125; return d[t] == INF ? -1 : d[t];&#125; SPFA代码 1234567891011121314151617181920212223bool inq[MAXN];queue&lt;int&gt; q;inline int spfa(int s, int t) &#123; q.push(s); inq[s] = true; memset(d, 0x3f, sizeof(d)); d[s] = 0; while (!q.empty()) &#123; int now = q.front(); q.pop(); inq[now] = false; for (int i = he[now]; i; i = ne[i]) &#123; Edge &amp;e = ed[i]; if (d[now] + e.dist &lt; d[e.to]) &#123; d[e.to] = d[now] + e.dist; if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = true; &#125; &#125; &#125; &#125; return d[t] == INF ? -1 : d[t];&#125; 待做例题 luogu模板题 P3371 luoug P1119 灾后重建(感受一下离线) luogu P1629 邮递员送信（反图） Tarjan 用途 很多很多很多…… 如果用来缩点。就是在一个有环有向图里面，我们可以用tarjan把强连通分量们弄成一个点，当然这个点权可能就是最大/最小值或者和。然后肯定就成DAG了，然后可以尽情的TopSort了。 四种边： 为了更好理解tarjan我们定义四种边。 P.S:只要DFN小那就在以其为根的子树中。 树枝边：A边终点未访问过（找到一个有边相连而且没有被访问的就好） 前向边：B边终点已被访问过，且dfn[v]&gt;dfn[u]，说明在子树中（只需要判断是否有边相连而且在栈内即可） 后向边：C边终点已被访问过且不在子树中，终点在栈中 横叉边：D边终点已被访问过且不在子树中 且 已经出栈 分别操作： 图自老师的PPT 维护一个数组low，low[u]代表点u所能到达的，深度最小的点的dfs序编号。 更新LOW 对于边(u,v) 若为树枝边，则用low[v]更新 若为后向边，则用dfn[v]更新 后向边一定已经更新过，所以不需要处理 横叉边属于别的强连通分量，别瞎操心 简单来说，若使用边(u,v)更新LOW[u]，那么: 12345LOW[u]=MIN&#123; DFN(v)//后向边 LOW(v)//树枝边 DFN(u)//当然初始化就是自己的dfs序。特别想一下这个点没有出边的情况。&#125; 示例代码 123456789101112131415161718192021222324int s[MAXN], stop;int dfn[MAXN], low[MAXN];int scccnt, sccnum[MAXN];//属于同一个强连通分量的，sccnum的值相同。int dfscnt;inline void tarjan(int now)&#123; dfn[now] = low[now] = ++dfscnt; s[stop++] = now; for (int i = he[now]; i != 0 ; i = ne[i])&#123; if (!dfn[ed[i]]) &#123; tarjan(ed[i]); low[now] = min(low[now], low[ed[i]]); &#125; else if(!sccnum[ed[i]]) &#123; low[now] = min(low[now], dfn[ed[i]]); &#125; &#125; if (dfn[now] == low[now]) &#123; scccnt++; do &#123; sccnum[s[--stop]] = scccnt; &#125; while(s[stop] != now); &#125;&#125; 待做例题 luogu模板 P3387]]></content>
      <tags>
        <tag>洛谷网课</tag>
        <tag>外出培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[luogu春令营-Day1]]></title>
    <url>%2Fluogu%E6%98%A5%E4%BB%A4%E8%90%A5-Day1%2F</url>
    <content type="text"><![CDATA[首先这些文字都是给我自己看的，所以比较土。。 博客没有写完，有空再写…… 二分&amp;三分 之所以一开始就聊二/三分，是因为我觉得这东西比较有意思，而且主要是我一直不会。。。。 首先，最大值最小化和最小值最大化是两个二分的标志，当然没有这两个标志的问题也可能用二分。 二分，一般有两种情况：最小值最大化和最小值最大化。 最大值最小化二分 一般的二分答案，其实就是在一个单调的函数上***摩擦***的操作。 这个函数可以不存在解析式，但是这个函数可以通过自变量取值得到函数值即可。 如果f(x)这个函数是判断取X是否合法的函数，而且具有单调性，那么其实这个函数的图像是这样的 或者 当x的值可以的时候，函数返回值为true，即为1。 当x的值不可以的时候，函数返回值为false，即为0。 二分查找的目的就在于找到函数图像的那个折点。 当然更复杂的就是函数值小于某个值的最大的x和函数值大于某个值的最小x（函数单调递增）。 来看一道例题。 题目描述： 输入N个数，把这N个数划分为M段，SUM(i)表示第i段的区间和，现在需要得到一中划分方法，使最大的区间和最小。 解题思路： 既然要求最大的区间和最小，那我们先分解这个问题；第一步是求出最大的区间和；然后第二步就是找出最小的那一个最大区间和。废话 我们先设最大的区间和为x，易得:任意一个i都可以使SUM(i)&lt;=x成立。 然后通过二分答案的方法查找一个在满足条件的情况下最小的x。 这样问题就转化为找下图中的折点。 12345678910//最大值最小化int le = 1, ri = n, mid, ans;while (le &lt;= ri)&#123; mid = (le + ri) / 2; if (check(mid)) ans = mid, ri = mid - 1; else le = mid + 1;&#125;ans 1234567891011121314151617181920212223242526272829303132//最小值最大化int le = 1, ri = n, mid, ans;while (le &lt;= ri)&#123; mid = (le + ri) / 2; if (check(mid)) ans = mid, le = mid + 1; else ri = mid - 1;&#125;ans//求实数double le = 1, ri = n, mid;for (int i = 1; i &lt;= 50; i++)&#123; mid = (le + ri) / 2; if (check(mid)) ri = mid; else le = mid;&#125;ans//三分le = 0; ri = min(i - 1, n - i);while (le + 1 &lt;= ri)&#123; w1 = (ri - le) / 3 + le; w2 = ri - (ri - le) / 3; v1 = make(i, w1); v2 = make(i, w2); if (v1 &gt; v2) ri = w2 - 1; else le = w1 + 1;&#125;le DFS判断存在环]]></content>
      <tags>
        <tag>洛谷网课</tag>
        <tag>外出培训</tag>
      </tags>
  </entry>
</search>
